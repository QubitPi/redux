"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9533],{904:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"usage/reducing-boilerplate","title":"Reducing Boilerplate","description":"Redux is in part inspired by Flux, and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we\'d like our code to be, depending on personal style, team preferences, longer term maintainability, and so on.","source":"@site/../docs/usage/ReducingBoilerplate.md","sourceDirName":"usage","slug":"/usage/reducing-boilerplate","permalink":"/usage/reducing-boilerplate","draft":false,"unlisted":false,"editUrl":"https://github.com/reduxjs/redux/edit/master/website/../docs/usage/ReducingBoilerplate.md","tags":[],"version":"current","lastUpdatedAt":1747212223000,"frontMatter":{"id":"reducing-boilerplate","title":"Reducing Boilerplate"},"sidebar":"docs","previous":{"title":"Initializing State","permalink":"/usage/structuring-reducers/initializing-state"},"next":{"title":"Deriving Data with Selectors","permalink":"/usage/deriving-data-selectors"}}');var o=t(4848),r=t(8453);const a={id:"reducing-boilerplate",title:"Reducing Boilerplate"},i="Reducing Boilerplate",c={},d=[{value:"Actions",id:"actions",level:2},{value:"Action Creators",id:"action-creators",level:2},{value:"<code>actionCreators.js</code>",id:"actioncreatorsjs",level:4},{value:"<code>AddTodo.js</code>",id:"addtodojs",level:4},{value:"Generating Action Creators",id:"generating-action-creators",level:3},{value:"Async Action Creators",id:"async-action-creators",level:2},{value:"<code>actionCreators.js</code>",id:"actioncreatorsjs-1",level:4},{value:"<code>UserInfo.js</code>",id:"userinfojs",level:4},{value:"Note",id:"note",level:5},{value:"<code>actionCreators.js</code>",id:"actioncreatorsjs-2",level:4},{value:"<code>UserInfo.js</code>",id:"userinfojs-1",level:4},{value:"Reducers",id:"reducers",level:2},{value:"Generating Reducers",id:"generating-reducers",level:3}];function l(e){const n={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"reducing-boilerplate",children:"Reducing Boilerplate"})}),"\n",(0,o.jsxs)(n.p,{children:["Redux is in part ",(0,o.jsx)(n.a,{href:"/understanding/history-and-design/prior-art",children:"inspired by Flux"}),", and the most common complaint about Flux is how it makes you write a lot of boilerplate. In this recipe, we will consider how Redux lets us choose how verbose we'd like our code to be, depending on personal style, team preferences, longer term maintainability, and so on."]}),"\n",(0,o.jsx)(n.h2,{id:"actions",children:"Actions"}),"\n",(0,o.jsxs)(n.p,{children:["Actions are plain objects describing what happened in the app, and serve as the sole way to describe an intention to mutate the data. It's important that ",(0,o.jsxs)(n.strong,{children:["actions being objects you have to dispatch is not boilerplate, but one of the ",(0,o.jsx)(n.a,{href:"/understanding/thinking-in-redux/three-principles",children:"fundamental design choices"})," of Redux"]}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["There are frameworks claiming to be similar to Flux, but without a concept of action objects. In terms of being predictable, this is a step backwards from Flux or Redux. If there are no serializable plain object actions, it is impossible to record and replay user sessions, or to implement ",(0,o.jsx)(n.a,{href:"https://www.youtube.com/watch?v=xsSnOQynTHs",children:"hot reloading with time travel"}),". If you'd rather modify data directly, you don't need Redux."]}),"\n",(0,o.jsx)(n.p,{children:"Actions look like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"{ type: 'ADD_TODO', text: 'Use Redux' }\n{ type: 'REMOVE_TODO', id: 42 }\n{ type: 'LOAD_ARTICLE', response: { ... } }\n"})}),"\n",(0,o.jsxs)(n.p,{children:["It is a common convention that actions have a constant type that helps reducers (or Stores in Flux) identify them. We recommend that you use strings and not ",(0,o.jsx)(n.a,{href:"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol",children:"Symbols"})," for action types, because strings are serializable, and by using Symbols you make recording and replaying harder than it needs to be."]}),"\n",(0,o.jsx)(n.p,{children:"In Flux, it is traditionally thought that you would define every action type as a string constant:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const ADD_TODO = 'ADD_TODO'\nconst REMOVE_TODO = 'REMOVE_TODO'\nconst LOAD_ARTICLE = 'LOAD_ARTICLE'\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Why is this beneficial? ",(0,o.jsx)(n.strong,{children:"It is often claimed that constants are unnecessary, and for small projects, this might be correct."})," For larger projects, there are some benefits to defining action types as constants:"]}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"It helps keep the naming consistent because all action types are gathered in a single place."}),"\n",(0,o.jsx)(n.li,{children:"Sometimes you want to see all existing actions before working on a new feature. It may be that the action you need was already added by somebody on the team, but you didn't know."}),"\n",(0,o.jsx)(n.li,{children:"The list of action types that were added, removed, and changed in a Pull Request helps everyone on the team keep track of scope and implementation of new features."}),"\n",(0,o.jsxs)(n.li,{children:["If you make a typo when importing an action constant, you will get ",(0,o.jsx)(n.code,{children:"undefined"}),". Redux will immediately throw when dispatching such an action, and you'll find the mistake sooner."]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"It is up to you to choose the conventions for your project. You may start by using inline strings, and later transition to constants, and maybe later group them into a single file. Redux does not have any opinion here, so use your best judgment."}),"\n",(0,o.jsx)(n.h2,{id:"action-creators",children:"Action Creators"}),"\n",(0,o.jsx)(n.p,{children:"It is another common convention that, instead of creating action objects inline in the places where you dispatch the actions, you would create functions generating them."}),"\n",(0,o.jsxs)(n.p,{children:["For example, instead of calling ",(0,o.jsx)(n.code,{children:"dispatch"})," with an object literal:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// somewhere in an event handler\ndispatch({\n  type: 'ADD_TODO',\n  text: 'Use Redux'\n})\n"})}),"\n",(0,o.jsx)(n.p,{children:"You might write an action creator in a separate file, and import it into your component:"}),"\n",(0,o.jsx)(n.h4,{id:"actioncreatorsjs",children:(0,o.jsx)(n.code,{children:"actionCreators.js"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export function addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"addtodojs",children:(0,o.jsx)(n.code,{children:"AddTodo.js"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { addTodo } from './actionCreators'\n\n// somewhere in an event handler\ndispatch(addTodo('Use Redux'))\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Action creators have often been criticized as boilerplate. Well, you don't have to write them! ",(0,o.jsx)(n.strong,{children:"You can use object literals if you feel this better suits your project."})," There are, however, some benefits for writing action creators you should know about."]}),"\n",(0,o.jsxs)(n.p,{children:["Let's say a designer comes back to us after reviewing our prototype, and tells us that we need to allow three todos maximum. We can enforce this by rewriting our action creator to a callback form with ",(0,o.jsx)(n.a,{href:"https://github.com/reduxjs/redux-thunk",children:"redux-thunk"})," middleware and adding an early exit:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function addTodoWithoutCheck(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n\nexport function addTodo(text) {\n  // This form is allowed by Redux Thunk middleware\n  // described below in \u201cAsync Action Creators\u201d section.\n  return function (dispatch, getState) {\n    if (getState().todos.length === 3) {\n      // Exit early\n      return\n    }\n    dispatch(addTodoWithoutCheck(text))\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["We just modified how the ",(0,o.jsx)(n.code,{children:"addTodo"})," action creator behaves, completely invisible to the calling code. ",(0,o.jsx)(n.strong,{children:"We don't have to worry about looking at each place where todos are being added, to make sure they have this check."})," Action creators let you decouple additional logic around dispatching an action, from the actual components emitting those actions. It's very handy when the application is under heavy development, and the requirements change often."]}),"\n",(0,o.jsx)(n.h3,{id:"generating-action-creators",children:"Generating Action Creators"}),"\n",(0,o.jsxs)(n.p,{children:["Some frameworks like ",(0,o.jsx)(n.a,{href:"https://github.com/acdlite/flummox",children:"Flummox"})," generate action type constants automatically from the action creator function definitions. The idea is that you don't need to both define ",(0,o.jsx)(n.code,{children:"ADD_TODO"})," constant and ",(0,o.jsx)(n.code,{children:"addTodo()"})," action creator. Under the hood, such solutions still generate action type constants, but they're created implicitly so it's a level of indirection and can cause confusion. We recommend creating your action type constants explicitly."]}),"\n",(0,o.jsx)(n.p,{children:"Writing simple action creators can be tiresome and often ends up generating redundant boilerplate code:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export function addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n\nexport function editTodo(id, text) {\n  return {\n    type: 'EDIT_TODO',\n    id,\n    text\n  }\n}\n\nexport function removeTodo(id) {\n  return {\n    type: 'REMOVE_TODO',\n    id\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"You can always write a function that generates an action creator:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function makeActionCreator(type, ...argNames) {\n  return function (...args) {\n    const action = { type }\n    argNames.forEach((arg, index) => {\n      action[argNames[index]] = args[index]\n    })\n    return action\n  }\n}\n\nconst ADD_TODO = 'ADD_TODO'\nconst EDIT_TODO = 'EDIT_TODO'\nconst REMOVE_TODO = 'REMOVE_TODO'\n\nexport const addTodo = makeActionCreator(ADD_TODO, 'text')\nexport const editTodo = makeActionCreator(EDIT_TODO, 'id', 'text')\nexport const removeTodo = makeActionCreator(REMOVE_TODO, 'id')\n"})}),"\n",(0,o.jsxs)(n.p,{children:["There are also utility libraries to aid in generating action creators, such as ",(0,o.jsx)(n.a,{href:"https://github.com/pauldijou/redux-act",children:"redux-act"})," and ",(0,o.jsx)(n.a,{href:"https://github.com/acdlite/redux-actions",children:"redux-actions"}),". These can help reduce boilerplate code and enforce adherence to standards such as ",(0,o.jsx)(n.a,{href:"https://github.com/acdlite/flux-standard-action",children:"Flux Standard Action (FSA)"}),"."]}),"\n",(0,o.jsx)(n.h2,{id:"async-action-creators",children:"Async Action Creators"}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.a,{href:"/understanding/thinking-in-redux/glossary#middleware",children:"Middleware"})," lets you inject custom logic that interprets every action object before it is dispatched. Async actions are the most common use case for middleware."]}),"\n",(0,o.jsxs)(n.p,{children:["Without any middleware, ",(0,o.jsx)(n.a,{href:"/api/store#dispatchaction",children:(0,o.jsx)(n.code,{children:"dispatch"})})," only accepts a plain object, so we have to perform AJAX calls inside our components:"]}),"\n",(0,o.jsx)(n.h4,{id:"actioncreatorsjs-1",children:(0,o.jsx)(n.code,{children:"actionCreators.js"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export function loadPostsSuccess(userId, response) {\n  return {\n    type: 'LOAD_POSTS_SUCCESS',\n    userId,\n    response\n  }\n}\n\nexport function loadPostsFailure(userId, error) {\n  return {\n    type: 'LOAD_POSTS_FAILURE',\n    userId,\n    error\n  }\n}\n\nexport function loadPostsRequest(userId) {\n  return {\n    type: 'LOAD_POSTS_REQUEST',\n    userId\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"userinfojs",children:(0,o.jsx)(n.code,{children:"UserInfo.js"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { Component } from 'react'\nimport { connect } from 'react-redux'\nimport {\n  loadPostsRequest,\n  loadPostsSuccess,\n  loadPostsFailure\n} from './actionCreators'\n\nclass Posts extends Component {\n  loadData(userId) {\n    // Injected into props by React Redux `connect()` call:\n    const { dispatch, posts } = this.props\n\n    if (posts[userId]) {\n      // There is cached data! Don't do anything.\n      return\n    }\n\n    // Reducer can react to this action by setting\n    // `isFetching` and thus letting us show a spinner.\n    dispatch(loadPostsRequest(userId))\n\n    // Reducer can react to these actions by filling the `users`.\n    fetch(`http://myapi.com/users/${userId}/posts`).then(\n      response => dispatch(loadPostsSuccess(userId, response)),\n      error => dispatch(loadPostsFailure(userId, error))\n    )\n  }\n\n  componentDidMount() {\n    this.loadData(this.props.userId)\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.userId !== this.props.userId) {\n      this.loadData(this.props.userId)\n    }\n  }\n\n  render() {\n    if (this.props.isFetching) {\n      return <p>Loading...</p>\n    }\n\n    const posts = this.props.posts.map(post => (\n      <Post post={post} key={post.id} />\n    ))\n\n    return <div>{posts}</div>\n  }\n}\n\nexport default connect(state => ({\n  posts: state.posts,\n  isFetching: state.isFetching\n}))(Posts)\n"})}),"\n",(0,o.jsx)(n.p,{children:"However, this quickly gets repetitive because different components request data from the same API endpoints. Moreover, we want to reuse some of this logic (e.g., early exit when there is cached data available) from many components."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Middleware lets us write more expressive, potentially async action creators."})," It lets us dispatch something other than plain objects, and interprets the values. For example, middleware can \u201ccatch\u201d dispatched Promises and turn them into a pair of request and success/failure actions."]}),"\n",(0,o.jsxs)(n.p,{children:["The simplest example of middleware is ",(0,o.jsx)(n.a,{href:"https://github.com/reduxjs/redux-thunk",children:"redux-thunk"}),". ",(0,o.jsx)(n.strong,{children:"\u201cThunk\u201d middleware lets you write action creators as \u201cthunks\u201d, that is, functions returning functions."})," This inverts the control: you will get ",(0,o.jsx)(n.code,{children:"dispatch"})," as an argument, so you can write an action creator that dispatches many times."]}),"\n",(0,o.jsxs)(n.blockquote,{children:["\n",(0,o.jsx)(n.h5,{id:"note",children:"Note"}),"\n",(0,o.jsx)(n.p,{children:"Thunk middleware is just one example of middleware. Middleware is not about \u201cletting you dispatch functions\u201d. It's about letting you dispatch anything that the particular middleware you use knows how to handle. Thunk middleware adds a specific behavior when you dispatch functions, but it really depends on the middleware you use."}),"\n"]}),"\n",(0,o.jsxs)(n.p,{children:["Consider the code above rewritten with ",(0,o.jsx)(n.a,{href:"https://github.com/reduxjs/redux-thunk",children:"redux-thunk"}),":"]}),"\n",(0,o.jsx)(n.h4,{id:"actioncreatorsjs-2",children:(0,o.jsx)(n.code,{children:"actionCreators.js"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export function loadPosts(userId) {\n  // Interpreted by the thunk middleware:\n  return function (dispatch, getState) {\n    const { posts } = getState()\n    if (posts[userId]) {\n      // There is cached data! Don't do anything.\n      return\n    }\n\n    dispatch({\n      type: 'LOAD_POSTS_REQUEST',\n      userId\n    })\n\n    // Dispatch vanilla actions asynchronously\n    fetch(`http://myapi.com/users/${userId}/posts`).then(\n      response =>\n        dispatch({\n          type: 'LOAD_POSTS_SUCCESS',\n          userId,\n          response\n        }),\n      error =>\n        dispatch({\n          type: 'LOAD_POSTS_FAILURE',\n          userId,\n          error\n        })\n    )\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h4,{id:"userinfojs-1",children:(0,o.jsx)(n.code,{children:"UserInfo.js"})}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { Component } from 'react'\nimport { connect } from 'react-redux'\nimport { loadPosts } from './actionCreators'\n\nclass Posts extends Component {\n  componentDidMount() {\n    this.props.dispatch(loadPosts(this.props.userId))\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.userId !== this.props.userId) {\n      this.props.dispatch(loadPosts(this.props.userId))\n    }\n  }\n\n  render() {\n    if (this.props.isFetching) {\n      return <p>Loading...</p>\n    }\n\n    const posts = this.props.posts.map(post => (\n      <Post post={post} key={post.id} />\n    ))\n\n    return <div>{posts}</div>\n  }\n}\n\nexport default connect(state => ({\n  posts: state.posts,\n  isFetching: state.isFetching\n}))(Posts)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This is much less typing! If you'd like, you can still have \u201cvanilla\u201d action creators like ",(0,o.jsx)(n.code,{children:"loadPostsSuccess"})," which you'd use from a container ",(0,o.jsx)(n.code,{children:"loadPosts"})," action creator."]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Finally, you can write your own middleware."})," Let's say you want to generalize the pattern above and describe your async action creators like this instead:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export function loadPosts(userId) {\n  return {\n    // Types of actions to emit before and after\n    types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'],\n    // Check the cache (optional):\n    shouldCallAPI: state => !state.posts[userId],\n    // Perform the fetching:\n    callAPI: () => fetch(`http://myapi.com/users/${userId}/posts`),\n    // Arguments to inject in begin/end actions\n    payload: { userId }\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"The middleware that interprets such actions could look like this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function callAPIMiddleware({ dispatch, getState }) {\n  return next => action => {\n    const { types, callAPI, shouldCallAPI = () => true, payload = {} } = action\n\n    if (!types) {\n      // Normal action: pass it on\n      return next(action)\n    }\n\n    if (\n      !Array.isArray(types) ||\n      types.length !== 3 ||\n      !types.every(type => typeof type === 'string')\n    ) {\n      throw new Error('Expected an array of three string types.')\n    }\n\n    if (typeof callAPI !== 'function') {\n      throw new Error('Expected callAPI to be a function.')\n    }\n\n    if (!shouldCallAPI(getState())) {\n      return\n    }\n\n    const [requestType, successType, failureType] = types\n\n    dispatch(\n      Object.assign({}, payload, {\n        type: requestType\n      })\n    )\n\n    return callAPI().then(\n      response =>\n        dispatch(\n          Object.assign({}, payload, {\n            response,\n            type: successType\n          })\n        ),\n      error =>\n        dispatch(\n          Object.assign({}, payload, {\n            error,\n            type: failureType\n          })\n        )\n    )\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["After passing it once to ",(0,o.jsx)(n.a,{href:"/api/applymiddleware",children:(0,o.jsx)(n.code,{children:"applyMiddleware(...middlewares)"})}),", you can write all your API-calling action creators the same way:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export function loadPosts(userId) {\n  return {\n    types: ['LOAD_POSTS_REQUEST', 'LOAD_POSTS_SUCCESS', 'LOAD_POSTS_FAILURE'],\n    shouldCallAPI: state => !state.posts[userId],\n    callAPI: () => fetch(`http://myapi.com/users/${userId}/posts`),\n    payload: { userId }\n  }\n}\n\nexport function loadComments(postId) {\n  return {\n    types: [\n      'LOAD_COMMENTS_REQUEST',\n      'LOAD_COMMENTS_SUCCESS',\n      'LOAD_COMMENTS_FAILURE'\n    ],\n    shouldCallAPI: state => !state.comments[postId],\n    callAPI: () => fetch(`http://myapi.com/posts/${postId}/comments`),\n    payload: { postId }\n  }\n}\n\nexport function addComment(postId, message) {\n  return {\n    types: [\n      'ADD_COMMENT_REQUEST',\n      'ADD_COMMENT_SUCCESS',\n      'ADD_COMMENT_FAILURE'\n    ],\n    callAPI: () =>\n      fetch(`http://myapi.com/posts/${postId}/comments`, {\n        method: 'post',\n        headers: {\n          Accept: 'application/json',\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ message })\n      }),\n    payload: { postId, message }\n  }\n}\n"})}),"\n",(0,o.jsx)(n.h2,{id:"reducers",children:"Reducers"}),"\n",(0,o.jsx)(n.p,{children:"Redux reduces the boilerplate of Flux stores considerably by describing the update logic as a function. A function is simpler than an object, and much simpler than a class."}),"\n",(0,o.jsx)(n.p,{children:"Consider this Flux store:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const _todos = []\n\nconst TodoStore = Object.assign({}, EventEmitter.prototype, {\n  getAll() {\n    return _todos\n  }\n})\n\nAppDispatcher.register(function (action) {\n  switch (action.type) {\n    case ActionTypes.ADD_TODO:\n      const text = action.text.trim()\n      _todos.push(text)\n      TodoStore.emitChange()\n  }\n})\n\nexport default TodoStore\n"})}),"\n",(0,o.jsx)(n.p,{children:"With Redux, the same update logic can be described as a reducer function:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export function todos(state = [], action) {\n  switch (action.type) {\n    case ActionTypes.ADD_TODO:\n      const text = action.text.trim()\n      return [...state, text]\n    default:\n      return state\n  }\n}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"switch"})," statement is ",(0,o.jsx)(n.em,{children:"not"})," the real boilerplate. The real boilerplate of Flux is conceptual: the need to emit an update, the need to register the Store with a Dispatcher, the need for the Store to be an object (and the complications that arise when you want a universal app)."]}),"\n",(0,o.jsxs)(n.p,{children:["It's unfortunate that many still choose Flux framework based on whether it uses ",(0,o.jsx)(n.code,{children:"switch"})," statements in the documentation. If you don't like ",(0,o.jsx)(n.code,{children:"switch"}),", you can solve this with a single function, as we show below."]}),"\n",(0,o.jsx)(n.h3,{id:"generating-reducers",children:"Generating Reducers"}),"\n",(0,o.jsxs)(n.p,{children:["Let's write a function that lets us express reducers as an object mapping from action types to handlers. For example, if we want our ",(0,o.jsx)(n.code,{children:"todos"})," reducers to be defined like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"export const todos = createReducer([], {\n  [ActionTypes.ADD_TODO]: (state, action) => {\n    const text = action.text.trim()\n    return [...state, text]\n  }\n})\n"})}),"\n",(0,o.jsx)(n.p,{children:"We can write the following helper to accomplish this:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"function createReducer(initialState, handlers) {\n  return function reducer(state = initialState, action) {\n    if (handlers.hasOwnProperty(action.type)) {\n      return handlers[action.type](state, action)\n    } else {\n      return state\n    }\n  }\n}\n"})}),"\n",(0,o.jsx)(n.p,{children:"This wasn't difficult, was it? Redux doesn't provide such a helper function by default because there are many ways to write it. Maybe you want it to automatically convert plain JS objects to Immutable objects to hydrate the server state. Maybe you want to merge the returned state with the current state. There may be different approaches to a \u201ccatch all\u201d handler. All of this depends on the conventions you choose for your team on a specific project."}),"\n",(0,o.jsxs)(n.p,{children:["The Redux reducer API is ",(0,o.jsx)(n.code,{children:"(state, action) => newState"}),", but how you create those reducers is up to you."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>i});var s=t(6540);const o={},r=s.createContext(o);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);