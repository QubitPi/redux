"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7132],{8453:(e,t,s)=>{s.d(t,{R:()=>i,x:()=>c});var r=s(6540);const n={},a=r.createContext(n);function i(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),r.createElement(a.Provider,{value:t},e.children)}},8928:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"usage/structuring-reducers/basic-reducer-structure","title":"Basic Reducer Structure","description":"Structuring Reducers > Basic Reducer Structure: Overview of how reducer functions work with Redux state","source":"@site/../docs/usage/structuring-reducers/BasicReducerStructure.md","sourceDirName":"usage/structuring-reducers","slug":"/usage/structuring-reducers/basic-reducer-structure","permalink":"/usage/structuring-reducers/basic-reducer-structure","draft":false,"unlisted":false,"editUrl":"https://github.com/reduxjs/redux/edit/master/website/../docs/usage/structuring-reducers/BasicReducerStructure.md","tags":[],"version":"current","lastUpdatedAt":1747212223000,"frontMatter":{"id":"basic-reducer-structure","title":"Basic Reducer Structure","sidebar_label":"Basic Reducer Structure","description":"Structuring Reducers > Basic Reducer Structure: Overview of how reducer functions work with Redux state"},"sidebar":"docs","previous":{"title":"Prerequisite Concepts","permalink":"/usage/structuring-reducers/prerequisite-concepts"},"next":{"title":"Splitting Reducer Logic","permalink":"/usage/structuring-reducers/splitting-reducer-logic"}}');var n=s(4848),a=s(8453);const i={id:"basic-reducer-structure",title:"Basic Reducer Structure",sidebar_label:"Basic Reducer Structure",description:"Structuring Reducers > Basic Reducer Structure: Overview of how reducer functions work with Redux state"},c="Basic Reducer Structure and State Shape",o={},d=[{value:"Basic Reducer Structure",id:"basic-reducer-structure",level:2},{value:"Basic State Shape",id:"basic-state-shape",level:2}];function u(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"basic-reducer-structure-and-state-shape",children:"Basic Reducer Structure and State Shape"})}),"\n",(0,n.jsx)(t.h2,{id:"basic-reducer-structure",children:"Basic Reducer Structure"}),"\n",(0,n.jsxs)(t.p,{children:["First and foremost, it's important to understand that your entire application really only has ",(0,n.jsx)(t.strong,{children:"one single reducer function"}),": the function that you've passed into ",(0,n.jsx)(t.code,{children:"createStore"})," as the first argument. That one single reducer function ultimately needs to do several things:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["The first time the reducer is called, the ",(0,n.jsx)(t.code,{children:"state"})," value will be ",(0,n.jsx)(t.code,{children:"undefined"}),". The reducer needs to handle this case by supplying a default state value before handling the incoming action."]}),"\n",(0,n.jsx)(t.li,{children:"It needs to look at the previous state and the dispatched action, and determine what kind of work needs to be done"}),"\n",(0,n.jsx)(t.li,{children:"Assuming actual changes need to occur, it needs to create new objects and arrays with the updated data and return those"}),"\n",(0,n.jsx)(t.li,{children:"If no changes are needed, it should return the existing state as-is."}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"The simplest possible approach to writing reducer logic is to put everything into a single function declaration, like this:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"function counter(state, action) {\n  if (typeof state === 'undefined') {\n    state = 0 // If state is undefined, initialize it with a default value\n  }\n\n  if (action.type === 'INCREMENT') {\n    return state + 1\n  } else if (action.type === 'DECREMENT') {\n    return state - 1\n  } else {\n    return state // In case an action is passed in we don't understand\n  }\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"Notice that this simple function fulfills all the basic requirements. It returns a default value if none exists, initializing the store; it determines what sort of update needs to be done based on the type of the action, and returns new values; and it returns the previous state if no work needs to be done."}),"\n",(0,n.jsxs)(t.p,{children:["There are some simple tweaks that can be made to this reducer. First, repeated ",(0,n.jsx)(t.code,{children:"if"}),"/",(0,n.jsx)(t.code,{children:"else"})," statements quickly grow tiresome, so it's very common to use ",(0,n.jsx)(t.code,{children:"switch"}),' statements instead. Second, we can use default parameter values to handle the initial "no existing data" case. With those changes, the reducer would look like:']}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"function counter(state = 0, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1\n    case 'DECREMENT':\n      return state - 1\n    default:\n      return state\n  }\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"This is the basic structure that a typical Redux reducer function uses."}),"\n",(0,n.jsx)(t.h2,{id:"basic-state-shape",children:"Basic State Shape"}),"\n",(0,n.jsxs)(t.p,{children:['Redux encourages you to think about your application in terms of the data you need to manage. The data at any given point in time is the "',(0,n.jsx)(t.em,{children:"state"}),'" of your application, and the structure and organization of that state is typically referred to as its "',(0,n.jsx)(t.em,{children:"shape"}),'". The shape of your state plays a major role in how you structure your reducer logic.']}),"\n",(0,n.jsx)(t.p,{children:'A Redux state usually has a plain Javascript object as the top of the state tree. (It is certainly possible to have another type of data instead, such as a single number, an array, or a specialized data structure, but most libraries assume that the top-level value is a plain object.) The most common way to organize data within that top-level object is to further divide data into sub-trees, where each top-level key represents some "domain" or "slice" of related data. For example, a basic Todo app\'s state might look like:'}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"{\n  visibilityFilter: 'SHOW_ALL',\n  todos: [\n    {\n      text: 'Consider using Redux',\n      completed: true,\n    },\n    {\n      text: 'Keep all state in a single tree',\n      completed: false\n    }\n  ]\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["In this example, ",(0,n.jsx)(t.code,{children:"todos"})," and ",(0,n.jsx)(t.code,{children:"visibilityFilter"}),' are both top-level keys in the state, and each represents a "slice" of data for some particular concept.']}),"\n",(0,n.jsx)(t.p,{children:"Most applications deal with multiple types of data, which can be broadly divided into three categories:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:"Domain data"}),': data that the application needs to show, use, or modify (such as "all of the Todos retrieved from the server")']}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:"App state"}),': data that is specific to the application\'s behavior (such as "Todo #5 is currently selected", or "there is a request in progress to fetch Todos")']}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.em,{children:"UI state"}),': data that represents how the UI is currently displayed (such as "The EditTodo modal dialog is currently open")']}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Because the store represents the core of your application, you should ",(0,n.jsx)(t.strong,{children:"define your state shape in terms of your domain data and app state, not your UI component tree"}),". As an example, a shape of ",(0,n.jsx)(t.code,{children:"state.leftPane.todoList.todos"}),' would be a bad idea, because the idea of "todos" is central to the whole application, not just a single part of the UI. The ',(0,n.jsx)(t.code,{children:"todos"})," slice should be at the top of the state tree instead."]}),"\n",(0,n.jsxs)(t.p,{children:["There will ",(0,n.jsx)(t.em,{children:"rarely"})," be a 1-to-1 correspondence between your UI tree and your state shape. The exception to that might be if you are explicitly tracking various aspects of UI data in your Redux store as well, but even then the shape of the UI data and the shape of the domain data would likely be different."]}),"\n",(0,n.jsx)(t.p,{children:"A typical app's state shape might look roughly like:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-js",children:"{\n    domainData1 : {},\n    domainData2 : {},\n    appState1 : {},\n    appState2 : {},\n    ui : {\n        uiState1 : {},\n        uiState2 : {},\n    }\n}\n"})})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}}}]);