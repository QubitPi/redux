"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[693],{568:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/postslist-optimized-23628dbcf4aea5665a14754ca14bb47f.png"},2435:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"tutorials/essentials/part-6-performance-normalization","title":"Redux Essentials, Part 6: Performance, Normalizing Data, and Reactive Logic","description":"The official Redux Essentials tutorial: learn how to improve app performance and structure data correctly","source":"@site/../docs/tutorials/essentials/part-6-performance-normalization.md","sourceDirName":"tutorials/essentials","slug":"/tutorials/essentials/part-6-performance-normalization","permalink":"/tutorials/essentials/part-6-performance-normalization","draft":false,"unlisted":false,"editUrl":"https://github.com/reduxjs/redux/edit/master/website/../docs/tutorials/essentials/part-6-performance-normalization.md","tags":[],"version":"current","lastUpdatedAt":1747212223000,"frontMatter":{"id":"part-6-performance-normalization","title":"Redux Essentials, Part 6: Performance, Normalizing Data, and Reactive Logic","sidebar_label":"Performance, Normalizing Data, and Reactive Logic","description":"The official Redux Essentials tutorial: learn how to improve app performance and structure data correctly"},"sidebar":"docs","previous":{"title":"Async Logic and Data Fetching","permalink":"/tutorials/essentials/part-5-async-logic"},"next":{"title":"RTK Query Basics","permalink":"/tutorials/essentials/part-7-rtk-query-basics"}}');var i=n(4848),o=n(8453);n(9692);const a={id:"part-6-performance-normalization",title:"Redux Essentials, Part 6: Performance, Normalizing Data, and Reactive Logic",sidebar_label:"Performance, Normalizing Data, and Reactive Logic",description:"The official Redux Essentials tutorial: learn how to improve app performance and structure data correctly"},r=void 0,c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Adding More User Features",id:"adding-more-user-features",level:2},{value:"Adding User Pages",id:"adding-user-pages",level:3},{value:"Sending Login Requests to the Server",id:"sending-login-requests-to-the-server",level:3},{value:"Adding Notifications",id:"adding-notifications",level:2},{value:"Notifications Slice",id:"notifications-slice",level:3},{value:"Thunk Arguments",id:"thunk-arguments",level:3},{value:"Adding the Notifications List",id:"adding-the-notifications-list",level:3},{value:"Showing New Notifications",id:"showing-new-notifications",level:3},{value:"Tracking Notification Status",id:"tracking-notification-status",level:4},{value:"Marking Notifications as Read",id:"marking-notifications-as-read",level:4},{value:"Showing Unread Notifications",id:"showing-unread-notifications",level:4},{value:"Improving Render Performance",id:"improving-render-performance",level:2},{value:"Investigating Render Behavior",id:"investigating-render-behavior",level:3},{value:"Memoizing Selector Functions",id:"memoizing-selector-functions",level:3},{value:"Balancing Selector Usage",id:"balancing-selector-usage",level:3},{value:"Investigating the Posts List",id:"investigating-the-posts-list",level:2},{value:"Options for Optimizing List Rendering",id:"options-for-optimizing-list-rendering",level:3},{value:"Normalizing Data",id:"normalizing-data",level:2},{value:"Normalized State Structure",id:"normalized-state-structure",level:3},{value:"Managing Normalized State with <code>createEntityAdapter</code>",id:"managing-normalized-state-with-createentityadapter",level:3},{value:"Normalizing the Posts Slice",id:"normalizing-the-posts-slice",level:3},{value:"Optimizing the Posts List",id:"optimizing-the-posts-list",level:3},{value:"Normalizing the Users Slice",id:"normalizing-the-users-slice",level:3},{value:"Normalizing the Notifications Slice",id:"normalizing-the-notifications-slice",level:3},{value:"Writing Reactive Logic",id:"writing-reactive-logic",level:2},{value:"Reactive Logic with <code>createListenerMiddleware</code>",id:"reactive-logic-with-createlistenermiddleware",level:3},{value:"Setting Up the Listener Middleware",id:"setting-up-the-listener-middleware",level:3},{value:"Showing Toasts for New Posts",id:"showing-toasts-for-new-posts",level:3},{value:"What You&#39;ve Learned",id:"what-youve-learned",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function d(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.admonition,{title:"What You'll Learn",type:"tip",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["How to create memoized selector functions with ",(0,i.jsx)(t.code,{children:"createSelector"})]}),"\n",(0,i.jsx)(t.li,{children:"Patterns for optimizing component rendering performance"}),"\n",(0,i.jsxs)(t.li,{children:["How to use ",(0,i.jsx)(t.code,{children:"createEntityAdapter"})," to store and update normalized data"]}),"\n",(0,i.jsxs)(t.li,{children:["How to use ",(0,i.jsx)(t.code,{children:"createListenerMiddleware"})," for reactive logic"]}),"\n"]})}),"\n",(0,i.jsx)(t.admonition,{title:"Prerequisites",type:"info",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Completion of ",(0,i.jsx)(t.a,{href:"/tutorials/essentials/part-5-async-logic",children:"Part 5"})," to understand data fetching flow"]}),"\n"]})}),"\n",(0,i.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(t.p,{children:["In ",(0,i.jsx)(t.a,{href:"/tutorials/essentials/part-5-async-logic",children:"Part 5: Async Logic and Data Fetching"}),", we saw how to write async thunks to fetch data from a server API, and patterns for handling async request loading state."]}),"\n",(0,i.jsx)(t.p,{children:"In this section, we'll look at optimized patterns for ensuring good performance in our application, and techniques for automatically handling common updates of data in the store. We'll also look at how to write reactive logic that responds to dispatched actions."}),"\n",(0,i.jsxs)(t.p,{children:["So far, most of our functionality has been centered around the ",(0,i.jsx)(t.code,{children:"posts"})," feature. We're going to add a couple new sections of the app. After those are added, we'll look at some specific details of how we've built things, and talk about some weaknesses with what we've built so far and how we can improve the implementation."]}),"\n",(0,i.jsx)(t.h2,{id:"adding-more-user-features",children:"Adding More User Features"}),"\n",(0,i.jsx)(t.h3,{id:"adding-user-pages",children:"Adding User Pages"}),"\n",(0,i.jsx)(t.p,{children:"We're fetching a list of users from our fake API, and we can choose a user as the author when we add a new post. But, a social media app needs the ability to look at the page for a specific user and see all the posts they've made. Let's add a page to show the list of all users, and another to show all posts by a specific user."}),"\n",(0,i.jsxs)(t.p,{children:["We'll start by adding a new ",(0,i.jsx)(t.code,{children:"<UsersList>"})," component. It follows the usual pattern of reading some data from the store with ",(0,i.jsx)(t.code,{children:"useSelector"}),", and mapping over the array to show a list of users with links to their individual pages:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/users/UsersList.tsx"',children:"import { Link } from 'react-router-dom'\n\nimport { useAppSelector } from '@/app/hooks'\n\nimport { selectAllUsers } from './usersSlice'\n\nexport const UsersList = () => {\n  const users = useAppSelector(selectAllUsers)\n\n  const renderedUsers = users.map(user => (\n    <li key={user.id}>\n      <Link to={`/users/${user.id}`}>{user.name}</Link>\n    </li>\n  ))\n\n  return (\n    <section>\n      <h2>Users</h2>\n\n      <ul>{renderedUsers}</ul>\n    </section>\n  )\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["And we'll add a ",(0,i.jsx)(t.code,{children:"<UserPage>"}),", which is similar to our ",(0,i.jsx)(t.code,{children:"<SinglePostPage>"})," in taking a ",(0,i.jsx)(t.code,{children:"userId"})," parameter from the router. It then renders a list of all of the posts for that particular user. Following our usual pattern, we'll first add a ",(0,i.jsx)(t.code,{children:"selectPostsByUser"})," selector in ",(0,i.jsx)(t.code,{children:"postsSlice.ts"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/posts/postsSlice.ts"',children:"// omit rest of the file\nexport const selectPostById = (state: RootState, postId: string) =>\n  state.posts.posts.find(post => post.id === postId)\n\n// highlight-start\nexport const selectPostsByUser = (state: RootState, userId: string) => {\n  const allPosts = selectAllPosts(state)\n  // \u274c This seems suspicious! See more details below\n  return allPosts.filter(post => post.user === userId)\n}\n// highlight-end\n\nexport const selectPostsStatus = (state: RootState) => state.posts.status\nexport const selectPostsError = (state: RootState) => state.posts.error\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/users/UserPage.tsx"',children:"import { Link, useParams } from 'react-router-dom'\n\nimport { useAppSelector } from '@/app/hooks'\nimport { selectPostsByUser } from '@/features/posts/postsSlice'\n\nimport { selectUserById } from './usersSlice'\n\nexport const UserPage = () => {\n  const { userId } = useParams()\n\n  const user = useAppSelector(state => selectUserById(state, userId!))\n\n  const postsForUser = useAppSelector(state =>\n    selectPostsByUser(state, userId!)\n  )\n\n  if (!user) {\n    return (\n      <section>\n        <h2>User not found!</h2>\n      </section>\n    )\n  }\n\n  const postTitles = postsForUser.map(post => (\n    <li key={post.id}>\n      <Link to={`/posts/${post.id}`}>{post.title}</Link>\n    </li>\n  ))\n\n  return (\n    <section>\n      <h2>{user.name}</h2>\n\n      <ul>{postTitles}</ul>\n    </section>\n  )\n}\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"caution",children:(0,i.jsxs)(t.p,{children:["Note that we're using ",(0,i.jsx)(t.code,{children:"allPosts.filter()"})," inside of ",(0,i.jsx)(t.code,{children:"selectPostsByUser"}),". ",(0,i.jsxs)(t.strong,{children:["This is actually a ",(0,i.jsx)(t.em,{children:"broken"})," pattern!"]})," We'll see why in just a minute."]})}),"\n",(0,i.jsxs)(t.p,{children:["We already have the ",(0,i.jsx)(t.code,{children:"selectAllUsers"})," and ",(0,i.jsx)(t.code,{children:"selectUserById"})," selectors available in our ",(0,i.jsx)(t.code,{children:"usersSlice"}),", so we can just import and use those in the components."]}),"\n",(0,i.jsxs)(t.p,{children:["As we've seen before, we can take data from one ",(0,i.jsx)(t.code,{children:"useSelector"})," call, or from props, and use that to help decide what to read from the store in another ",(0,i.jsx)(t.code,{children:"useSelector"})," call."]}),"\n",(0,i.jsxs)(t.p,{children:["As usual, we will add routes for these components in ",(0,i.jsx)(t.code,{children:"<App>"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="App.tsx"',children:'          <Route path="/posts/:postId" element={<SinglePostPage />} />\n          <Route path="/editPost/:postId" element={<EditPostForm />} />\n          // highlight-start\n          <Route path="/users" element={<UsersList />} />\n          <Route path="/users/:userId" element={<UserPage />} />\n          // highlight-end\n          <Redirect to="/" />\n'})}),"\n",(0,i.jsxs)(t.p,{children:["We'll also add another tab in ",(0,i.jsx)(t.code,{children:"<Navbar>"})," that links to ",(0,i.jsx)(t.code,{children:"/users"})," so that we can click and go to ",(0,i.jsx)(t.code,{children:"<UsersList>"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="app/Navbar.tsx"',children:'export const Navbar = () => {\n  // omit other logic\n\n  navContent = (\n    <div className="navContent">\n      <div className="navLinks">\n        <Link to="/posts">Posts</Link>\n        // highlight-next-line\n        <Link to="/users">Users</Link>\n      </div>\n      <div className="userDetails">\n        <UserIcon size={32} />\n        {user.name}\n        <button className="button small" onClick={onLogoutClicked}>\n          Log Out\n        </button>\n      </div>\n    </div>\n  )\n\n  // omit other rendering\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Now we can actually browse to each user's page and see a list of just their posts."}),"\n",(0,i.jsx)(t.h3,{id:"sending-login-requests-to-the-server",children:"Sending Login Requests to the Server"}),"\n",(0,i.jsxs)(t.p,{children:["Right now our ",(0,i.jsx)(t.code,{children:"<LoginPage>"})," and ",(0,i.jsx)(t.code,{children:"authSlice"})," are just dispatching client-side Redux actions to track the current username. In practice, we really need to send a login request to the server. Like we've done with posts and users, we'll convert the login and logout handling to async thunks instead."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/auth/authSlice.ts"',children:"// highlight-next-line\nimport { createSlice, createAsyncThunk } from '@reduxjs/toolkit'\n\n// highlight-next-line\nimport { client } from '@/api/client'\n\nimport type { RootState } from '@/app/store'\n\n// highlight-next-line\nimport { createAppAsyncThunk } from '@/app/withTypes'\n\ninterface AuthState {\n  username: string | null\n}\n\n// highlight-start\nexport const login = createAppAsyncThunk(\n  'auth/login',\n  async (username: string) => {\n    await client.post('/fakeApi/login', { username })\n    return username\n  }\n)\n\nexport const logout = createAppAsyncThunk('auth/logout', async () => {\n  await client.post('/fakeApi/logout', {})\n})\n// highlight-end\n\nconst initialState: AuthState = {\n  // Note: a real app would probably have more complex auth state,\n  // but for this example we'll keep things simple\n  username: null\n}\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  // highlight-start\n  // Remove the reducer definitions\n  reducers: {},\n  extraReducers: builder => {\n    // and handle the thunk actions instead\n    builder\n      .addCase(login.fulfilled, (state, action) => {\n        state.username = action.payload\n      })\n      .addCase(logout.fulfilled, state => {\n        state.username = null\n      })\n  }\n  // highlight-end\n})\n\n// highlight-next-line\n// Removed the exported actions\n\nexport default authSlice.reducer\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Along with that, we'll update ",(0,i.jsx)(t.code,{children:"<Navbar>"})," and ",(0,i.jsx)(t.code,{children:"<LoginPage>"})," to import and dispatch the new thunks instead of the previous action creators:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="components/Navbar.tsx"',children:"import { Link } from 'react-router-dom'\n\nimport { useAppDispatch, useAppSelector } from '@/app/hooks'\n\n// highlight-next-line\nimport { logout } from '@/features/auth/authSlice'\nimport { selectCurrentUser } from '@/features/users/usersSlice'\n\nimport { UserIcon } from './UserIcon'\n\nexport const Navbar = () => {\n  const dispatch = useAppDispatch()\n  const user = useAppSelector(selectCurrentUser)\n\n  const isLoggedIn = !!user\n\n  let navContent: React.ReactNode = null\n\n  if (isLoggedIn) {\n    const onLogoutClicked = () => {\n      // highlight-next-line\n      dispatch(logout())\n    }\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/auth/LoginPage.tsx"',children:"import React from 'react'\nimport { useNavigate } from 'react-router-dom'\n\nimport { useAppDispatch, useAppSelector } from '@/app/hooks'\nimport { selectAllUsers } from '@/features/users/usersSlice'\n\n// highlight-next-line\nimport { login } from './authSlice'\n\n// omit types\n\nexport const LoginPage = () => {\n  const dispatch = useAppDispatch()\n  const users = useAppSelector(selectAllUsers)\n  const navigate = useNavigate()\n\n  // highlight-next-line\n  const handleSubmit = async (e: React.FormEvent<LoginPageFormElements>) => {\n    e.preventDefault()\n\n    const username = e.currentTarget.elements.username.value\n    // highlight-next-line\n    await dispatch(login(username))\n    navigate('/posts')\n  }\n\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Since the ",(0,i.jsx)(t.code,{children:"userLoggedOut"})," action creator was being used by the ",(0,i.jsx)(t.code,{children:"postsSlice"}),", we can update that to listen to ",(0,i.jsx)(t.code,{children:"logout.fulfilled"})," instead:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/posts/postsSlice.ts"',children:"import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport { client } from '@/api/client'\n\nimport type { RootState } from '@/app/store'\n\n// highlight-start\n// Import this thunk instead\nimport { logout } from '@/features/auth/authSlice'\n// highlight-end\n\n// omit types and setup\n\nconst postsSlice = createSlice({\n  name,\n  initialState,\n  reducers: {\n    /* omitted */\n  },\n  extraReducers: builder => {\n    builder\n      // highlight-start\n      // switch to handle the thunk fulfilled action\n      .addCase(logout.fulfilled, state => {\n        // highlight-end\n        // Clear out the list of posts whenever the user logs out\n        return initialState\n      })\n    // omit other cases\n  }\n})\n"})}),"\n",(0,i.jsx)(t.h2,{id:"adding-notifications",children:"Adding Notifications"}),"\n",(0,i.jsx)(t.p,{children:"No social media app would be complete without some notifications popping up to tell us that someone has sent a message, left a comment, or reacted to one of our posts."}),"\n",(0,i.jsxs)(t.p,{children:["In a real application, our app client would be in constant communication with the backend server, and the server would push an update to the client every time something happens. Since this is a small example app, we're going to mimic that process by adding a button to actually fetch some notification entries from our fake API. We also don't have any other ",(0,i.jsx)(t.em,{children:"real"})," users sending messages or reacting to posts, so the fake API will just create some random notification entries every time we make a request. (Remember, the goal here is to see how to use Redux itself.)"]}),"\n",(0,i.jsx)(t.h3,{id:"notifications-slice",children:"Notifications Slice"}),"\n",(0,i.jsx)(t.p,{children:"Since this is a new part of our app, the first step is to create a new slice for our notifications, and an async thunk to fetch some notification entries from the API. In order to create some realistic notifications, we'll include the timestamp of the latest notification we have in state. That will let our mock server generate notifications newer than that timestamp."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/notifications/notificationsSlice.ts"',children:"import { createSlice } from '@reduxjs/toolkit'\n\nimport { client } from '@/api/client'\n\nimport type { RootState } from '@/app/store'\nimport { createAppAsyncThunk } from '@/app/withTypes'\n\nexport interface ServerNotification {\n  id: string\n  date: string\n  message: string\n  user: string\n}\n\nexport const fetchNotifications = createAppAsyncThunk(\n  'notifications/fetchNotifications',\n  async (_unused, thunkApi) => {\n    const allNotifications = selectAllNotifications(thunkApi.getState())\n    const [latestNotification] = allNotifications\n    const latestTimestamp = latestNotification ? latestNotification.date : ''\n    const response = await client.get<ServerNotification[]>(\n      `/fakeApi/notifications?since=${latestTimestamp}`\n    )\n    return response.data\n  }\n)\n\nconst initialState: ServerNotification[] = []\n\nconst notificationsSlice = createSlice({\n  name: 'notifications',\n  initialState,\n  reducers: {},\n  extraReducers(builder) {\n    builder.addCase(fetchNotifications.fulfilled, (state, action) => {\n      state.push(...action.payload)\n      // Sort with newest first\n      state.sort((a, b) => b.date.localeCompare(a.date))\n    })\n  }\n})\n\nexport default notificationsSlice.reducer\n\nexport const selectAllNotifications = (state: RootState) => state.notifications\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As with the other slices, we then import ",(0,i.jsx)(t.code,{children:"notificationsReducer"})," into ",(0,i.jsx)(t.code,{children:"store.ts"})," and add it to the ",(0,i.jsx)(t.code,{children:"configureStore()"})," call."]}),"\n",(0,i.jsxs)(t.p,{children:["We've written an async thunk called ",(0,i.jsx)(t.code,{children:"fetchNotifications"}),", which will retrieve a list of new notifications from the server. As part of that, we want to use the creation timestamp of the most recent notification as part of our request, so that the server knows it should only send back notifications that are actually new."]}),"\n",(0,i.jsxs)(t.p,{children:["We know that we will be getting back an array of notifications, so we can pass them as separate arguments to ",(0,i.jsx)(t.code,{children:"state.push()"}),", and the array will add each item. We also want to make sure that they're sorted so that the most recent notification is first in the array, just in case the server were to send them out of order. (As a reminder, ",(0,i.jsxs)(t.strong,{children:[(0,i.jsx)(t.code,{children:"array.sort()"})," always mutates the existing array - this is only safe because we're using ",(0,i.jsx)(t.code,{children:"createSlice"})," and Immer inside."]}),")"]}),"\n",(0,i.jsx)(t.h3,{id:"thunk-arguments",children:"Thunk Arguments"}),"\n",(0,i.jsxs)(t.p,{children:["If you look at our ",(0,i.jsx)(t.code,{children:"fetchNotifications"})," thunk, it has something new that we haven't seen before. Let's talk about thunk arguments for a minute."]}),"\n",(0,i.jsxs)(t.p,{children:["We've already seen that we can pass an argument into a thunk action creator when we dispatch it, like ",(0,i.jsx)(t.code,{children:"dispatch(addPost(newPost))"}),". For ",(0,i.jsx)(t.code,{children:"createAsyncThunk"})," specifically, you can only pass in one argument, and whatever we pass in becomes the first argument of the payload creation callback. If we don't actually pass anything in, then that argument becomes ",(0,i.jsx)(t.code,{children:"undefined"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The second argument to our payload creator is a ",(0,i.jsx)(t.code,{children:"thunkAPI"})," object containing several useful functions and pieces of information:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"dispatch"})," and ",(0,i.jsx)(t.code,{children:"getState"}),": the actual ",(0,i.jsx)(t.code,{children:"dispatch"})," and ",(0,i.jsx)(t.code,{children:"getState"})," methods from our Redux store. You can use these inside the thunk to dispatch more actions, or get the latest Redux store state (such as reading an updated value after another action is dispatched)."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"extra"}),": the \"extra argument\" that can be passed into the thunk middleware when creating the store. This is typically some kind of API wrapper, such as a set of functions that know how to make API calls to your application's server and return data, so that your thunks don't have to have all the URLs and query logic directly inside."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"requestId"}),": a unique random ID value for this thunk call. Useful for tracking status of an individual request."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"signal"}),": An ",(0,i.jsx)(t.code,{children:"AbortController.signal"})," function that can be used to cancel an in-progress request."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"rejectWithValue"}),": a utility that helps customize the contents of a ",(0,i.jsx)(t.code,{children:"rejected"})," action if the thunk receives an error."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["(If you're writing a thunk by hand instead of using ",(0,i.jsx)(t.code,{children:"createAsyncThunk"}),", the thunk function will get",(0,i.jsx)(t.code,{children:"(dispatch, getState)"})," as separate arguments, instead of putting them together in one object.)"]}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["For more details on these arguments and how to handle canceling thunks and requests, see ",(0,i.jsxs)(t.a,{href:"https://redux-toolkit.js.org/api/createAsyncThunk",children:["the ",(0,i.jsx)(t.code,{children:"createAsyncThunk"})," API reference page"]}),"."]})}),"\n",(0,i.jsxs)(t.p,{children:["In this case, we need access to the ",(0,i.jsx)(t.code,{children:"thunkApi"})," argument, which is always the second argument. That means we need to provide ",(0,i.jsx)(t.em,{children:"some"})," variable name for the first argument, even though we don't pass anything in when we dispatch the thunk, and we don't need to use it inside the payload callback. So, we'll just give it a name of ",(0,i.jsx)(t.code,{children:"_unused"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["From there, we know that the list of notifications is in our Redux store state, and that the latest notification should be first in the array. We can call ",(0,i.jsx)(t.code,{children:"thunkApi.getState()"})," to read the state value, and use the ",(0,i.jsx)(t.code,{children:"selectAllNotifications"})," selector to give us just the array of notifications. Since the array of notifications is sorted newest first, we can grab the latest one using array destructuring."]}),"\n",(0,i.jsx)(t.h3,{id:"adding-the-notifications-list",children:"Adding the Notifications List"}),"\n",(0,i.jsxs)(t.p,{children:["Now that we've got the ",(0,i.jsx)(t.code,{children:"notificationsSlice"})," created, we can add a ",(0,i.jsx)(t.code,{children:"<NotificationsList>"})," component. It needs to read the list of notifications from the store and format them, including showing how recent each notification was, and who sent it. We already have the ",(0,i.jsx)(t.code,{children:"<PostAuthor>"})," and ",(0,i.jsx)(t.code,{children:"<TimeAgo>"})," components that can do that formatting, so we can reuse them here. That said, ",(0,i.jsx)(t.code,{children:"<PostAuthor>"})," includes a \"by \" prefix which doesn't make sense here - we'll modify it to add a ",(0,i.jsx)(t.code,{children:"showPrefix"})," prop that defaults to ",(0,i.jsx)(t.code,{children:"true"}),", and specifically ",(0,i.jsx)(t.em,{children:"not"})," show prefixes here."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/posts/PostAuthor.tsx"',children:"interface PostAuthorProps {\n  userId: string\n  // highlight-next-line\n  showPrefix?: boolean\n}\n\n// highlight-next-line\nexport const PostAuthor = ({ userId, showPrefix = true }: PostAuthorProps) => {\n  const author = useAppSelector(state => selectUserById(state, userId))\n\n  return (\n    <span>\n      // highlight-next-line\n      {showPrefix ? 'by ' : null}\n      {author?.name ?? 'Unknown author'}\n    </span>\n  )\n}\n"})}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/notifications/NotificationsList.tsx"',children:"import { useAppSelector } from '@/app/hooks'\n\nimport { TimeAgo } from '@/components/TimeAgo'\n\nimport { PostAuthor } from '@/features/posts/PostAuthor'\n\nimport { selectAllNotifications } from './notificationsSlice'\n\nexport const NotificationsList = () => {\n  const notifications = useAppSelector(selectAllNotifications)\n\n  const renderedNotifications = notifications.map(notification => {\n    return (\n      <div key={notification.id} className=\"notification\">\n        <div>\n          <b>\n            <PostAuthor userId={notification.user} showPrefix={false} />\n          </b>{' '}\n          {notification.message}\n        </div>\n        <TimeAgo timestamp={notification.date} />\n      </div>\n    )\n  })\n\n  return (\n    <section className=\"notificationsList\">\n      <h2>Notifications</h2>\n      {renderedNotifications}\n    </section>\n  )\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We also need to update the ",(0,i.jsx)(t.code,{children:"<Navbar>"}),' to add a "Notifications" tab, and a new button to fetch some notifications:']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="app/Navbar.tsx"',children:'// omit several imports\n\nimport { logout } from \'@/features/auth/authSlice\'\n// highlight-next-line\nimport { fetchNotifications } from \'@/features/notifications/notificationsSlice\'\nimport { selectCurrentUser } from \'@/features/users/usersSlice\'\n\nexport const Navbar = () => {\n  const dispatch = useAppDispatch()\n  const user = useAppSelector(selectCurrentUser)\n\n  const isLoggedIn = !!user\n\n  let navContent: React.ReactNode = null\n\n  if (isLoggedIn) {\n    const onLogoutClicked = () => {\n      dispatch(logout())\n    }\n\n    // highlight-start\n    const fetchNewNotifications = () => {\n      dispatch(fetchNotifications())\n    }\n    // highlight-end\n\n    navContent = (\n      <div className="navContent">\n        <div className="navLinks">\n          <Link to="/posts">Posts</Link>\n          <Link to="/users">Users</Link>\n          // highlight-start\n          <Link to="/notifications">Notifications</Link>\n          <button className="button small" onClick={fetchNewNotifications}>\n            Refresh Notifications\n          </button>\n          // highlight-end\n        </div>\n        {/* omit user details */}\n      </div>\n    )\n  }\n\n  // omit other rendering\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Lastly, we need to update ",(0,i.jsx)(t.code,{children:"App.ts"}),' with the "Notifications" route so we can navigate to it:']}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="App.tsx"',children:'// omit imports\n// highlight-next-line\nimport { NotificationsList } from \'./features/notifications/NotificationsList\'\n\nfunction App() {\n  return (\n    // omit all the outer router setup\n    <Routes>\n      <Route path="/posts" element={<PostsMainPage />} />\n      <Route path="/posts/:postId" element={<SinglePostPage />} />\n      <Route path="/editPost/:postId" element={<EditPostForm />} />\n      <Route path="/users" element={<UsersList />} />\n      <Route path="/users/:userId" element={<UserPage />} />\n      // highlight-start\n      <Route path="/notifications" element={<NotificationsList />} />\n      // highlight-end\n    </Routes>\n  )\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:'Here\'s what the "Notifications" tab looks like so far:'}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"Initial Notifications tab",src:n(8090).A+"",width:"1080",height:"366"})}),"\n",(0,i.jsx)(t.h3,{id:"showing-new-notifications",children:"Showing New Notifications"}),"\n",(0,i.jsxs)(t.p,{children:['Each time we click "Refresh Notifications", a few more notification entries will be added to our list. In a real app, those could be coming from the server while we\'re looking at other parts of the UI. We can do something similar by clicking "Refresh Notifications" while we\'re looking at the ',(0,i.jsx)(t.code,{children:"<PostsList>"})," or ",(0,i.jsx)(t.code,{children:"<UserPage>"}),"."]}),"\n",(0,i.jsx)(t.p,{children:'But, right now we have no idea how many notifications just arrived, and if we keep clicking the button, there could be many notifications we haven\'t read yet. Let\'s add some logic to keep track of which notifications have been read and which of them are "new". That will let us show the count of "Unread" notifications as a badge on our "Notifications" tab in the navbar, and display new notifications in a different color.'}),"\n",(0,i.jsx)(t.h4,{id:"tracking-notification-status",children:"Tracking Notification Status"}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"Notification"})," objects that our fake API is sending back look like ",(0,i.jsx)(t.code,{children:"{id, date, message, user}"}),'. The idea of "new" or "unread" will only exist on the client. Given that, let\'s rework the ',(0,i.jsx)(t.code,{children:"notificationsSlice"})," to support that."]}),"\n",(0,i.jsxs)(t.p,{children:["First, we'll create a new ",(0,i.jsx)(t.code,{children:"ClientNotification"})," type that extends ",(0,i.jsx)(t.code,{children:"ServerNotification"})," to add those two fields. Then, when we receive a new batch of notifications from the server, we'll always add those fields with default values."]}),"\n",(0,i.jsx)(t.p,{children:'Next, we\'ll add a reducer that marks all notifications as read, and some logic to handle marking existing notifications as "not new".'}),"\n",(0,i.jsx)(t.p,{children:"Finally, we can also add a selector that counts how many unread notifications are in the store:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/notifications/notificationsSlice.ts"',children:"// omit imports\n\nexport interface ServerNotification {\n  id: string\n  date: string\n  message: string\n  user: string\n}\n\n// highlight-start\nexport interface ClientNotification extends ServerNotification {\n  read: boolean\n  isNew: boolean\n}\n// highlight-end\n\n// omit thunk\n\n// highlight-next-line\nconst initialState: ClientNotification[] = []\n\nconst notificationsSlice = createSlice({\n  name: 'notifications',\n  initialState,\n  reducers: {\n    // highlight-start\n    allNotificationsRead(state) {\n      state.forEach(notification => {\n        notification.read = true\n      })\n    }\n    // highlight-end\n  },\n  extraReducers(builder) {\n    builder.addCase(fetchNotifications.fulfilled, (state, action) => {\n      // highlight-start\n      // Add client-side metadata for tracking new notifications\n      const notificationsWithMetadata: ClientNotification[] =\n        action.payload.map(notification => ({\n          ...notification,\n          read: false,\n          isNew: true\n        }))\n\n      state.forEach(notification => {\n        // Any notifications we've read are no longer new\n        notification.isNew = !notification.read\n      })\n\n      state.push(...notificationsWithMetadata)\n      // highlight-end\n      // Sort with newest first\n      state.sort((a, b) => b.date.localeCompare(a.date))\n    })\n  }\n})\n\n// highlight-next-line\nexport const { allNotificationsRead } = notificationsSlice.actions\n\nexport default notificationsSlice.reducer\n\n// highlight-start\nexport const selectUnreadNotificationsCount = (state: RootState) => {\n  const allNotifications = selectAllNotifications(state)\n  const unreadNotifications = allNotifications.filter(\n    notification => !notification.read\n  )\n  return unreadNotifications.length\n}\n// highlight-end\n"})}),"\n",(0,i.jsx)(t.h4,{id:"marking-notifications-as-read",children:"Marking Notifications as Read"}),"\n",(0,i.jsxs)(t.p,{children:["We want to mark these notifications as read whenever our ",(0,i.jsx)(t.code,{children:"<NotificationsList>"})," component renders, either because we clicked on the tab to view the notifications, or because we already have it open and we just received some additional notifications. We can do this by dispatching ",(0,i.jsx)(t.code,{children:"allNotificationsRead"})," any time this component re-renders. In order to avoid flashing of old data as this updates, we'll dispatch the action in a ",(0,i.jsx)(t.code,{children:"useLayoutEffect"})," hook. We also want to add an additional classname to any notification list entries in the page, to highlight them:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/notifications/NotificationsList.tsx"',children:"// highlight-start\nimport { useLayoutEffect } from 'react'\nimport classnames from 'classnames'\n// highlight-end\nimport { useAppSelector, useAppDispatch } from '@/app/hooks'\n\nimport { TimeAgo } from '@/components/TimeAgo'\n\nimport { PostAuthor } from '@/features/posts/PostAuthor'\n\n// highlight-start\nimport {\n  allNotificationsRead,\n  selectAllNotifications\n} from './notificationsSlice'\n// highlight-end\n\nexport const NotificationsList = () => {\n  const dispatch = useAppDispatch()\n  const notifications = useAppSelector(selectAllNotifications)\n\n  // highlight-start\n  useLayoutEffect(() => {\n    dispatch(allNotificationsRead())\n  })\n  // highlight-end\n\n  const renderedNotifications = notifications.map(notification => {\n    // highlight-start\n    const notificationClassname = classnames('notification', {\n      new: notification.isNew\n    })\n    // highlight-end\n\n    return (\n      // highlight-next-line\n      <div key={notification.id} className={notificationClassname}>\n        <div>\n          <b>\n            <PostAuthor userId={notification.user} showPrefix={false} />\n          </b>{' '}\n          {notification.message}\n        </div>\n        <TimeAgo timestamp={notification.date} />\n      </div>\n    )\n  })\n\n  return (\n    <section className=\"notificationsList\">\n      <h2>Notifications</h2>\n      {renderedNotifications}\n    </section>\n  )\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This works, but actually has a slightly surprising bit of behavior. Any time there are new notifications (either because we've just switched to this tab, or we've fetched some new notifications from the API), you'll actually see ",(0,i.jsx)(t.em,{children:"two"})," ",(0,i.jsx)(t.code,{children:'"notifications/allNotificationsRead"'})," actions dispatched. Why is that?"]}),"\n",(0,i.jsxs)(t.p,{children:["Let's say we have fetched some notifications while looking at the ",(0,i.jsx)(t.code,{children:"<PostsList>"}),', and then click the "Notifications" tab. The ',(0,i.jsx)(t.code,{children:"<NotificationsList>"})," component will mount, and the ",(0,i.jsx)(t.code,{children:"useLayoutEffect"})," callback will run after that first render and dispatch ",(0,i.jsx)(t.code,{children:"allNotificationsRead"}),". Our ",(0,i.jsx)(t.code,{children:"notificationsSlice"})," will handle that by updating the notification entries in the store. This creates a new ",(0,i.jsx)(t.code,{children:"state.notifications"})," array containing the immutably-updated entries, which forces our component to render again because it sees a new array returned from the ",(0,i.jsx)(t.code,{children:"useSelector"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["When the component renders the second time, ",(0,i.jsx)(t.code,{children:"useLayoutEffect"})," hook runs again and dispatches ",(0,i.jsx)(t.code,{children:"allNotificationsRead"}),"again. The reducer runs again too, but ",(0,i.jsx)(t.strong,{children:"this time no data changes, so the slice state and root state remain the same, and the component doesn't re-render"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"There's a couple ways we could potentially avoid that second dispatch, like splitting the logic to dispatch once when the component mounts, and only dispatch again if the size of the notifications array changes. But, this isn't actually hurting anything, so we can leave it alone."}),"\n",(0,i.jsxs)(t.p,{children:["This does actually show that ",(0,i.jsxs)(t.strong,{children:["it's possible to dispatch an action and not have ",(0,i.jsx)(t.em,{children:"any"})," state changes happen at all"]}),". Remember, ",(0,i.jsxs)(t.strong,{children:["it's always up to your reducers to decide ",(0,i.jsx)(t.em,{children:"if"}),' any state actually needs to be updated, and "nothing needs to happen" is a valid decision for a reducer to make']}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Here's how the notifications tab looks now that we've got the \"new/read\" behavior working:"}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"New notifications",src:n(3360).A+"",width:"1080",height:"498"})}),"\n",(0,i.jsx)(t.h4,{id:"showing-unread-notifications",children:"Showing Unread Notifications"}),"\n",(0,i.jsx)(t.p,{children:'The last thing we need to do before we move on is to add the badge on our "Notifications" tab in the navbar. This will show us the count of "Unread" notifications when we are in other tabs:'}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="app/Navbar.tsx"',children:'// omit other imports\n\n// highlight-next-line\nimport {\n  fetchNotifications,\n  selectUnreadNotificationsCount\n} from \'@/features/notifications/notificationsSlice\'\n\nexport const Navbar = () => {\n  const dispatch = useAppDispatch()\n  const username = useAppSelector(selectCurrentUsername)\n  const user = useAppSelector(selectCurrentUser)\n\n  // highlight-start\n  const numUnreadNotifications = useAppSelector(selectUnreadNotificationsCount)\n\n  // highlight-end\n\n  const isLoggedIn = !!user\n\n  let navContent: React.ReactNode = null\n\n  if (isLoggedIn) {\n    const onLogoutClicked = () => {\n      dispatch(logout())\n    }\n\n    const fetchNewNotifications = () => {\n      dispatch(fetchNotifications())\n    }\n\n    // highlight-start\n    let unreadNotificationsBadge: React.ReactNode | undefined\n\n    if (numUnreadNotifications > 0) {\n      unreadNotificationsBadge = (\n        <span className="badge">{numUnreadNotifications}</span>\n      )\n    }\n    // highlight-end\n\n    navContent = (\n      <div className="navContent">\n        <div className="navLinks">\n          <Link to="/posts">Posts</Link>\n          <Link to="/users">Users</Link>\n          // highlight-start\n          <Link to="/notifications">\n            Notifications {unreadNotificationsBadge}\n          </Link>\n          // highlight-end\n          <button className="button small" onClick={fetchNewNotifications}>\n            Refresh Notifications\n          </button>\n        </div>\n        {/* omit button */}\n      </div>\n    )\n  }\n\n  // omit other rendering\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"improving-render-performance",children:"Improving Render Performance"}),"\n",(0,i.jsx)(t.p,{children:"Our application is looking useful, but we've actually got a couple flaws in when and how our components re-render. Let's look at those problems, and talk about some ways to improve the performance."}),"\n",(0,i.jsx)(t.h3,{id:"investigating-render-behavior",children:"Investigating Render Behavior"}),"\n",(0,i.jsxs)(t.p,{children:["We can use the React DevTools Profiler to view some graphs of what components re-render when state is updated. Try clicking over to the ",(0,i.jsx)(t.code,{children:"<UserPage>"}),' for a single user. Open up your browser\'s DevTools, and in the React "Profiler" tab, click the circle "Record" button in the upper-left. Then, click the "Refresh Notifications" button in our app, and stop the recording in the React DevTools Profiler. You should see a chart that looks like this:']}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"React DevTools Profiler render capture - &lt;UserPage&gt;",src:n(8315).A+"",width:"2548",height:"690"})}),"\n",(0,i.jsxs)(t.p,{children:["We can see that the ",(0,i.jsx)(t.code,{children:"<Navbar>"}),' re-rendered, which makes sense because it had to show the updated "unread notifications" badge in the tab. But, why did our ',(0,i.jsx)(t.code,{children:"<UserPage>"})," re-render?"]}),"\n",(0,i.jsxs)(t.p,{children:["If we inspect the last couple dispatched actions in the Redux DevTools, we can see that only the notifications state updated. Since the ",(0,i.jsx)(t.code,{children:"<UserPage>"})," doesn't read any notifications, it shouldn't have re-rendered. Something must be wrong with the component or one of the selectors it's using."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"<UserPage>"})," is reading the list of posts from the store via ",(0,i.jsx)(t.code,{children:"selectPostsByUser"}),". If we look at ",(0,i.jsx)(t.code,{children:"selectPostsByUser"})," carefully, there's a specific problem:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/posts/postsSlice.ts"',children:"export const selectPostsByUser = (state: RootState, userId: string) => {\n  const allPosts = selectAllPosts(state)\n  // \u274c WRONG - this _always_ creates a new array reference!\n  return allPosts.filter(post => post.user === userId)\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We know that ",(0,i.jsx)(t.code,{children:"useSelector"})," will re-run every time an action is dispatched, and that it forces the component to re-render if we return a new reference value."]}),"\n",(0,i.jsxs)(t.p,{children:["We're calling ",(0,i.jsx)(t.code,{children:"filter()"})," inside of a selector function, so that we only return the list of posts that belong to this user."]}),"\n",(0,i.jsxs)(t.p,{children:["Unfortunately, ",(0,i.jsxs)(t.strong,{children:["this means that ",(0,i.jsx)(t.code,{children:"useSelector"})," ",(0,i.jsx)(t.em,{children:"always"})," returns a new array reference for this selector, and so our component will re-render after ",(0,i.jsx)(t.em,{children:"every"})," action even if the posts data hasn't changed!"]}),"."]}),"\n",(0,i.jsx)(t.p,{children:"This is a common mistake in Redux applications. Because of that, React-Redux actually does checks in development mode for selectors that accidentally always return new references. If you open up your browser devtools and go to the console, you should see a warning that says:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Selector unknown returned a different result when called with the same parameters.\nThis can lead to unnecessary rerenders.\nSelectors that return a new reference (such as an object or an array) should be memoized:\n    at UserPage (http://localhost:5173/src/features/users/UserPage.tsx)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["In most cases, the error would tell us the actual variable name of the selector. In ",(0,i.jsx)(t.em,{children:"this"})," case, the error message doesn't have a specific name for the selector, because we're actually using an anonymous function inside of ",(0,i.jsx)(t.code,{children:"useAppSelector"}),". But, knowing it's in ",(0,i.jsx)(t.code,{children:"<UserPage>"})," narrows it down for us."]}),"\n",(0,i.jsxs)(t.p,{children:["Now, realistically this isn't a meaningful perf issue in this particular example app. The ",(0,i.jsx)(t.code,{children:"<UserPage>"})," component is small, and there's not many actions being dispatched in the app. However, ",(0,i.jsxs)(t.strong,{children:["this ",(0,i.jsx)(t.em,{children:"can"})," be a very major perf issue in real-world apps"]}),", with the impact varying based on app structure. Given that, extra components re-rendering when they didn't need to is a common perf issue and something we should try to fix."]}),"\n",(0,i.jsx)(t.h3,{id:"memoizing-selector-functions",children:"Memoizing Selector Functions"}),"\n",(0,i.jsxs)(t.p,{children:["What we really need is a way to only calculate the new filtered array if either ",(0,i.jsx)(t.code,{children:"state.posts"})," or ",(0,i.jsx)(t.code,{children:"userId"})," have changed. If they ",(0,i.jsx)(t.em,{children:"haven't"})," changed, we want to return the same filtered array reference as the last time."]}),"\n",(0,i.jsxs)(t.p,{children:["This idea is called ",(0,i.jsx)(t.strong,{children:'"memoization"'}),". We want to save a previous set of inputs and the calculated result, and if the inputs are the same, return the previous result instead of recalculating it again."]}),"\n",(0,i.jsx)(t.p,{children:"So far, we've been writing selectors by ourselves as plain functions, and mostly using them so that we don't have to copy and paste the code for reading data from the store. It would be great if there was a way to make our selector functions memoized so that we could improve performance."}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsxs)(t.strong,{children:[(0,i.jsx)(t.a,{href:"https://github.com/reduxjs/reselect",children:"Reselect"})," is a library for creating memoized selector functions"]}),", and was specifically designed to be used with Redux. It has a ",(0,i.jsx)(t.code,{children:"createSelector"})," function that generates memoized selectors that will only recalculate results when the inputs change. Redux Toolkit ",(0,i.jsxs)(t.a,{href:"https://redux-toolkit.js.org/api/createSelector",children:["exports the ",(0,i.jsx)(t.code,{children:"createSelector"})," function"]}),", so we already have it available."]}),"\n",(0,i.jsxs)(t.p,{children:["Let's rewrite ",(0,i.jsx)(t.code,{children:"selectPostsByUser"})," to be a memoized function with ",(0,i.jsx)(t.code,{children:"createSelector"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/posts/postsSlice.ts"',children:"// highlight-next-line\nimport { createSlice, createAsyncThunk, createSelector } from '@reduxjs/toolkit'\n\n// omit slice logic\n\nexport const selectAllPosts = (state: RootState) => state.posts.posts\n\nexport const selectPostById = (state: RootState, postId: string) =>\n  state.posts.posts.find(post => post.id === postId)\n\n// highlight-start\nexport const selectPostsByUser = createSelector(\n  // Pass in one or more \"input selectors\"\n  [\n    // we can pass in an existing selector function that\n    // reads something from the root `state` and returns it\n    selectAllPosts,\n    // and another function that extracts one of the arguments\n    // and passes that onward\n    (state: RootState, userId: string) => userId\n  ],\n  // the output function gets those values as its arguments,\n  // and will run when either input value changes\n  (posts, userId) => posts.filter(post => post.user === userId)\n)\n\n// highlight-end\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"createSelector"}),' first needs one or more "input selector" functions (either together inside of a single array, or as separate arguments). You also need to pass in an "output function", which calculates the result.']}),"\n",(0,i.jsxs)(t.p,{children:["When we call ",(0,i.jsx)(t.code,{children:"selectPostsByUser(state, userId)"}),", ",(0,i.jsx)(t.code,{children:"createSelector"})," will pass all of the arguments into each of our input selectors. Whatever those input selectors return becomes the arguments for the output selector. (We've already done something similar in ",(0,i.jsx)(t.code,{children:"selectCurrentUser"}),", where we first call ",(0,i.jsx)(t.code,{children:"const currentUsername = selectCurrentUsername(state)"}),".)"]}),"\n",(0,i.jsxs)(t.p,{children:["In this case, we know that we need the array of all posts and the user ID as the two arguments for our output selector. We can reuse our existing ",(0,i.jsx)(t.code,{children:"selectAllPosts"})," selector to extract the posts array. Since the user ID is the second argument we're passing into ",(0,i.jsx)(t.code,{children:"selectPostsByUser"}),", we can write a small selector that just returns ",(0,i.jsx)(t.code,{children:"userId"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Our output function then gets ",(0,i.jsx)(t.code,{children:"posts"})," and ",(0,i.jsx)(t.code,{children:"userId"})," as its arguments, and returns the filtered array of posts for just that user."]}),"\n",(0,i.jsxs)(t.p,{children:["If we try calling ",(0,i.jsx)(t.code,{children:"selectPostsByUser"})," multiple times, it will only re-run the output selector if either ",(0,i.jsx)(t.code,{children:"posts"})," or ",(0,i.jsx)(t.code,{children:"userId"})," has changed:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:"Selector Calculation Examples",children:"const state1 = getState()\n// Output selector runs, because it's the first call\nselectPostsByUser(state1, 'user1')\n// Output selector does _not_ run, because the arguments haven't changed\nselectPostsByUser(state1, 'user1')\n// Output selector runs, because `userId` changed\nselectPostsByUser(state1, 'user2')\n\ndispatch(reactionAdded())\nconst state2 = getState()\n// Output selector does not run, because `posts` and `userId` are the same\nselectPostsByUser(state2, 'user2')\n\n// Add some more posts\ndispatch(addNewPost())\nconst state3 = getState()\n// Output selector runs, because `posts` has changed\nselectPostsByUser(state3, 'user2')\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now that we've memoized ",(0,i.jsx)(t.code,{children:"selectPostsByUser"}),", we can try repeating the React profiler with ",(0,i.jsx)(t.code,{children:"<UserPage>"})," open while fetching notifications. This time we should see that ",(0,i.jsx)(t.code,{children:"<UserPage>"})," doesn't re-render:"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"React DevTools Profiler optimized render capture - &lt;UserPage&gt;",src:n(3273).A+"",width:"2560",height:"687"})}),"\n",(0,i.jsx)(t.h3,{id:"balancing-selector-usage",children:"Balancing Selector Usage"}),"\n",(0,i.jsx)(t.p,{children:"Memoized selectors are a valuable tool for improving performance in a React+Redux application, because they can help us avoid unnecessary re-renders, and also avoid doing potentially complex or expensive calculations if the input data hasn't changed."}),"\n",(0,i.jsxs)(t.p,{children:["Note that ",(0,i.jsx)(t.strong,{children:"not all selectors in an application need to be memoized!"})," The rest of the selectors we've written are still just plain functions, and those work fine. ",(0,i.jsx)(t.strong,{children:'Selectors only need to be memoized if they create and return new object or array references, or if the calculation logic is "expensive"'}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["As an example, let's look back at ",(0,i.jsx)(t.code,{children:"selectUnreadNotificationsCount"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"export const selectUnreadNotificationsCount = (state: RootState) => {\n  const allNotifications = selectAllNotifications(state)\n  const unreadNotifications = allNotifications.filter(\n    notification => !notification.read\n  )\n  return unreadNotifications.length\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This selector ",(0,i.jsx)(t.em,{children:"is"})," a plain function that's doing a ",(0,i.jsx)(t.code,{children:".filter()"})," call inside. However, notice that it's not ",(0,i.jsx)(t.em,{children:"returning"})," that new array reference. Instead, it's just returning a number. That's safer - even if we update the notifications array, the actual return value isn't going to be changing all the time."]}),"\n",(0,i.jsxs)(t.p,{children:["Now, re-filtering the notifications array every time this selector runs ",(0,i.jsx)(t.em,{children:"is"})," a bit wasteful. It would be reasonable to also convert this to a memoized selector, and that might save a few CPU cycles. But, it's not as ",(0,i.jsx)(t.em,{children:"necessary"})," as it would be if the selector was actually returning a new reference each time."]}),"\n",(0,i.jsxs)(t.admonition,{type:"info",children:[(0,i.jsx)(t.p,{children:"For more details on why we use selector functions and how to write memoized selectors with Reselect, see:"}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"/usage/deriving-data-selectors",children:"Using Redux: Deriving Data with Selectors"})}),"\n"]})]}),"\n",(0,i.jsx)(t.h2,{id:"investigating-the-posts-list",children:"Investigating the Posts List"}),"\n",(0,i.jsxs)(t.p,{children:["If we go back to our ",(0,i.jsx)(t.code,{children:"<PostsList>"})," and try clicking a reaction button on one of the posts while capturing a React profiler trace, we'll see that not only did the ",(0,i.jsx)(t.code,{children:"<PostsList>"})," and the updated ",(0,i.jsx)(t.code,{children:"<PostExcerpt>"})," instance render, ",(0,i.jsx)(t.em,{children:"all"})," of the ",(0,i.jsx)(t.code,{children:"<PostExcerpt>"})," components rendered:"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"React DevTools Profiler render capture - &lt;PostsList&gt;",src:n(7936).A+"",width:"2558",height:"830"})}),"\n",(0,i.jsx)(t.p,{children:"Why is that? None of the other posts changed, so why would they need to re-render?"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.a,{href:"https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/",children:(0,i.jsx)(t.strong,{children:"React's default behavior is that when a parent component renders, React will recursively render all child components inside of it!"})}),". The immutable update of one post object also created a new ",(0,i.jsx)(t.code,{children:"posts"})," array. Our ",(0,i.jsx)(t.code,{children:"<PostsList>"})," had to re-render because the ",(0,i.jsx)(t.code,{children:"posts"})," array was a new reference, so after it rendered, React continued downwards and re-rendered all of the ",(0,i.jsx)(t.code,{children:"<PostExcerpt>"})," components too."]}),"\n",(0,i.jsx)(t.p,{children:"This isn't a serious problem for our small example app, but in a larger real-world app, we might have some very long lists or very large component trees, and having all those extra components re-render might slow things down."}),"\n",(0,i.jsx)(t.h3,{id:"options-for-optimizing-list-rendering",children:"Options for Optimizing List Rendering"}),"\n",(0,i.jsxs)(t.p,{children:["There's a few different ways we could optimize this behavior in ",(0,i.jsx)(t.code,{children:"<PostsList>"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["First, we could wrap the ",(0,i.jsx)(t.code,{children:"<PostExcerpt>"})," component in ",(0,i.jsx)(t.a,{href:"https://react.dev/reference/react/memo",children:(0,i.jsx)(t.code,{children:"React.memo()"})}),", which will ensure that the component inside of it only re-renders if the props have actually changed. This will actually work quite well - try it out and see what happens:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/posts/PostsList.tsx"',children:"// highlight-next-line\nlet PostExcerpt = ({ post }: PostExcerptProps) => {\n  // omit logic\n}\n\n// highlight-next-line\nPostExcerpt = React.memo(PostExcerpt)\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Another option is to rewrite ",(0,i.jsx)(t.code,{children:"<PostsList>"})," so that it only selects a list of post IDs from the store instead of the entire ",(0,i.jsx)(t.code,{children:"posts"})," array, and rewrite ",(0,i.jsx)(t.code,{children:"<PostExcerpt>"})," so that it receives a ",(0,i.jsx)(t.code,{children:"postId"})," prop and calls ",(0,i.jsx)(t.code,{children:"useSelector"})," to read the post object it needs. If ",(0,i.jsx)(t.code,{children:"<PostsList>"})," gets the same list of IDs as before, it won't need to re-render, and so only our one changed ",(0,i.jsx)(t.code,{children:"<PostExcerpt>"})," component should have to render."]}),"\n",(0,i.jsxs)(t.p,{children:["Unfortunately, this gets tricky because we also need to have all our posts sorted by date and rendered in the right order. We could update our ",(0,i.jsx)(t.code,{children:"postsSlice"})," to keep the array sorted at all times, so we don't have to sort it in the component, and use a memoized selector to extract just the list of post IDs. We could also ",(0,i.jsxs)(t.a,{href:"https://react-redux.js.org/api/hooks#equality-comparisons-and-updates",children:["customize the comparison function that ",(0,i.jsx)(t.code,{children:"useSelector"})," runs to check the results"]}),", like ",(0,i.jsx)(t.code,{children:"useSelector(selectPostIds, shallowEqual)"}),", so that will skip re-rendering if the ",(0,i.jsx)(t.em,{children:"contents"})," of the IDs array haven't changed."]}),"\n",(0,i.jsxs)(t.p,{children:["The last option is to find some way to have our reducer keep a separate array of IDs for all the posts, and only modify that array when posts are added or removed, and do the same rewrite of ",(0,i.jsx)(t.code,{children:"<PostsList>"})," and ",(0,i.jsx)(t.code,{children:"<PostExcerpt>"}),". This way, ",(0,i.jsx)(t.code,{children:"<PostsList>"})," only needs to re-render when that IDs array changes."]}),"\n",(0,i.jsxs)(t.p,{children:["Conveniently, Redux Toolkit has a ",(0,i.jsx)(t.code,{children:"createEntityAdapter"})," function that will help us do just that."]}),"\n",(0,i.jsx)(t.h2,{id:"normalizing-data",children:"Normalizing Data"}),"\n",(0,i.jsxs)(t.p,{children:["You've seen that a lot of our logic has been looking up items by their ID field. Since we've been storing our data in arrays, that means we have to loop over all the items in the array using ",(0,i.jsx)(t.code,{children:"array.find()"})," until we find the item with the ID we're looking for."]}),"\n",(0,i.jsxs)(t.p,{children:["Realistically, this doesn't take very long, but if we had arrays with hundreds or thousands of items inside, looking through the entire array to find one item becomes wasted effort. What we need is a way to look up a single item based on its ID, directly, without having to check all the other items. This process is known as ",(0,i.jsx)(t.strong,{children:'"normalization"'}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"normalized-state-structure",children:"Normalized State Structure"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:'"Normalized state"'})," means that:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"We only have one copy of each particular piece of data in our state, so there's no duplication"}),"\n",(0,i.jsx)(t.li,{children:"Data that has been normalized is kept in a lookup table, where the item IDs are the keys, and the items themselves are the values. This is typically just a plain JS object."}),"\n",(0,i.jsx)(t.li,{children:"There may also be an array of all of the IDs for a particular item type"}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:['JavaScript objects can be used as lookup tables, similar to "maps" or "dictionaries" in other languages. Here\'s what the normalized state for a group of ',(0,i.jsx)(t.code,{children:"user"})," objects might look like:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'{\n  users: {\n    ids: ["user1", "user2", "user3"],\n    entities: {\n      "user1": {id: "user1", firstName, lastName},\n      "user2": {id: "user2", firstName, lastName},\n      "user3": {id: "user3", firstName, lastName},\n    }\n  }\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["This makes it easy to find a particular ",(0,i.jsx)(t.code,{children:"user"})," object by its ID, without having to loop through all the other user objects in an array:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"const userId = 'user2'\nconst userObject = state.users.entities[userId]\n"})}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsxs)(t.p,{children:["For more details on why normalizing state is useful, see ",(0,i.jsx)(t.a,{href:"/usage/structuring-reducers/normalizing-state-shape",children:"Normalizing State Shape"})," and the Redux Toolkit Usage Guide section on ",(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/usage/usage-guide#managing-normalized-data",children:"Managing Normalized Data"}),"."]})}),"\n",(0,i.jsxs)(t.h3,{id:"managing-normalized-state-with-createentityadapter",children:["Managing Normalized State with ",(0,i.jsx)(t.code,{children:"createEntityAdapter"})]}),"\n",(0,i.jsxs)(t.p,{children:["Redux Toolkit's ",(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/api/createEntityAdapter",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"createEntityAdapter"})})})," API provides a standardized way to store your data in a slice by taking a collection of items and putting them into the shape of ",(0,i.jsx)(t.code,{children:"{ ids: [], entities: {} }"}),". Along with this predefined state shape, it generates a set of reducer functions and selectors that know how to work with that data."]}),"\n",(0,i.jsx)(t.p,{children:"This has several benefits:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"We don't have to write the code to manage the normalization ourselves"}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"createEntityAdapter"}),'\'s pre-built reducer functions handle common cases like "add all these items", "update one item", or "remove multiple items"']}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"createEntityAdapter"})," can optionally keep the ID array in a sorted order based on the contents of the items, and will only update that array if items are added / removed or the sorting order changes."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"createEntityAdapter"})," accepts an options object that may include a ",(0,i.jsx)(t.code,{children:"sortComparer"})," function, which will be used to keep the item IDs array in sorted order by comparing two items (and works the same way as ",(0,i.jsx)(t.code,{children:"Array.sort()"}),")."]}),"\n",(0,i.jsxs)(t.p,{children:["It returns an object that contains ",(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/api/createEntityAdapter#crud-functions",children:"a set of generated reducer functions for adding, updating, and removing items from an entity state object"}),'. These reducer functions can either be used as a case reducer for a specific action type, or as a "mutating" utility function within another reducer in ',(0,i.jsx)(t.code,{children:"createSlice"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The adapter object also has a ",(0,i.jsx)(t.code,{children:"getSelectors"})," function. You can pass in a selector that returns this particular slice of state from the Redux root state, and it will generate selectors like ",(0,i.jsx)(t.code,{children:"selectAll"})," and ",(0,i.jsx)(t.code,{children:"selectById"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, the adapter object has a ",(0,i.jsx)(t.code,{children:"getInitialState"})," function that generates an empty ",(0,i.jsx)(t.code,{children:"{ids: [], entities: {}}"})," object. You can pass in more fields to ",(0,i.jsx)(t.code,{children:"getInitialState"}),", and those will be merged in."]}),"\n",(0,i.jsx)(t.h3,{id:"normalizing-the-posts-slice",children:"Normalizing the Posts Slice"}),"\n",(0,i.jsxs)(t.p,{children:["With that in mind, let's update our ",(0,i.jsx)(t.code,{children:"postsSlice"})," to use ",(0,i.jsx)(t.code,{children:"createEntityAdapter"}),". We'll need to make several changes."]}),"\n",(0,i.jsxs)(t.p,{children:["Our ",(0,i.jsx)(t.code,{children:"PostsState"})," structure is going to change. Instead of having ",(0,i.jsx)(t.code,{children:"posts: Post[]"})," as an array, it's now going to include ",(0,i.jsx)(t.code,{children:"{ids: string[], entities: Record<string, Post>}"}),". Redux Toolkit already has an ",(0,i.jsx)(t.code,{children:"EntityState"})," type that describes that ",(0,i.jsx)(t.code,{children:"{ids, entities}"})," structure, so we'll import that and use it as the base for ",(0,i.jsx)(t.code,{children:"PostsState"}),". We also still need the ",(0,i.jsx)(t.code,{children:"status"})," and ",(0,i.jsx)(t.code,{children:"error"})," fields too, so we'll include those."]}),"\n",(0,i.jsxs)(t.p,{children:["We're going to need to import ",(0,i.jsx)(t.code,{children:"createEntityAdapter"}),", create an instance that has the right ",(0,i.jsx)(t.code,{children:"Post"})," type applied, and knows how to sort posts in the right order."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/posts/postsSlice.ts"',children:"import {\n  // highlight-start\n  createEntityAdapter,\n  EntityState\n  // highlight-end\n  // omit other imports\n} from '@reduxjs/toolkit'\n\n// omit thunks\n\n// highlight-start\ninterface PostsState extends EntityState<Post, string> {\n  status: 'idle' | 'pending' | 'succeeded' | 'rejected'\n  error: string | null\n}\n\nconst postsAdapter = createEntityAdapter<Post>({\n  // Sort in descending date order\n  sortComparer: (a, b) => b.date.localeCompare(a.date)\n})\n\nconst initialState: PostsState = postsAdapter.getInitialState({\n  status: 'idle',\n  error: null\n})\n\n// highlight-end\n\n// omit thunks\n\nconst postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    postUpdated(state, action: PayloadAction<PostUpdate>) {\n      const { id, title, content } = action.payload\n\n      // highlight-next-line\n      const existingPost = state.entities[id]\n\n      if (existingPost) {\n        existingPost.title = title\n        existingPost.content = content\n      }\n    },\n    reactionAdded(\n      state,\n      action: PayloadAction<{ postId: string; reaction: ReactionName }>\n    ) {\n      const { postId, reaction } = action.payload\n      // highlight-next-line\n      const existingPost = state.entities[postId]\n      if (existingPost) {\n        existingPost.reactions[reaction]++\n      }\n    }\n  },\n  extraReducers(builder) {\n    builder\n      // omit other cases\n      .addCase(fetchPosts.fulfilled, (state, action) => {\n        state.status = 'succeeded'\n        // highlight-start\n        // Save the fetched posts into state\n        postsAdapter.setAll(state, action.payload)\n      })\n      .addCase(addNewPost.fulfilled, postsAdapter.addOne)\n    // highlight-end\n  }\n})\n\nexport const { postAdded, postUpdated, reactionAdded } = postsSlice.actions\n\nexport default postsSlice.reducer\n\n// highlight-start\n// Export the customized selectors for this adapter using `getSelectors`\nexport const {\n  selectAll: selectAllPosts,\n  selectById: selectPostById,\n  selectIds: selectPostIds\n  // Pass in a selector that returns the posts slice of state\n} = postsAdapter.getSelectors((state: RootState) => state.posts)\n// highlight-end\n\nexport const selectPostsByUser = createSelector(\n  [selectAllPosts, (state: RootState, userId: string) => userId],\n  (posts, userId) => posts.filter(post => post.user === userId)\n)\n"})}),"\n",(0,i.jsx)(t.p,{children:"There's a lot going on there! Let's break it down."}),"\n",(0,i.jsxs)(t.p,{children:["First, we import ",(0,i.jsx)(t.code,{children:"createEntityAdapter"}),", and call it to create our ",(0,i.jsx)(t.code,{children:"postsAdapter"})," object. We know that we want to keep an array of all post IDs sorted with the newest post first, so we pass in a ",(0,i.jsx)(t.code,{children:"sortComparer"})," function that will sort newer items to the front based on the ",(0,i.jsx)(t.code,{children:"post.date"})," field."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"getInitialState()"})," returns an empty ",(0,i.jsx)(t.code,{children:"{ids: [], entities: {}}"})," normalized state object. Our ",(0,i.jsx)(t.code,{children:"postsSlice"})," needs to keep the ",(0,i.jsx)(t.code,{children:"status"})," and ",(0,i.jsx)(t.code,{children:"error"})," fields for loading state too, so we pass those in to ",(0,i.jsx)(t.code,{children:"getInitialState()"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Now that our posts are being kept as a lookup table in ",(0,i.jsx)(t.code,{children:"state.entities"}),", we can change our ",(0,i.jsx)(t.code,{children:"reactionAdded"})," and ",(0,i.jsx)(t.code,{children:"postUpdated"})," reducers to directly look up the right posts by their IDs via ",(0,i.jsx)(t.code,{children:"state.entities[postId]"}),", instead of having to loop over the old ",(0,i.jsx)(t.code,{children:"posts"})," array."]}),"\n",(0,i.jsxs)(t.p,{children:["When we receive the ",(0,i.jsx)(t.code,{children:"fetchPosts.fulfilled"})," action, we can use the ",(0,i.jsx)(t.code,{children:"postsAdapter.setAll"})," function to add all of the incoming posts to the state, by passing in the draft ",(0,i.jsx)(t.code,{children:"state"})," and the array of posts in ",(0,i.jsx)(t.code,{children:"action.payload"}),'. This is an example of using the adapter methods as "mutating" helper functions inside of a ',(0,i.jsx)(t.code,{children:"createSlice"})," reducer."]}),"\n",(0,i.jsxs)(t.p,{children:["When we receive the ",(0,i.jsx)(t.code,{children:"addNewPost.fulfilled"})," action, we know we need to add that one new post object to our state. We can use the adapter functions as reducers directly, so we'll pass ",(0,i.jsx)(t.code,{children:"postsAdapter.addOne"})," as the reducer function to handle that action. In this case, we use the adapter method ",(0,i.jsx)(t.em,{children:"as"})," the actual reducer for this action."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, we can replace the old hand-written ",(0,i.jsx)(t.code,{children:"selectAllPosts"})," and ",(0,i.jsx)(t.code,{children:"selectPostById"})," selector functions with the ones generated by ",(0,i.jsx)(t.code,{children:"postsAdapter.getSelectors"}),". Since the selectors are called with the root Redux state object, they need to know where to find our posts data in the Redux state, so we pass in a small selector that returns ",(0,i.jsx)(t.code,{children:"state.posts"}),". The generated selector functions are always called ",(0,i.jsx)(t.code,{children:"selectAll"})," and ",(0,i.jsx)(t.code,{children:"selectById"}),", so we can use destructuring syntax to rename them as we export them and match the old selector names. We'll also export ",(0,i.jsx)(t.code,{children:"selectPostIds"})," the same way, since we want to read the list of sorted post IDs in our ",(0,i.jsx)(t.code,{children:"<PostsList>"})," component."]}),"\n",(0,i.jsxs)(t.p,{children:["We could even cut out a couple more lines by changing ",(0,i.jsx)(t.code,{children:"postUpdated"})," to use the ",(0,i.jsx)(t.code,{children:"postsAdapter.updateOne"})," method. This takes an object that looks like",(0,i.jsx)(t.code,{children:"{id, changes}"}),", where ",(0,i.jsx)(t.code,{children:"changes"})," is an object with fields to overwrite:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/posts/postsSlice.ts"',children:"const postsSlice = createSlice({\n  name: 'posts',\n  initialState,\n  reducers: {\n    postUpdated(state, action: PayloadAction<PostUpdate>) {\n      const { id, title, content } = action.payload\n      // highlight-next-line\n      postsAdapter.updateOne(state, { id, changes: { title, content } })\n    },\n    reactionAdded(\n      state,\n      action: PayloadAction<{ postId: string; reaction: ReactionName }>\n    ) {\n      const { postId, reaction } = action.payload\n      const existingPost = state.entities[postId]\n      if (existingPost) {\n        existingPost.reactions[reaction]++\n      }\n    }\n  }\n  // omit `extraReducers`\n})\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Note that we can't quite use ",(0,i.jsx)(t.code,{children:"postsAdapter.updateOne"})," with the ",(0,i.jsx)(t.code,{children:"reactionAdded"})," reducer, because it's a bit more complicated. Rather than just ",(0,i.jsx)(t.em,{children:"replacing"}),' a field in the post object, we need to increment a counter nested inside one of the fields. In that case, it\'s fine to look up the object and do a "mutating" update as we have been.']}),"\n",(0,i.jsx)(t.h3,{id:"optimizing-the-posts-list",children:"Optimizing the Posts List"}),"\n",(0,i.jsxs)(t.p,{children:["Now that our posts slice is using ",(0,i.jsx)(t.code,{children:"createEntityAdapter"}),", we can update ",(0,i.jsx)(t.code,{children:"<PostsList>"})," to optimize its rendering behavior."]}),"\n",(0,i.jsxs)(t.p,{children:["We'll update ",(0,i.jsx)(t.code,{children:"<PostsList>"})," to read just the sorted array of post IDs, and pass ",(0,i.jsx)(t.code,{children:"postId"})," to each ",(0,i.jsx)(t.code,{children:"<PostExcerpt>"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/posts/PostsList.tsx"',children:"// omit other imports\n\n// highlight-start\nimport {\n  fetchPosts,\n  selectPostById,\n  selectPostIds,\n  selectPostsStatus,\n  selectPostsError\n} from './postsSlice'\n\ninterface PostExcerptProps {\n  postId: string\n}\n\nfunction PostExcerpt({ postId }: PostExcerptProps) {\n  const post = useAppSelector(state => selectPostById(state, postId))\n  // highlight-end\n  // omit rendering logic\n}\n\nexport const PostsList = () => {\n  const dispatch = useDispatch()\n  // highlight-next-line\n  const orderedPostIds = useSelector(selectPostIds)\n\n  // omit other selections and effects\n\n  if (postStatus === 'pending') {\n    content = <Spinner text=\"Loading...\" />\n  } else if (postStatus === 'succeeded') {\n    // highlight-start\n    content = orderedPostIds.map(postId => (\n      <PostExcerpt key={postId} postId={postId} />\n    ))\n    // highlight-end\n  } else if (postStatus === 'rejected') {\n    content = <div>{postsError}</div>\n  }\n\n  // omit other rendering\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now, if we try clicking a reaction button on one of the posts while capturing a React component performance profile, we should see that ",(0,i.jsx)(t.em,{children:"only"})," that one component re-rendered:"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"React DevTools Profiler render capture - optimized &lt;PostsList&gt;",src:n(568).A+"",width:"2560",height:"759"})}),"\n",(0,i.jsx)(t.h3,{id:"normalizing-the-users-slice",children:"Normalizing the Users Slice"}),"\n",(0,i.jsxs)(t.p,{children:["We can convert other slices to use ",(0,i.jsx)(t.code,{children:"createEntityAdapter"})," as well."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"usersSlice"})," is fairly small, so we've only got a few things to change:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/users/usersSlice.ts"',children:"import {\n  createSlice,\n  // highlight-next-line\n  createEntityAdapter\n} from '@reduxjs/toolkit'\n\nimport { client } from '@/api/client'\nimport { createAppAsyncThunk } from '@/app/withTypes'\n\n// highlight-start\nconst usersAdapter = createEntityAdapter<User>()\n\nconst initialState = usersAdapter.getInitialState()\n// highlight-end\n\nexport const fetchUsers = createAppAsyncThunk('users/fetchUsers', async () => {\n  const response = await client.get('/fakeApi/users')\n  return response.users\n})\n\nconst usersSlice = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {},\n  extraReducers(builder) {\n    // highlight-next-line\n    builder.addCase(fetchUsers.fulfilled, usersAdapter.setAll)\n  }\n})\n\nexport default usersSlice.reducer\n\n// highlight-start\nexport const { selectAll: selectAllUsers, selectById: selectUserById } =\n  usersAdapter.getSelectors((state: RootState) => state.users)\n// highlight-end\n\nexport const selectCurrentUser = (state: RootState) => {\n  const currentUsername = selectCurrentUsername(state)\n  // highlight-start\n  if (!currentUsername) {\n    return\n  }\n  // highlight-end\n  return selectUserById(state, currentUsername)\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The only action we're handling here always replaces the entire list of users with the array we fetched from the server. We can use ",(0,i.jsx)(t.code,{children:"usersAdapter.setAll"})," to implement that instead."]}),"\n",(0,i.jsxs)(t.p,{children:["We were already exporting the ",(0,i.jsx)(t.code,{children:"selectAllUsers"})," and ",(0,i.jsx)(t.code,{children:"selectUserById"})," selectors we'd written by hand. We can replace those with the versions generated by ",(0,i.jsx)(t.code,{children:"usersAdapter.getSelectors()"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["We do now have a slight types mismatch with ",(0,i.jsx)(t.code,{children:"selectUserById"})," - our ",(0,i.jsx)(t.code,{children:"currentUsername"})," ",(0,i.jsx)(t.em,{children:"can"})," be ",(0,i.jsx)(t.code,{children:"null"})," according to the types, but the generated ",(0,i.jsx)(t.code,{children:"selectUserById"})," won't accept that. A simple fix is to check if exists and just return early if it doesn't."]}),"\n",(0,i.jsx)(t.h3,{id:"normalizing-the-notifications-slice",children:"Normalizing the Notifications Slice"}),"\n",(0,i.jsxs)(t.p,{children:["Last but not least, we'll update ",(0,i.jsx)(t.code,{children:"notificationsSlice"})," as well:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/notifications/notificationsSlice.ts"',children:"// highlight-next-line\nimport { createEntityAdapter, createSlice } from '@reduxjs/toolkit'\n\nimport { client } from '@/api/client'\n\n// omit types and fetchNotifications thunk\n\n// highlight-start\nconst notificationsAdapter = createEntityAdapter<ClientNotification>({\n  // Sort with newest first\n  sortComparer: (a, b) => b.date.localeCompare(a.date)\n})\n\nconst initialState = notificationsAdapter.getInitialState()\n// highlight-end\n\nconst notificationsSlice = createSlice({\n  name: 'notifications',\n  // highlight-next-line\n  initialState,\n  reducers: {\n    allNotificationsRead(state) {\n      // highlight-start\n      Object.values(state.entities).forEach(notification => {\n        notification.read = true\n      })\n      // highlight-end\n    }\n  },\n  extraReducers(builder) {\n    builder.addCase(fetchNotifications.fulfilled, (state, action) => {\n      // Add client-side metadata for tracking new notifications\n      const notificationsWithMetadata: ClientNotification[] =\n        action.payload.map(notification => ({\n          ...notification,\n          read: false,\n          isNew: true\n        }))\n\n      // highlight-start\n      Object.values(state.entities).forEach(notification => {\n        // Any notifications we've read are no longer new\n        notification.isNew = !notification.read\n      })\n\n      notificationsAdapter.upsertMany(state, notificationsWithMetadata)\n      // highlight-end\n    })\n  }\n})\n\nexport const { allNotificationsRead } = notificationsSlice.actions\n\nexport default notificationsSlice.reducer\n\n// highlight-start\nexport const { selectAll: selectAllNotifications } =\n  notificationsAdapter.getSelectors((state: RootState) => state.notifications)\n// highlight-end\n\nexport const selectUnreadNotificationsCount = (state: RootState) => {\n  const allNotifications = selectAllNotifications(state)\n  const unreadNotifications = allNotifications.filter(\n    notification => !notification.read\n  )\n  return unreadNotifications.length\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We again import ",(0,i.jsx)(t.code,{children:"createEntityAdapter"}),", call it, and call ",(0,i.jsx)(t.code,{children:"notificationsAdapter.getInitialState()"})," to help set up the slice."]}),"\n",(0,i.jsxs)(t.p,{children:["Ironically, we do have a couple places in here where we need to loop over all notification objects and update them. Since those are no longer being kept in an array, we have to use ",(0,i.jsx)(t.code,{children:"Object.values(state.entities)"})," to get an array of those notifications and loop over that. On the other hand, we can replace the previous fetch update logic with ",(0,i.jsx)(t.code,{children:"notificationsAdapter.upsertMany"}),"."]}),"\n",(0,i.jsx)(t.h2,{id:"writing-reactive-logic",children:"Writing Reactive Logic"}),"\n",(0,i.jsxs)(t.p,{children:["Thus far, all of our application behavior has been relatively imperative. The user does something (adding a post, fetching notifications), and we dispatch actions in either a click handler or a component ",(0,i.jsx)(t.code,{children:"useEffect"})," hook in response. That includes the data fetching thunks like ",(0,i.jsx)(t.code,{children:"fetchPosts"})," and ",(0,i.jsx)(t.code,{children:"login"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"However, sometimes we need to write more logic that runs in response to things that happened in the app, such as certain actions being dispatched."}),"\n",(0,i.jsx)(t.p,{children:"We've shown some loading indicators for things like fetching posts. It would be nice to have some kind of a visual confirmation for the user when they add a new post, like popping up a toast message."}),"\n",(0,i.jsxs)(t.p,{children:["We've already seen that we can have ",(0,i.jsx)(t.a,{href:"/tutorials/essentials/part-4-using-data#handling-actions-in-multiple-slices",children:"many reducers respond to the same dispatched action"}),'. That works great for logic that is just "update more parts of the state", but what if we need to write logic that is async or has other side effects? We can\'t put that in the reducers - ',(0,i.jsxs)(t.a,{href:"/tutorials/essentials/part-2-app-structure#rules-of-reducers",children:['reducers must be "pure" and must ',(0,i.jsx)(t.em,{children:"not"})," have any side effects"]}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["If we can't put this logic with side effects in reducers, where ",(0,i.jsx)(t.em,{children:"can"})," we put it?"]}),"\n",(0,i.jsxs)(t.p,{children:["The answer is inside of ",(0,i.jsx)(t.a,{href:"/tutorials/essentials/part-5-async-logic#using-middleware-to-enable-async-logic",children:"Redux middleware, because middleware is designed to enable side effects"}),"."]}),"\n",(0,i.jsxs)(t.h3,{id:"reactive-logic-with-createlistenermiddleware",children:["Reactive Logic with ",(0,i.jsx)(t.code,{children:"createListenerMiddleware"})]}),"\n",(0,i.jsx)(t.p,{children:'We\'ve already used the thunk middleware for async logic that has to run "right now". However, thunks are just functions. We need a different kind of middleware that lets us say "when a specific action is dispatched, go run this additional logic in response".'}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsxs)(t.strong,{children:["Redux Toolkit includes the ",(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/api/createListenerMiddleware",children:(0,i.jsx)(t.code,{children:"createListenerMiddleware"})})," API to let us write logic that runs in response to specific actions being dispatched"]}),'. It lets us add "listener" entries that define what actions to look for and have an ',(0,i.jsx)(t.code,{children:"effect"})," callback that will run whenever it matches against an action."]}),"\n",(0,i.jsxs)(t.p,{children:["Conceptually, you can think of ",(0,i.jsx)(t.code,{children:"createListenerMiddleware"})," as being similar to ",(0,i.jsxs)(t.a,{href:"https://react.dev/learn/synchronizing-with-effects",children:["React's ",(0,i.jsx)(t.code,{children:"useEffect"})," hook"]}),", except that they are defined as part of your Redux logic instead of inside a React component, and they run in response to dispatched actions and Redux state updates instead of as part of React's rendering lifecycle."]}),"\n",(0,i.jsx)(t.h3,{id:"setting-up-the-listener-middleware",children:"Setting Up the Listener Middleware"}),"\n",(0,i.jsxs)(t.p,{children:["We didn't have to specifically set up or define the thunk middleware, because Redux Toolkit's ",(0,i.jsx)(t.code,{children:"configureStore"})," automatically adds the thunk middleware to the store setup. For the listener middleware, we'll have to do a bit of setup work to create it and add it to the store."]}),"\n",(0,i.jsxs)(t.p,{children:["We'll create a new ",(0,i.jsx)(t.code,{children:"app/listenerMiddleware.ts"})," file and create an instance of the listener middleware there. Similar to ",(0,i.jsx)(t.code,{children:"createAsyncThunk"}),", we'll pass through the correct ",(0,i.jsx)(t.code,{children:"dispatch"})," and ",(0,i.jsx)(t.code,{children:"state"})," types so that we can safely access state fields and dispatch actions."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="app/listenerMiddleware.ts"',children:"import { createListenerMiddleware, addListener } from '@reduxjs/toolkit'\nimport type { RootState, AppDispatch } from './store'\n\nexport const listenerMiddleware = createListenerMiddleware()\n\nexport const startAppListening = listenerMiddleware.startListening.withTypes<\n  RootState,\n  AppDispatch\n>()\nexport type AppStartListening = typeof startAppListening\n\nexport const addAppListener = addListener.withTypes<RootState, AppDispatch>()\nexport type AppAddListener = typeof addAppListener\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Like ",(0,i.jsx)(t.code,{children:"createSlice"}),", ",(0,i.jsx)(t.code,{children:"createListenerMiddleware"})," returns an object that contains multiple fields:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"listenerMiddleware.middleware"}),": the actual Redux middleware instance that needs to be added to the store"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"listenerMiddleware.startListening"}),": adds a new listener entry to the middleware directly"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"listenerMiddleware.addListener"}),": an action creator that can be dispatched to add a listener entry from anywhere in the codebase that has access to ",(0,i.jsx)(t.code,{children:"dispatch"}),", even if you didn't import the ",(0,i.jsx)(t.code,{children:"listenerMiddleware"})," object"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["As with async thunks and hooks, we can use the ",(0,i.jsx)(t.code,{children:".withTypes()"})," methods to define pre-typed ",(0,i.jsx)(t.code,{children:"startAppListening"})," and ",(0,i.jsx)(t.code,{children:"addAppListener"})," functions with the right types built in."]}),"\n",(0,i.jsx)(t.p,{children:"Then, we need to add it to the store:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="app/store.ts"',children:"import { configureStore } from '@reduxjs/toolkit'\n\nimport authReducer from '@/features/auth/authSlice'\nimport postsReducer from '@/features/posts/postsSlice'\nimport usersReducer from '@/features/users/usersSlice'\nimport notificationsReducer from '@/features/notifications/notificationsSlice'\n\n// highlight-next-line\nimport { listenerMiddleware } from './listenerMiddleware'\n\nexport const store = configureStore({\n  reducer: {\n    auth: authReducer,\n    posts: postsReducer,\n    users: usersReducer,\n    notifications: notificationsReducer\n  },\n  // highlight-start\n  middleware: getDefaultMiddleware =>\n    getDefaultMiddleware().prepend(listenerMiddleware.middleware)\n  // highlight-end\n})\n"})}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"configureStore"})," already adds the ",(0,i.jsx)(t.code,{children:"redux-thunk"})," middleware to the store setup by default, along with some additional middleware in development that add safety checks. We want to preserve those, but also add the listener middleware as well."]}),"\n",(0,i.jsxs)(t.p,{children:["Order can matter when setting up middleware, because they form a pipeline: ",(0,i.jsx)(t.code,{children:"m1"})," -> ",(0,i.jsx)(t.code,{children:"m2"})," -> ",(0,i.jsx)(t.code,{children:"m3"})," -> ",(0,i.jsx)(t.code,{children:"store.dispatch()"}),". In this case, the listener middleware needs to be at the ",(0,i.jsx)(t.em,{children:"start"})," of the pipeline, so that it can intercept some actions first and process them."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"getDefaultMiddleware()"})," returns an array of the configured middleware. Since it's an array, it already has a ",(0,i.jsx)(t.code,{children:".concat()"})," method that returns a copy with the new items at the ",(0,i.jsx)(t.em,{children:"end"})," of the array, but ",(0,i.jsx)(t.code,{children:"configureStore"})," also adds an equivalent ",(0,i.jsx)(t.code,{children:".prepend()"})," method that makes a copy with the new items at the ",(0,i.jsx)(t.em,{children:"start"})," of the array."]}),"\n",(0,i.jsxs)(t.p,{children:["So, we'll call ",(0,i.jsx)(t.code,{children:"getDefaultMiddleware().prepend(listenerMiddleware.middleware)"})," to add this to the front of the list."]}),"\n",(0,i.jsx)(t.h3,{id:"showing-toasts-for-new-posts",children:"Showing Toasts for New Posts"}),"\n",(0,i.jsx)(t.p,{children:"Now that we have the listener middleware configured, we can add a new listener entry that will show a toast message any time a new post successfully gets added."}),"\n",(0,i.jsxs)(t.p,{children:["We're going to use the ",(0,i.jsx)(t.code,{children:"react-tiny-toast"})," library to manage showing toasts with the right appearance. It's already included in the project repo, so we don't have to install it."]}),"\n",(0,i.jsxs)(t.p,{children:["We do need to import and render its ",(0,i.jsx)(t.code,{children:"<ToastContainer>"})," component in our ",(0,i.jsx)(t.code,{children:"<App>"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="App.tsx"',children:"import React from 'react'\nimport {\n  BrowserRouter as Router,\n  Route,\n  Routes,\n  Navigate\n} from 'react-router-dom'\n// highlight-next-line\nimport { ToastContainer } from 'react-tiny-toast'\n\n// omit other imports and ProtectedRoute definition\n\nfunction App() {\n  return (\n    <Router>\n      <Navbar />\n      <div className=\"App\">\n        <Routes>{/* omit routes content */}</Routes>\n        // highlight-next-line\n        <ToastContainer />\n      </div>\n    </Router>\n  )\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now we can go add a listener that will watch for the ",(0,i.jsx)(t.code,{children:"addNewPost.fulfilled"}),' action, show a toast that says "Post Added", and remove it after a delay.']}),"\n",(0,i.jsxs)(t.p,{children:["There's ",(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/api/createListenerMiddleware#organizing-listeners-in-files",children:"multiple approaches we can use for defining listeners in our codebase"}),". That said, it's usually a good practice to define listeners in whatever slice file seems most related to the logic we want to add. In this case, we want to show a toast when a post gets added, so let's add this listener in the ",(0,i.jsx)(t.code,{children:"postsSlice"})," file:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/posts/postsSlice.ts"',children:"import {\n  createEntityAdapter,\n  createSelector,\n  createSlice,\n  EntityState,\n  PayloadAction\n} from '@reduxjs/toolkit'\nimport { client } from '@/api/client'\n\nimport type { RootState } from '@/app/store'\n// highlight-next-line\nimport { AppStartListening } from '@/app/listenerMiddleware'\nimport { createAppAsyncThunk } from '@/app/withTypes'\n\n// omit types, initial state, slice definition, and selectors\n\nexport const selectPostsStatus = (state: RootState) => state.posts.status\nexport const selectPostsError = (state: RootState) => state.posts.error\n\n// highlight-start\nexport const addPostsListeners = (startAppListening: AppStartListening) => {\n  startAppListening({\n    actionCreator: addNewPost.fulfilled,\n    effect: async (action, listenerApi) => {\n      const { toast } = await import('react-tiny-toast')\n\n      const toastId = toast.show('New post added!', {\n        variant: 'success',\n        position: 'bottom-right',\n        pause: true\n      })\n\n      await listenerApi.delay(5000)\n      toast.remove(toastId)\n    }\n  })\n}\n// highlight-end\n"})}),"\n",(0,i.jsxs)(t.p,{children:["To add a listener, we need to call the ",(0,i.jsx)(t.code,{children:"startAppListening"})," function that was defined in ",(0,i.jsx)(t.code,{children:"app/listenerMiddleware.ts"}),". However, it's better if we ",(0,i.jsx)(t.em,{children:"don't"})," import ",(0,i.jsx)(t.code,{children:"startAppListening"})," directly into the slice file, to help keep the import chains more consistent. Instead, we can export a function that accepts ",(0,i.jsx)(t.code,{children:"startAppListening"})," as an argument. That way, the ",(0,i.jsx)(t.code,{children:"app/listenerMiddleware.ts"})," file can import this function, similar to the way ",(0,i.jsx)(t.code,{children:"app/store.ts"})," imports the slice reducers from each slice file."]}),"\n",(0,i.jsxs)(t.p,{children:["To add a listener entry, call ",(0,i.jsx)(t.code,{children:"startAppListening"})," and pass in an object with an ",(0,i.jsx)(t.code,{children:"effect"})," callback function, and one of these options to define when the effect callback will run:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"actionCreator: ActionCreator"}),": any RTK action creator function, like ",(0,i.jsx)(t.code,{children:"reactionAdded"})," or ",(0,i.jsx)(t.code,{children:"addNewPost.fulfilled"}),". This will run the effect when that one specific action is dispatched."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"matcher: (action: UnknownAction) => boolean"}),": Any RTK ",(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/api/matching-utilities",children:'"matcher" function'}),", like ",(0,i.jsx)(t.code,{children:"isAnyOf(reactionAdded, addNewPost.fulfilled)"}),". This will run the effect any time the matcher returns ",(0,i.jsx)(t.code,{children:"true"}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"predicate: (action: UnknownAction, currState: RootState, prevState: RootState) => boolean"}),": a more general matching function that has access to ",(0,i.jsx)(t.code,{children:"currState"})," and ",(0,i.jsx)(t.code,{children:"prevState"}),". This can be used to make any check you want against the action or state values, including seeing if a piece of state has changed (such as ",(0,i.jsx)(t.code,{children:"currState.counter.value !== prevState.counter.value"}),")"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["In this case, we specifically want to show our toast any time the ",(0,i.jsx)(t.code,{children:"addNewPost"})," thunk succeeds, so we'll specify the effect should run with ",(0,i.jsx)(t.code,{children:"actionCreator: addNewPost.fulfilled"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"effect"})," callback itself is much like an async thunk. It gets the matched ",(0,i.jsx)(t.code,{children:"action"})," as the first argument, and a ",(0,i.jsx)(t.code,{children:"listenerApi"})," object as the second argument."]}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"listenerApi"})," includes the usual ",(0,i.jsx)(t.code,{children:"dispatch"})," and ",(0,i.jsx)(t.code,{children:"getState"})," methods, but also ",(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/api/createListenerMiddleware#listener-api",children:"several other functions that can be used to implement complex async logic and workflows"}),". That includes methods like ",(0,i.jsx)(t.code,{children:"condition()"})," to pause until some other action is dispatched or state value changes, ",(0,i.jsx)(t.code,{children:"unsubscribe()/subscribe()"})," to change whether this listener entry is active, ",(0,i.jsx)(t.code,{children:"fork()"})," to kick off a child task, and more."]}),"\n",(0,i.jsxs)(t.p,{children:["In this case, we want to import the actual ",(0,i.jsx)(t.code,{children:"react-tiny-toast"})," library dynamically, show the success toast, wait a few seconds, and then remove the toast."]}),"\n",(0,i.jsxs)(t.p,{children:["Finally, we need to actually import and call ",(0,i.jsx)(t.code,{children:"addPostsListeners"})," somewhere. In this case, we'll import it into ",(0,i.jsx)(t.code,{children:"app/listenerMiddleware.ts"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="app/listenerMiddleware.ts"',children:"import { createListenerMiddleware, addListener } from '@reduxjs/toolkit'\nimport type { RootState, AppDispatch } from './store'\n\n// highlight-next-line\nimport { addPostsListeners } from '@/features/posts/postsSlice'\n\nexport const listenerMiddleware = createListenerMiddleware()\n\nexport const startAppListening = listenerMiddleware.startListening.withTypes<\n  RootState,\n  AppDispatch\n>()\nexport type AppStartListening = typeof startAppListening\n\nexport const addAppListener = addListener.withTypes<RootState, AppDispatch>()\nexport type AppAddListener = typeof addAppListener\n\n// highlight-start\n// Call this and pass in `startAppListening` to let the\n// posts slice set up its listeners\naddPostsListeners(startAppListening)\n// highlight-end\n"})}),"\n",(0,i.jsx)(t.p,{children:"Now when we add a new post, we should see a small green toast pop up in the lower right-hand corner of the page, and disappear after 5 seconds. This works because the listener middleware in the Redux store checks and runs the effect callback after the action was dispatched, even though we didn't specifically add any more logic to the React components themselves."}),"\n",(0,i.jsx)(t.h2,{id:"what-youve-learned",children:"What You've Learned"}),"\n",(0,i.jsx)(t.p,{children:"We've built a lot of new behavior in this section. Let's see what how the app looks with all those changes:"}),"\n",(0,i.jsx)("iframe",{class:"codesandbox",src:"https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/ts-checkpoint-4-listenerToasts?fontsize=14&hidenavigation=1&module=%2fsrc%2Ffeatures%2Fposts%2FpostsSlice.ts&theme=dark&runonclick=1",title:"redux-essentials-example",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),"\n",(0,i.jsx)(t.p,{children:"Here's what we covered in this section:"}),"\n",(0,i.jsx)(t.admonition,{title:"Summary",type:"tip",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Memoized selector functions can be used to optimize performance"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Redux Toolkit re-exports the ",(0,i.jsx)(t.code,{children:"createSelector"})," function from Reselect, which generates memoized selectors"]}),"\n",(0,i.jsx)(t.li,{children:"Memoized selectors will only recalculate the results if the input selectors return new values"}),"\n",(0,i.jsx)(t.li,{children:"Memoization can skip expensive calculations, and ensure the same result references are returned"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"There are multiple patterns you can use to optimize React component rendering with Redux"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Avoid creating new object/array references inside of ",(0,i.jsx)(t.code,{children:"useSelector"})," - those will cause unnecessary re-renders"]}),"\n",(0,i.jsxs)(t.li,{children:["Memoized selector functions can be passed to ",(0,i.jsx)(t.code,{children:"useSelector"})," to optimize rendering"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"useSelector"})," can accept an alternate comparison function like ",(0,i.jsx)(t.code,{children:"shallowEqual"})," instead of reference equality"]}),"\n",(0,i.jsxs)(t.li,{children:["Components can be wrapped in ",(0,i.jsx)(t.code,{children:"React.memo()"})," to only re-render if their props change"]}),"\n",(0,i.jsx)(t.li,{children:"List rendering can be optimized by having list parent components read just an array of item IDs, passing the IDs to list item children, and retrieving items by ID in the children"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Normalized state structure is a recommended approach for storing items"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'"Normalization" means no duplication of data, and keeping items stored in a lookup table by item ID'}),"\n",(0,i.jsxs)(t.li,{children:["Normalized state shape usually looks like ",(0,i.jsx)(t.code,{children:"{ids: [], entities: {}}"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsxs)(t.strong,{children:["Redux Toolkit's ",(0,i.jsx)(t.code,{children:"createEntityAdapter"})," API helps manage normalized data in a slice"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Item IDs can be kept in sorted order by passing in a ",(0,i.jsx)(t.code,{children:"sortComparer"})," option"]}),"\n",(0,i.jsxs)(t.li,{children:["The adapter object includes:","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"adapter.getInitialState"}),", which can accept additional state fields like loading state"]}),"\n",(0,i.jsxs)(t.li,{children:["Prebuilt reducers for common cases, like ",(0,i.jsx)(t.code,{children:"setAll"}),", ",(0,i.jsx)(t.code,{children:"addMany"}),", ",(0,i.jsx)(t.code,{children:"upsertOne"}),", and ",(0,i.jsx)(t.code,{children:"removeMany"})]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"adapter.getSelectors"}),", which generates selectors like ",(0,i.jsx)(t.code,{children:"selectAll"})," and ",(0,i.jsx)(t.code,{children:"selectById"})]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsxs)(t.strong,{children:["Redux Toolkit's ",(0,i.jsx)(t.code,{children:"createListenerMiddleware"})," API is used to run reactive logic in response to dispatched actions"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The listener middleware should be added to the store setup, with the right store types attached"}),"\n",(0,i.jsx)(t.li,{children:"Listeners are typically defined in slice files, but may be structured other ways as well"}),"\n",(0,i.jsx)(t.li,{children:"Listeners can match against individual actions, many actions, or use custom comparisons"}),"\n",(0,i.jsx)(t.li,{children:"Listener effect callbacks can contain any sync or async logic"}),"\n",(0,i.jsxs)(t.li,{children:["The ",(0,i.jsx)(t.code,{children:"listenerApi"})," object provides many methods for managing async workflows and behavior"]}),"\n"]}),"\n"]}),"\n"]})}),"\n",(0,i.jsx)(t.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:'Redux Toolkit also includes a powerful data fetching and caching API called "RTK Query"'}),". RTK Query is an optional addon that can completely eliminate the need to write any data fetching logic yourself. In ",(0,i.jsx)(t.a,{href:"/tutorials/essentials/part-7-rtk-query-basics",children:"Part 7: RTK Query Basics"}),", you'll learn what RTK Query is, what problems it solves, and how to use it to fetch and use cached data in your application."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},3273:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/userpage-optimized-d13b7234b39ee2bab35850957aa7c565.png"},3360:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/notifications-new-bcc16426628f559f669f84d905827df9.png"},7936:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/postslist-rerender-9bc528bfe01ce0061f52d0b28fe61a03.png"},8090:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/notifications-initial-f816879edaf36c592966efd8b2e9c127.png"},8315:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/userpage-rerender-a952574967005f2e3fc3b96299c1f980.png"},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>r});var s=n(6540);const i={},o=s.createContext(i);function a(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:t},e.children)}},9692:(e,t,n)=>{n.d(t,{E:()=>i});n(6540);var s=n(4848);const i=e=>{let{children:t,title:n="Detailed Explanation"}=e;return(0,s.jsxs)("details",{className:"detailed-explanation",children:[(0,s.jsx)("summary",{children:(0,s.jsx)("h4",{children:n})}),t]})}}}]);