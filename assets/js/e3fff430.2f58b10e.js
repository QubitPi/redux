"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7760],{5610:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>a,contentTitle:()=>o,default:()=>d,frontMatter:()=>c,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"usage/structuring-reducers/splitting-reducer-logic","title":"Splitting Reducer Logic","description":"Structuring Reducers > Splitting Reducer Logic: Terms for different reducer use cases","source":"@site/../docs/usage/structuring-reducers/SplittingReducerLogic.md","sourceDirName":"usage/structuring-reducers","slug":"/usage/structuring-reducers/splitting-reducer-logic","permalink":"/usage/structuring-reducers/splitting-reducer-logic","draft":false,"unlisted":false,"editUrl":"https://github.com/reduxjs/redux/edit/master/website/../docs/usage/structuring-reducers/SplittingReducerLogic.md","tags":[],"version":"current","lastUpdatedAt":1747212223000,"frontMatter":{"id":"splitting-reducer-logic","title":"Splitting Reducer Logic","sidebar_label":"Splitting Reducer Logic","description":"Structuring Reducers > Splitting Reducer Logic: Terms for different reducer use cases"},"sidebar":"docs","previous":{"title":"Basic Reducer Structure","permalink":"/usage/structuring-reducers/basic-reducer-structure"},"next":{"title":"Refactoring Reducers Example","permalink":"/usage/structuring-reducers/refactoring-reducer-example"}}');var n=i(4848),s=i(8453);const c={id:"splitting-reducer-logic",title:"Splitting Reducer Logic",sidebar_label:"Splitting Reducer Logic",description:"Structuring Reducers > Splitting Reducer Logic: Terms for different reducer use cases"},o="Splitting Up Reducer Logic",a={},l=[];function u(e){const t={a:"a",code:"code",em:"em",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.header,{children:(0,n.jsx)(t.h1,{id:"splitting-up-reducer-logic",children:"Splitting Up Reducer Logic"})}),"\n",(0,n.jsxs)(t.p,{children:["For any meaningful application, putting ",(0,n.jsx)(t.em,{children:"all"})," your update logic into a single reducer function is quickly going to become unmaintainable. While there's no single rule for how long a function should be, it's generally agreed that functions should be relatively short and ideally only do one specific thing. Because of this, it's good programming practice to take pieces of code that are very long or do many different things, and break them into smaller pieces that are easier to understand."]}),"\n",(0,n.jsxs)(t.p,{children:["Since a Redux reducer is ",(0,n.jsx)(t.em,{children:"just"})," a function, the same concept applies. You can split some of your reducer logic out into another function, and call that new function from the parent function."]}),"\n",(0,n.jsx)(t.p,{children:"These new functions would typically fall into one of three categories:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:"Small utility functions containing some reusable chunk of logic that is needed in multiple places (which may or may not be actually related to the specific business logic)"}),"\n",(0,n.jsxs)(t.li,{children:["Functions for handling a specific update case, which often need parameters other than the typical ",(0,n.jsx)(t.code,{children:"(state, action)"})," pair"]}),"\n",(0,n.jsxs)(t.li,{children:["Functions which handle ",(0,n.jsx)(t.em,{children:"all"})," updates for a given slice of state. These functions do generally have the typical ",(0,n.jsx)(t.code,{children:"(state, action)"})," parameter signature"]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"For clarity, these terms will be used to distinguish between different types of functions and different use cases:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.em,{children:"reducer"})}),": any function with the signature ",(0,n.jsx)(t.code,{children:"(state, action) -> newState"})," (ie, any function that ",(0,n.jsx)(t.em,{children:"could"})," be used as an argument to ",(0,n.jsx)(t.code,{children:"Array.prototype.reduce"}),")"]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.em,{children:"root reducer"})}),": the reducer function that is actually passed as the first argument to ",(0,n.jsx)(t.code,{children:"createStore"}),". This is the only part of the reducer logic that ",(0,n.jsx)(t.em,{children:"must"})," have the ",(0,n.jsx)(t.code,{children:"(state, action) -> newState"})," signature."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.em,{children:"slice reducer"})}),": a reducer that is being used to handle updates to one specific slice of the state tree, usually done by passing it to ",(0,n.jsx)(t.code,{children:"combineReducers"})]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.em,{children:"case function"})}),": a function that is being used to handle the update logic for a specific action. This may actually be a reducer function, or it may require other parameters to do its work properly."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.em,{children:"higher-order reducer"})}),": a function that takes a reducer function as an argument, and/or returns a new reducer function as a result (such as ",(0,n.jsx)(t.code,{children:"combineReducers"}),", or ",(0,n.jsx)(t.code,{children:"redux-undo"}),")"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:['The term "',(0,n.jsx)(t.em,{children:"sub-reducer"}),'" has also been used in various discussions to mean any function that is not the root reducer, although the term is not very precise. Some people may also refer to some functions as "',(0,n.jsx)(t.em,{children:"business logic"}),'" (functions that relate to application-specific behavior) or "',(0,n.jsx)(t.em,{children:"utility functions"}),'" (generic functions that are not application-specific).']}),"\n",(0,n.jsxs)(t.p,{children:["Breaking down a complex process into smaller, more understandable parts is usually described with the term ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.em,{children:(0,n.jsx)(t.a,{href:"https://stackoverflow.com/questions/947874/what-is-functional-decomposition",children:"functional decomposition"})})}),". This term and concept can be applied generically to any code. However, in Redux it is ",(0,n.jsx)(t.em,{children:"very"})," common to structure reducer logic using approach #3, where update logic is delegated to other functions based on slice of state. Redux refers to this concept as ",(0,n.jsx)(t.strong,{children:(0,n.jsx)(t.em,{children:"reducer composition"})}),", and it is by far the most widely-used approach to structuring reducer logic. In fact, it's so common that Redux includes a utility function called ",(0,n.jsx)(t.a,{href:"/api/combinereducers",children:(0,n.jsx)(t.code,{children:"combineReducers()"})}),", which specifically abstracts the process of delegating work to other reducer functions based on slices of state. However, it's important to note that it is not the ",(0,n.jsx)(t.em,{children:"only"})," pattern that can be used. In fact, it's entirely possible to use all three approaches for splitting up logic into functions, and usually a good idea as well. The ",(0,n.jsx)(t.a,{href:"/usage/structuring-reducers/refactoring-reducer-example",children:"Refactoring Reducers"})," section shows some examples of this in action."]})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>c,x:()=>o});var r=i(6540);const n={},s=r.createContext(n);function c(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:c(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);