"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9936],{7393:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>n,toc:()=>l});const n=JSON.parse('{"id":"understanding/history-and-design/history-of-redux","title":"The History of Redux","description":"Understanding > The History of Redux","source":"@site/../docs/understanding/history-and-design/history-of-redux.md","sourceDirName":"understanding/history-and-design","slug":"/understanding/history-and-design/history-of-redux","permalink":"/understanding/history-and-design/history-of-redux","draft":false,"unlisted":false,"editUrl":"https://github.com/reduxjs/redux/edit/master/website/../docs/understanding/history-and-design/history-of-redux.md","tags":[],"version":"current","lastUpdatedAt":1747212223000,"frontMatter":{"id":"history-of-redux","title":"The History of Redux","description":"Understanding > The History of Redux"},"sidebar":"docs","previous":{"title":"Glossary","permalink":"/understanding/thinking-in-redux/glossary"},"next":{"title":"Prior Art","permalink":"/understanding/history-and-design/prior-art"}}');var o=a(4848),i=a(8453);const s={id:"history-of-redux",title:"The History of Redux",description:"Understanding > The History of Redux"},r="A (Brief) History of Redux",d={},l=[{value:"2011: JS MVC Frameworks",id:"2011-js-mvc-frameworks",level:2},{value:"2014: Flux",id:"2014-flux",level:2},{value:"2015: The Birth of Redux",id:"2015-the-birth-of-redux",level:2},{value:"2017: Ecosystem Competition",id:"2017-ecosystem-competition",level:2},{value:"2019: Redux Toolkit",id:"2019-redux-toolkit",level:2},{value:"Further Information",id:"further-information",level:2}];function h(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"a-brief-history-of-redux",children:"A (Brief) History of Redux"})}),"\n",(0,o.jsx)(t.h2,{id:"2011-js-mvc-frameworks",children:"2011: JS MVC Frameworks"}),"\n",(0,o.jsxs)(t.p,{children:['Early JavaScript MVC frameworks like AngularJS, Ember, and Backbone had issues. AngularJS tried to enforce separation of "controllers" from templates, but nothing prevented you from writing ',(0,o.jsx)(t.code,{children:'<div onClick="$ctrl.some.deeply.nested.field = 123">'})," in a template. Meanwhile, Backbone was based on event emitters - Models, Collections, and Views were all each capable of emitting events. Models might emit a ",(0,o.jsx)(t.code,{children:'"change:firstName"'})," event, and Views would subscribe to those. But, ",(0,o.jsx)(t.em,{children:"any"})," code could subscribe to those events and run more logic, which could trigger ",(0,o.jsx)(t.em,{children:"more"})," events"]}),"\n",(0,o.jsx)(t.p,{children:"That made these frameworks very hard to debug and maintain. It was possible that updating one field in one model could trigger dozens of events and logic running around the app, or that any template could make changes to state at any time, which made it impossible to understand what would happen when you did a state update."}),"\n",(0,o.jsx)(t.h2,{id:"2014-flux",children:"2014: Flux"}),"\n",(0,o.jsx)(t.p,{children:'Back around 2012-2013, when React was first publicly released, Facebook had been using it internally for a couple years. One of the problems they ran into was that they had multiple independent pieces of their UI that needed access to the same data, like "how many unread notifications are there", but they found it hard to keep that logic straight when using Backbone-style code.'}),"\n",(0,o.jsxs)(t.p,{children:['Facebook ultimately came up with a pattern called "Flux": create multiple singleton Stores, like a ',(0,o.jsx)(t.code,{children:"PostsStore"})," and ",(0,o.jsx)(t.code,{children:"CommentsStore"}),". Each of those Store instances would register with a ",(0,o.jsx)(t.code,{children:"Dispatcher"}),", and the ",(0,o.jsx)(t.em,{children:"only"})," way to trigger an update in a store was to call ",(0,o.jsx)(t.code,{children:'Dispatcher.dispatch({type: "somethingHappened"})'}),'. That plain object was called an "action". The idea was that all the state update logic would be semi-centralized - you couldn\'t just have any random part of the app mutate state, and all the state updates would be predictable.']}),"\n",(0,o.jsxs)(t.p,{children:['Facebook announced this "Flux Architecture" concept around 2014, but didn\'t provide a full library that implemented that pattern. That led the React community to build ',(0,o.jsx)(t.em,{children:"dozens"})," of Flux-inspired libraries with variations on the pattern."]}),"\n",(0,o.jsx)(t.h2,{id:"2015-the-birth-of-redux",children:"2015: The Birth of Redux"}),"\n",(0,o.jsxs)(t.p,{children:['In mid-2015, Dan Abramov began building yet another Flux-inspired library, called Redux. The idea was to demonstrate "time-travel debugging" for a ',(0,o.jsx)(t.a,{href:"https://youtu.be/xsSnOQynTHs?t=601",children:"conference talk"}),". The library was designed to use the Flux pattern, but with some functional programming principles applied. Rather than Store ",(0,o.jsx)(t.em,{children:"instances"}),", you could use predictable reducer functions that did immutable updates. This would allow jumping back and forth in time to see how the state looked at various points. It would also make the code more straightforward, testable, and understandable."]}),"\n",(0,o.jsxs)(t.p,{children:["Redux came out in 2015, and quickly killed off all the other Flux-inspired libraries. It got early adoption from advanced developers in the React ecosystem, and by 2016, many people began to say that \"if you're using React, you ",(0,o.jsx)(t.em,{children:"must"})," be using Redux too\". (Frankly, this led to a lot of people using Redux in places they didn't ",(0,o.jsx)(t.em,{children:"need"})," to be using it!)"]}),"\n",(0,o.jsxs)(t.p,{children:["It's also worth noting that at the time, React only had its ",(0,o.jsx)(t.em,{children:"legacy"})," Context API, which had was basically broken: it couldn't properly pass ",(0,o.jsx)(t.em,{children:"updated"})," values down. So, it was possible to put event emitters into Context and subscribe to them, but you couldn't really use it for plain data. That meant that a lot of people began adopting Redux because it ",(0,o.jsx)(t.em,{children:"was"})," a way to consistently pass updated values around the entire application."]}),"\n",(0,o.jsxs)(t.p,{children:['Dan said early on that "Redux is not meant to be the ',(0,o.jsx)(t.em,{children:"shortest"})," way to write code - it's meant to make it predictable and understandable\". Part of that is about having a consistent pattern (state updates are done by reducers, so you always look at the reducer logic to see what the state values ",(0,o.jsx)(t.em,{children:"can"})," be, what the possible actions are, and what updates they cause). It's also about moving logic ",(0,o.jsx)(t.em,{children:"out"}),' of the component tree, so that the UI mostly just says "this thing happened", and your components are simpler. Along with that, code that is written as "pure functions", like reducers and selectors, are more straightforward to understand: arguments in, result out, nothing else to look at. Finally, Redux\'s design enabled the Redux DevTools, which show you a readable list of all the actions that were dispatched, what the actions/state contained, and changes occurred for each action.']}),"\n",(0,o.jsxs)(t.p,{children:["The early Redux patterns were especially boilerplate-heavy. It was common to have ",(0,o.jsx)(t.code,{children:"actions/todos.js"}),", ",(0,o.jsx)(t.code,{children:"reducers/todos.js"}),", and ",(0,o.jsx)(t.code,{children:"constants/todos.js"}),", just to define a single action type ( ",(0,o.jsx)(t.code,{children:'const ADD_TODO = "ADD_TODO"'}),"), action creator function, and reducer case. You also had to hand-write immutable updates with spread operators, which were easy to mess up. People did fetch and cache server state in Redux, but it took a lot of manually-written code to write thunks to do the fetching, dispatch the actions with the fetched data, and manage the cache status in the reducers."]}),"\n",(0,o.jsxs)(t.p,{children:["Redux became popular in ",(0,o.jsx)(t.em,{children:"spite"})," of that boilerplate, but it was always the biggest point of concern."]}),"\n",(0,o.jsx)(t.h2,{id:"2017-ecosystem-competition",children:"2017: Ecosystem Competition"}),"\n",(0,o.jsxs)(t.p,{children:['By 2017-18, things had changed. A lot of the community was now focusing more on "data fetching and caching" rather than "client-side state management", and that\'s when we saw the rise of libraries like Apollo, React Query, SWR, and Urql for data fetching. At the same time, we also had the ',(0,o.jsx)(t.em,{children:"new"})," React Context API came out, which does properly pass updated values down the component tree."]}),"\n",(0,o.jsx)(t.p,{children:'That meant that Redux wasn\'t nearly as "required" as it used to be - there were now other tools that solved many of the same problems, with varying amounts of overlap (and often with less code). The frequent complaints about "boilerplate" also caused a lot of concern from folks using Redux.'}),"\n",(0,o.jsx)(t.h2,{id:"2019-redux-toolkit",children:"2019: Redux Toolkit"}),"\n",(0,o.jsx)(t.p,{children:'So, in 2019, we built and shipped Redux Toolkit as a simpler way to write the same Redux logic with less code. RTK is still "Redux" (single store, dispatching actions to trigger state updates done in reducers via immutable update logic), but with a simpler API and better built-in default behaviors. That also includes RTK Query, our built-in data fetching and caching library that was inspired by React Query and Apollo.'}),"\n",(0,o.jsxs)(t.p,{children:["Today, ",(0,o.jsx)(t.a,{href:"/introduction/why-rtk-is-redux-today",children:"RTK is the standard way to write Redux logic"}),". Like all tools, it has tradeoffs. RTK is probably going to be a bit more code to use than Zustand, but it also provides useful patterns for separating app logic from the UI. Redux isn't the right tool for every app, but it is still the most widely used state management lib with React apps, has excellent documentation, and provides a lot of features to help you build apps with a consistent and predictable structure."]}),"\n",(0,o.jsx)(t.h2,{id:"further-information",children:"Further Information"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://blog.isquaredsoftware.com/2017/05/idiomatic-redux-tao-of-redux-part-1/",children:"The Tao of Redux, Part 1: Implementation and Intent"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://blog.isquaredsoftware.com/2021/01/context-redux-differences/",children:'Why React Context is Not a "State Management" Tool (and Why It Doesn\'t Replace Redux)'})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://blog.isquaredsoftware.com/2019/10/redux-toolkit-1.0/",children:"Idiomatic Redux: Redux Toolkit 1.0"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.a,{href:"https://changelog.com/podcast/187",children:"Changelog #187: Dan Abramov talks about Redux"})}),"\n",(0,o.jsxs)(t.li,{children:[(0,o.jsx)(t.a,{href:"https://gist.github.com/markerikson/2971210292a9c65138eeb33ae7d560b0",children:"Redux Archeology and Design Notes"})," (with links to early design discussions and descriptions of project design goals)"]}),"\n"]})]})}function c(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(h,{...e})}):h(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>r});var n=a(6540);const o={},i=n.createContext(o);function s(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);