"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2021],{348:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>c,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"usage/structuring-reducers/refactoring-reducer-example","title":"Refactoring Reducers Example","description":"Structuring Reducers > Refactoring Reducers: Examples of ways to refactor reducer logic","source":"@site/../docs/usage/structuring-reducers/RefactoringReducersExample.md","sourceDirName":"usage/structuring-reducers","slug":"/usage/structuring-reducers/refactoring-reducer-example","permalink":"/usage/structuring-reducers/refactoring-reducer-example","draft":false,"unlisted":false,"editUrl":"https://github.com/reduxjs/redux/edit/master/website/../docs/usage/structuring-reducers/RefactoringReducersExample.md","tags":[],"version":"current","lastUpdatedAt":1747212223000,"frontMatter":{"id":"refactoring-reducer-example","title":"Refactoring Reducers Example","sidebar_label":"Refactoring Reducers Example","description":"Structuring Reducers > Refactoring Reducers: Examples of ways to refactor reducer logic"},"sidebar":"docs","previous":{"title":"Splitting Reducer Logic","permalink":"/usage/structuring-reducers/splitting-reducer-logic"},"next":{"title":"Using combineReducers","permalink":"/usage/structuring-reducers/using-combinereducers"}}');var o=n(4848),a=n(8453);const r={id:"refactoring-reducer-example",title:"Refactoring Reducers Example",sidebar_label:"Refactoring Reducers Example",description:"Structuring Reducers > Refactoring Reducers: Examples of ways to refactor reducer logic"},c="Refactoring Reducer Logic Using Functional Decomposition and Reducer Composition",s={},d=[{value:"Initial Reducer",id:"initial-reducer",level:4},{value:"Extracting Utility Functions",id:"extracting-utility-functions",level:4},{value:"Extracting Case Reducers",id:"extracting-case-reducers",level:4},{value:"Separating Data Handling by Domain",id:"separating-data-handling-by-domain",level:4},{value:"Reducing Boilerplate",id:"reducing-boilerplate",level:4},{value:"Combining Reducers by Slice",id:"combining-reducers-by-slice",level:4}];function l(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h1:"h1",h4:"h4",header:"header",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"refactoring-reducer-logic-using-functional-decomposition-and-reducer-composition",children:"Refactoring Reducer Logic Using Functional Decomposition and Reducer Composition"})}),"\n",(0,o.jsx)(t.p,{children:"It may be helpful to see examples of what the different types of sub-reducer functions look like and how they fit together. Let's look at a demonstration of how a large single reducer function can be refactored into a composition of several smaller functions."}),"\n",(0,o.jsxs)(t.blockquote,{children:["\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.strong,{children:"Note"}),": this example is deliberately written in a verbose style in order to illustrate the concepts and the process of refactoring, rather than perfectly concise code."]}),"\n"]}),"\n",(0,o.jsx)(t.h4,{id:"initial-reducer",children:"Initial Reducer"}),"\n",(0,o.jsx)(t.p,{children:"Let's say that our initial reducer looks like this:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"const initialState = {\n  visibilityFilter: 'SHOW_ALL',\n  todos: []\n}\n\nfunction appReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER': {\n      return Object.assign({}, state, {\n        visibilityFilter: action.filter\n      })\n    }\n    case 'ADD_TODO': {\n      return Object.assign({}, state, {\n        todos: state.todos.concat({\n          id: action.id,\n          text: action.text,\n          completed: false\n        })\n      })\n    }\n    case 'TOGGLE_TODO': {\n      return Object.assign({}, state, {\n        todos: state.todos.map(todo => {\n          if (todo.id !== action.id) {\n            return todo\n          }\n\n          return Object.assign({}, todo, {\n            completed: !todo.completed\n          })\n        })\n      })\n    }\n    case 'EDIT_TODO': {\n      return Object.assign({}, state, {\n        todos: state.todos.map(todo => {\n          if (todo.id !== action.id) {\n            return todo\n          }\n\n          return Object.assign({}, todo, {\n            text: action.text\n          })\n        })\n      })\n    }\n    default:\n      return state\n  }\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"That function is fairly short, but already becoming overly complex. We're dealing with two different areas of concern (filtering vs managing our list of todos), the nesting is making the update logic harder to read, and it's not exactly clear what's going on everywhere."}),"\n",(0,o.jsx)(t.h4,{id:"extracting-utility-functions",children:"Extracting Utility Functions"}),"\n",(0,o.jsx)(t.p,{children:"A good first step might be to break out a utility function to return a new object with updated fields. There's also a repeated pattern with trying to update a specific item in an array that we could extract to a function:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"function updateObject(oldObject, newValues) {\n  // Encapsulate the idea of passing a new object as the first parameter\n  // to Object.assign to ensure we correctly copy data instead of mutating\n  return Object.assign({}, oldObject, newValues)\n}\n\nfunction updateItemInArray(array, itemId, updateItemCallback) {\n  const updatedItems = array.map(item => {\n    if (item.id !== itemId) {\n      // Since we only want to update one item, preserve all others as they are now\n      return item\n    }\n\n    // Use the provided callback to create an updated item\n    const updatedItem = updateItemCallback(item)\n    return updatedItem\n  })\n\n  return updatedItems\n}\n\nfunction appReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER': {\n      return updateObject(state, { visibilityFilter: action.filter })\n    }\n    case 'ADD_TODO': {\n      const newTodos = state.todos.concat({\n        id: action.id,\n        text: action.text,\n        completed: false\n      })\n\n      return updateObject(state, { todos: newTodos })\n    }\n    case 'TOGGLE_TODO': {\n      const newTodos = updateItemInArray(state.todos, action.id, todo => {\n        return updateObject(todo, { completed: !todo.completed })\n      })\n\n      return updateObject(state, { todos: newTodos })\n    }\n    case 'EDIT_TODO': {\n      const newTodos = updateItemInArray(state.todos, action.id, todo => {\n        return updateObject(todo, { text: action.text })\n      })\n\n      return updateObject(state, { todos: newTodos })\n    }\n    default:\n      return state\n  }\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:"That reduced the duplication and made things a bit easier to read."}),"\n",(0,o.jsx)(t.h4,{id:"extracting-case-reducers",children:"Extracting Case Reducers"}),"\n",(0,o.jsx)(t.p,{children:"Next, we can split each specific case into its own function:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"// Omitted\nfunction updateObject(oldObject, newValues) {}\nfunction updateItemInArray(array, itemId, updateItemCallback) {}\n\nfunction setVisibilityFilter(state, action) {\n  return updateObject(state, { visibilityFilter: action.filter })\n}\n\nfunction addTodo(state, action) {\n  const newTodos = state.todos.concat({\n    id: action.id,\n    text: action.text,\n    completed: false\n  })\n\n  return updateObject(state, { todos: newTodos })\n}\n\nfunction toggleTodo(state, action) {\n  const newTodos = updateItemInArray(state.todos, action.id, todo => {\n    return updateObject(todo, { completed: !todo.completed })\n  })\n\n  return updateObject(state, { todos: newTodos })\n}\n\nfunction editTodo(state, action) {\n  const newTodos = updateItemInArray(state.todos, action.id, todo => {\n    return updateObject(todo, { text: action.text })\n  })\n\n  return updateObject(state, { todos: newTodos })\n}\n\nfunction appReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER':\n      return setVisibilityFilter(state, action)\n    case 'ADD_TODO':\n      return addTodo(state, action)\n    case 'TOGGLE_TODO':\n      return toggleTodo(state, action)\n    case 'EDIT_TODO':\n      return editTodo(state, action)\n    default:\n      return state\n  }\n}\n"})}),"\n",(0,o.jsxs)(t.p,{children:["Now it's ",(0,o.jsx)(t.em,{children:"very"})," clear what's happening in each case. We can also start to see some patterns emerging."]}),"\n",(0,o.jsx)(t.h4,{id:"separating-data-handling-by-domain",children:"Separating Data Handling by Domain"}),"\n",(0,o.jsx)(t.p,{children:"Our app reducer is still aware of all the different cases for our application. Let's try splitting things up so that the filter logic and the todo logic are separated:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"// Omitted\nfunction updateObject(oldObject, newValues) {}\nfunction updateItemInArray(array, itemId, updateItemCallback) {}\n\nfunction setVisibilityFilter(visibilityState, action) {\n  // Technically, we don't even care about the previous state\n  return action.filter\n}\n\nfunction visibilityReducer(visibilityState = 'SHOW_ALL', action) {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER':\n      return setVisibilityFilter(visibilityState, action)\n    default:\n      return visibilityState\n  }\n}\n\nfunction addTodo(todosState, action) {\n  const newTodos = todosState.concat({\n    id: action.id,\n    text: action.text,\n    completed: false\n  })\n\n  return newTodos\n}\n\nfunction toggleTodo(todosState, action) {\n  const newTodos = updateItemInArray(todosState, action.id, todo => {\n    return updateObject(todo, { completed: !todo.completed })\n  })\n\n  return newTodos\n}\n\nfunction editTodo(todosState, action) {\n  const newTodos = updateItemInArray(todosState, action.id, todo => {\n    return updateObject(todo, { text: action.text })\n  })\n\n  return newTodos\n}\n\nfunction todosReducer(todosState = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return addTodo(todosState, action)\n    case 'TOGGLE_TODO':\n      return toggleTodo(todosState, action)\n    case 'EDIT_TODO':\n      return editTodo(todosState, action)\n    default:\n      return todosState\n  }\n}\n\nfunction appReducer(state = initialState, action) {\n  return {\n    todos: todosReducer(state.todos, action),\n    visibilityFilter: visibilityReducer(state.visibilityFilter, action)\n  }\n}\n"})}),"\n",(0,o.jsx)(t.p,{children:'Notice that because the two "slice of state" reducers are now getting only their own part of the whole state as arguments, they no longer need to return complex nested state objects, and are now simpler as a result.'}),"\n",(0,o.jsx)(t.h4,{id:"reducing-boilerplate",children:"Reducing Boilerplate"}),"\n",(0,o.jsxs)(t.p,{children:["We're almost done. Since many people don't like switch statements, it's very common to use a function that creates a lookup table of action types to case functions. We'll use the ",(0,o.jsx)(t.code,{children:"createReducer"})," function described in ",(0,o.jsx)(t.a,{href:"../reducing-boilerplate",children:"Reducing Boilerplate"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:"// Omitted\nfunction updateObject(oldObject, newValues) {}\nfunction updateItemInArray(array, itemId, updateItemCallback) {}\n\nfunction createReducer(initialState, handlers) {\n  return function reducer(state = initialState, action) {\n    if (handlers.hasOwnProperty(action.type)) {\n      return handlers[action.type](state, action)\n    } else {\n      return state\n    }\n  }\n}\n\n// Omitted\nfunction setVisibilityFilter(visibilityState, action) {}\n\nconst visibilityReducer = createReducer('SHOW_ALL', {\n  SET_VISIBILITY_FILTER: setVisibilityFilter\n})\n\n// Omitted\nfunction addTodo(todosState, action) {}\nfunction toggleTodo(todosState, action) {}\nfunction editTodo(todosState, action) {}\n\nconst todosReducer = createReducer([], {\n  ADD_TODO: addTodo,\n  TOGGLE_TODO: toggleTodo,\n  EDIT_TODO: editTodo\n})\n\nfunction appReducer(state = initialState, action) {\n  return {\n    todos: todosReducer(state.todos, action),\n    visibilityFilter: visibilityReducer(state.visibilityFilter, action)\n  }\n}\n"})}),"\n",(0,o.jsx)(t.h4,{id:"combining-reducers-by-slice",children:"Combining Reducers by Slice"}),"\n",(0,o.jsxs)(t.p,{children:["As our last step, we can now use Redux's built-in ",(0,o.jsx)(t.code,{children:"combineReducers"}),' utility to handle the "slice-of-state" logic for our top-level app reducer. Here\'s the final result:']}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-js",children:'// Reusable utility functions\n\nfunction updateObject(oldObject, newValues) {\n  // Encapsulate the idea of passing a new object as the first parameter\n  // to Object.assign to ensure we correctly copy data instead of mutating\n  return Object.assign({}, oldObject, newValues)\n}\n\nfunction updateItemInArray(array, itemId, updateItemCallback) {\n  const updatedItems = array.map(item => {\n    if (item.id !== itemId) {\n      // Since we only want to update one item, preserve all others as they are now\n      return item\n    }\n\n    // Use the provided callback to create an updated item\n    const updatedItem = updateItemCallback(item)\n    return updatedItem\n  })\n\n  return updatedItems\n}\n\nfunction createReducer(initialState, handlers) {\n  return function reducer(state = initialState, action) {\n    if (handlers.hasOwnProperty(action.type)) {\n      return handlers[action.type](state, action)\n    } else {\n      return state\n    }\n  }\n}\n\n// Handler for a specific case ("case reducer")\nfunction setVisibilityFilter(visibilityState, action) {\n  // Technically, we don\'t even care about the previous state\n  return action.filter\n}\n\n// Handler for an entire slice of state ("slice reducer")\nconst visibilityReducer = createReducer(\'SHOW_ALL\', {\n  SET_VISIBILITY_FILTER: setVisibilityFilter\n})\n\n// Case reducer\nfunction addTodo(todosState, action) {\n  const newTodos = todosState.concat({\n    id: action.id,\n    text: action.text,\n    completed: false\n  })\n\n  return newTodos\n}\n\n// Case reducer\nfunction toggleTodo(todosState, action) {\n  const newTodos = updateItemInArray(todosState, action.id, todo => {\n    return updateObject(todo, { completed: !todo.completed })\n  })\n\n  return newTodos\n}\n\n// Case reducer\nfunction editTodo(todosState, action) {\n  const newTodos = updateItemInArray(todosState, action.id, todo => {\n    return updateObject(todo, { text: action.text })\n  })\n\n  return newTodos\n}\n\n// Slice reducer\nconst todosReducer = createReducer([], {\n  ADD_TODO: addTodo,\n  TOGGLE_TODO: toggleTodo,\n  EDIT_TODO: editTodo\n})\n\n// "Root reducer"\nconst appReducer = combineReducers({\n  visibilityFilter: visibilityReducer,\n  todos: todosReducer\n})\n'})}),"\n",(0,o.jsxs)(t.p,{children:["We now have examples of several kinds of split-up reducer functions: helper utilities like ",(0,o.jsx)(t.code,{children:"updateObject"})," and ",(0,o.jsx)(t.code,{children:"createReducer"}),", handlers for specific cases like ",(0,o.jsx)(t.code,{children:"setVisibilityFilter"})," and ",(0,o.jsx)(t.code,{children:"addTodo"}),", and slice-of-state handlers like ",(0,o.jsx)(t.code,{children:"visibilityReducer"})," and ",(0,o.jsx)(t.code,{children:"todosReducer"}),". We also can see that ",(0,o.jsx)(t.code,{children:"appReducer"}),' is an example of a "root reducer".']}),"\n",(0,o.jsxs)(t.p,{children:["Although the final result in this example is noticeably longer than the original version, this is primarily due to the extraction of the utility functions, the addition of comments, and some deliberate verbosity for the sake of clarity, such as separate return statements. Looking at each function individually, the amount of responsibility is now smaller, and the intent is hopefully clearer. Also, in a real application, these functions would probably then be split into separate files such as ",(0,o.jsx)(t.code,{children:"reducerUtilities.js"}),", ",(0,o.jsx)(t.code,{children:"visibilityReducer.js"}),", ",(0,o.jsx)(t.code,{children:"todosReducer.js"}),", and ",(0,o.jsx)(t.code,{children:"rootReducer.js"}),"."]})]})}function u(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>c});var i=n(6540);const o={},a=i.createContext(o);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);