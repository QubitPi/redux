"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3635],{3794:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/devtools-rtkq-tab-7094ef7a60ca89d5ee40367027103cb2.png"},3948:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"tutorials/essentials/part-7-rtk-query-basics","title":"Redux Essentials, Part 7: RTK Query Basics","description":"The official Redux Essentials tutorial: learn how to use RTK Query for data fetching","source":"@site/../docs/tutorials/essentials/part-7-rtk-query-basics.md","sourceDirName":"tutorials/essentials","slug":"/tutorials/essentials/part-7-rtk-query-basics","permalink":"/tutorials/essentials/part-7-rtk-query-basics","draft":false,"unlisted":false,"editUrl":"https://github.com/reduxjs/redux/edit/master/website/../docs/tutorials/essentials/part-7-rtk-query-basics.md","tags":[],"version":"current","lastUpdatedAt":1747212223000,"frontMatter":{"id":"part-7-rtk-query-basics","title":"Redux Essentials, Part 7: RTK Query Basics","sidebar_label":"RTK Query Basics","description":"The official Redux Essentials tutorial: learn how to use RTK Query for data fetching"},"sidebar":"docs","previous":{"title":"Performance, Normalizing Data, and Reactive Logic","permalink":"/tutorials/essentials/part-6-performance-normalization"},"next":{"title":"RTK Query Advanced Patterns","permalink":"/tutorials/essentials/part-8-rtk-query-advanced"}}');var i=n(4848),a=n(8453);n(9692);const o={id:"part-7-rtk-query-basics",title:"Redux Essentials, Part 7: RTK Query Basics",sidebar_label:"RTK Query Basics",description:"The official Redux Essentials tutorial: learn how to use RTK Query for data fetching"},r=void 0,d={},l=[{value:"Introduction",id:"introduction",level:2},{value:"RTK Query Overview",id:"rtk-query-overview",level:2},{value:"Motivation",id:"motivation",level:3},{value:"Server State Challenges",id:"server-state-challenges",level:4},{value:"RTK Query Differences",id:"rtk-query-differences",level:3},{value:"What&#39;s included",id:"whats-included",level:3},{value:"APIs",id:"apis",level:4},{value:"Bundle Size",id:"bundle-size",level:4},{value:"Thinking in RTK Query Caching",id:"thinking-in-rtk-query-caching",level:3},{value:"Setting Up RTK Query",id:"setting-up-rtk-query",level:2},{value:"Defining an API Slice",id:"defining-an-api-slice",level:3},{value:"API Slice Parameters",id:"api-slice-parameters",level:4},{value:"Defining Endpoints",id:"defining-endpoints",level:4},{value:"Exporting API Slices and Hooks",id:"exporting-api-slices-and-hooks",level:4},{value:"Configuring the Store",id:"configuring-the-store",level:3},{value:"Displaying Posts with Queries",id:"displaying-posts-with-queries",level:2},{value:"Using Query Hooks in Components",id:"using-query-hooks-in-components",level:3},{value:"Query Hook Result Objects",id:"query-hook-result-objects",level:3},{value:"Loading State Fields",id:"loading-state-fields",level:4},{value:"Sorting Posts",id:"sorting-posts",level:3},{value:"Displaying Individual Posts",id:"displaying-individual-posts",level:2},{value:"Adding the Single Post Query Endpoint",id:"adding-the-single-post-query-endpoint",level:3},{value:"Query Arguments and Cache Keys",id:"query-arguments-and-cache-keys",level:3},{value:"Creating Posts with Mutations",id:"creating-posts-with-mutations",level:2},{value:"Adding the New Post Mutation Endpoint",id:"adding-the-new-post-mutation-endpoint",level:3},{value:"Using Mutation Hooks in Components",id:"using-mutation-hooks-in-components",level:3},{value:"Refreshing Cached Data",id:"refreshing-cached-data",level:2},{value:"Refetching Posts Manually",id:"refetching-posts-manually",level:3},{value:"Automatic Refreshing with Cache Invalidation",id:"automatic-refreshing-with-cache-invalidation",level:3},{value:"What You&#39;ve Learned",id:"what-youve-learned",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function c(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.admonition,{title:"What You'll Learn",type:"tip",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"How RTK Query simplifies data fetching for Redux apps"}),"\n",(0,i.jsx)(t.li,{children:"How to set up RTK Query"}),"\n",(0,i.jsx)(t.li,{children:"How to use RTK Query for basic data fetching and update requests"}),"\n"]})}),"\n",(0,i.jsx)(t.admonition,{title:"Prerequisites",type:"info",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Completion of the previous sections of this tutorial to understand Redux Toolkit usage patterns"}),"\n"]})}),"\n",(0,i.jsxs)(t.admonition,{title:"Prefer a video course?",type:"tip",children:[(0,i.jsxs)(t.p,{children:["If you prefer a video course, you can ",(0,i.jsx)(t.a,{href:"https://egghead.io/courses/rtk-query-basics-query-endpoints-data-flow-and-typescript-57ea3c43?af=7pnhj6",children:"watch this RTK Query video course by Lenz Weber-Tronic, the creator of RTK Query, for free at Egghead"})," or take a look at the first lesson right here:"]}),(0,i.jsx)("div",{style:{position:"relative",paddingTop:"56.25%"},children:(0,i.jsx)("iframe",{src:"https://app.egghead.io/lessons/redux-course-introduction-and-application-walk-through-for-rtk-query-basics/embed?af=7pnhj6",title:"RTK Query Video course at Egghead: Course Introduction and Application Walk through for RTK Query Basics",frameborder:"0",allowfullscreen:!0,style:{position:"absolute",top:0,left:0,width:"100%",height:"100%"}})})]}),"\n",(0,i.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(t.p,{children:["in ",(0,i.jsx)(t.a,{href:"/tutorials/essentials/part-5-async-logic",children:"Part 5: Async Logic and Data Fetching"})," and ",(0,i.jsx)(t.a,{href:"/tutorials/essentials/part-6-performance-normalization",children:"Part 6: Performance and Normalization"}),", we saw the standard patterns used for data fetching and caching with Redux. Those patterns include using async thunks to fetch data, dispatching actions with the results, managing request loading state in the store, and normalizing the cached data to enable easier lookups and updates of individual items by ID."]}),"\n",(0,i.jsx)(t.p,{children:"In this section, we'll look at how to use RTK Query, a data fetching and caching solution designed for Redux applications, and see how it simplifies the process of fetching data and using it in our components."}),"\n",(0,i.jsx)(t.h2,{id:"rtk-query-overview",children:"RTK Query Overview"}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"RTK Query"})," is a powerful data fetching and caching tool. It is designed to simplify common cases for loading data in a web application, ",(0,i.jsx)(t.strong,{children:"eliminating the need to hand-write data fetching & caching logic yourself"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["RTK Query is ",(0,i.jsx)(t.strong,{children:"included in the Redux Toolkit package"}),", and its functionality is built on top of the other APIs in Redux Toolkit. ",(0,i.jsx)(t.strong,{children:"We recommend RTK Query as the default approach for data fetching in Redux apps"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"motivation",children:"Motivation"}),"\n",(0,i.jsx)(t.p,{children:"Web applications normally need to fetch data from a server in order to display it. They also usually need to make updates to that data, send those updates to the server, and keep the cached data on the client in sync with the data on the server. This is made more complicated by the need to implement other behaviors used in today's applications:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Tracking loading state in order to show UI spinners"}),"\n",(0,i.jsx)(t.li,{children:"Avoiding duplicate requests for the same data"}),"\n",(0,i.jsx)(t.li,{children:"Optimistic updates to make the UI feel faster"}),"\n",(0,i.jsx)(t.li,{children:"Managing cache lifetimes as the user interacts with the UI"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"We've already seen how we can implement these behaviors using Redux Toolkit."}),"\n",(0,i.jsxs)(t.p,{children:["However, originally Redux didn't include anything built in to help ",(0,i.jsx)(t.em,{children:"completely"})," solve these use cases. Even when we use ",(0,i.jsx)(t.code,{children:"createAsyncThunk"})," together with ",(0,i.jsx)(t.code,{children:"createSlice"}),", there's still a fair amount of manual work involved in making requests and managing loading state. We have to create the async thunk, make the actual request, pull relevant fields out of the response, add loading state fields, add handlers in ",(0,i.jsx)(t.code,{children:"extraReducers"})," to handle the ",(0,i.jsx)(t.code,{children:"pending/fulfilled/rejected"})," cases, and actually write the proper state updates."]}),"\n",(0,i.jsxs)(t.p,{children:["Over time, the React community has come to realize that ",(0,i.jsx)(t.strong,{children:'"data fetching and caching" is really a different set of concerns than "state management"'}),". While you can use a state management library like Redux to cache data, the use cases are different enough that it's worth using tools that are purpose-built for the data fetching use case."]}),"\n",(0,i.jsx)(t.h4,{id:"server-state-challenges",children:"Server State Challenges"}),"\n",(0,i.jsxs)(t.p,{children:["It's worth quoting the great explanation from ",(0,i.jsx)(t.a,{href:"https://tanstack.com/query/latest/docs/framework/react/overview",children:'the React Query "Motivation" docs page'}),":"]}),"\n",(0,i.jsxs)(t.blockquote,{children:["\n",(0,i.jsx)(t.p,{children:"While most traditional state management libraries are great for working with client state, they are not so great at working with async or server state. This is because server state is totally different. For starters, server state:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Is persisted remotely in a location you may not control or own"}),"\n",(0,i.jsx)(t.li,{children:"Requires asynchronous APIs for fetching and updating"}),"\n",(0,i.jsx)(t.li,{children:"Implies shared ownership and can be changed by other people without your knowledge"}),"\n",(0,i.jsx)(t.li,{children:'Can potentially become "out of date" in your applications if you\'re not careful'}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Once you grasp the nature of server state in your application, even more challenges will arise as you go, for example:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Caching... (possibly the hardest thing to do in programming)"}),"\n",(0,i.jsx)(t.li,{children:"Deduping multiple requests for the same data into a single request"}),"\n",(0,i.jsx)(t.li,{children:'Updating "out of date" data in the background'}),"\n",(0,i.jsx)(t.li,{children:'Knowing when data is "out of date"'}),"\n",(0,i.jsx)(t.li,{children:"Reflecting updates to data as quickly as possible"}),"\n",(0,i.jsx)(t.li,{children:"Performance optimizations like pagination and lazy loading data"}),"\n",(0,i.jsx)(t.li,{children:"Managing memory and garbage collection of server state"}),"\n",(0,i.jsx)(t.li,{children:"Memoizing query results with structural sharing"}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"rtk-query-differences",children:"RTK Query Differences"}),"\n",(0,i.jsx)(t.p,{children:"RTK Query takes inspiration from other tools that have pioneered solutions for data fetching, like Apollo Client, React Query, Urql, and SWR, but adds a unique approach to its API design:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The data fetching and caching logic is built on top of Redux Toolkit's ",(0,i.jsx)(t.code,{children:"createSlice"})," and ",(0,i.jsx)(t.code,{children:"createAsyncThunk"})," APIs"]}),"\n",(0,i.jsx)(t.li,{children:"Because Redux Toolkit is UI-agnostic, RTK Query's functionality can be used with any UI layer like Angular, Vue, or vanilla JS, not just with React"}),"\n",(0,i.jsx)(t.li,{children:"API endpoints are defined ahead of time, including how to generate query parameters from arguments and transform responses for caching"}),"\n",(0,i.jsxs)(t.li,{children:["RTK Query can also generate React hooks that encapsulate the entire data fetching process, provide ",(0,i.jsx)(t.code,{children:"data"})," and ",(0,i.jsx)(t.code,{children:"isFetching"})," fields to components, and manage the lifetime of cached data as components mount and unmount"]}),"\n",(0,i.jsx)(t.li,{children:'RTK Query provides "cache entry lifecycle" options that enable use cases like streaming cache updates via websocket messages after fetching the initial data'}),"\n",(0,i.jsx)(t.li,{children:"We have a code generator to generate RTK Query API definitions from OpenAPI schemas"}),"\n",(0,i.jsx)(t.li,{children:"Finally, RTK Query is completely written in TypeScript, and is designed to provide an excellent TS usage experience"}),"\n"]}),"\n",(0,i.jsx)(t.h3,{id:"whats-included",children:"What's included"}),"\n",(0,i.jsx)(t.h4,{id:"apis",children:"APIs"}),"\n",(0,i.jsx)(t.p,{children:"RTK Query is included within the installation of the core Redux Toolkit package. It is available via either of the two entry points below:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:"no-transpile",children:"// UI-agnostic entry point with the core logic\nimport { createApi } from '@reduxjs/toolkit/query'\n\n// React-specific entry point that automatically generates\n// hooks corresponding to the defined endpoints\nimport { createApi } from '@reduxjs/toolkit/query/react'\n"})}),"\n",(0,i.jsx)(t.p,{children:"RTK Query primarily consists of two APIs:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/rtk-query/api/createApi",children:(0,i.jsx)(t.code,{children:"createApi()"})}),': The core of RTK Query\'s functionality. It allows you to define a set of endpoints describe how to retrieve data from a series of endpoints, including configuration of how to fetch and transform that data. In most cases, you should use this once per app, with "one API slice per base URL" as a rule of thumb.']}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/rtk-query/api/fetchBaseQuery",children:(0,i.jsx)(t.code,{children:"fetchBaseQuery()"})}),": A small wrapper around ",(0,i.jsx)(t.a,{href:"https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",children:(0,i.jsx)(t.code,{children:"fetch"})})," that aims to simplify HTTP requests. RTK Query can be used to cache the result of ",(0,i.jsx)(t.em,{children:"any"})," async request, but since HTTP requests are the most common use case, ",(0,i.jsx)(t.code,{children:"fetchBaseQuery"})," provides HTTP support out of the box."]}),"\n"]}),"\n",(0,i.jsx)(t.h4,{id:"bundle-size",children:"Bundle Size"}),"\n",(0,i.jsx)(t.p,{children:"RTK Query adds a fixed one-time amount to your app's bundle size. Since RTK Query builds on top of Redux Toolkit and React-Redux, the added size varies depending on whether you are already using those in your app. The estimated min+gzip bundle sizes are:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"If you are using RTK already: ~9kb for RTK Query and ~2kb for the hooks."}),"\n",(0,i.jsxs)(t.li,{children:["If you are not using RTK already:","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"Without React: 17 kB for RTK+dependencies+RTK Query"}),"\n",(0,i.jsx)(t.li,{children:"With React: 19kB + React-Redux, which is a peer dependency"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["Adding additional endpoint definitions should only increase size based on the actual code inside the ",(0,i.jsx)(t.code,{children:"endpoints"})," definitions, which will typically be just a few bytes."]}),"\n",(0,i.jsx)(t.p,{children:"The functionality included in RTK Query quickly pays for the added bundle size, and the elimination of hand-written data fetching logic should be a net improvement in size for most meaningful applications."}),"\n",(0,i.jsx)(t.h3,{id:"thinking-in-rtk-query-caching",children:"Thinking in RTK Query Caching"}),"\n",(0,i.jsxs)(t.p,{children:["Redux has always had an emphasis on predictability and explicit behavior. There's no \"magic\" involved in Redux - you should be able to understand what's happening in the application because ",(0,i.jsx)(t.strong,{children:"all Redux logic follows the same basic patterns of dispatching actions and updating state via reducers"}),". This does mean that sometimes you have to write more code to make things happen, but the tradeoff is that should be very clear what the data flow and behavior is."]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"The Redux Toolkit core APIs do not change any of the basic data flow in a Redux app"})," You're still dispatching actions and writing reducers, just with less code than writing all of that logic by hand. ",(0,i.jsx)(t.strong,{children:"RTK Query is the same way"}),". It's an additional level of abstraction, but ",(0,i.jsx)(t.strong,{children:"internally it's still doing the exact same steps we've already seen for managing async requests and their responses"})," - using thunks to run async requests, dispatching actions with the results, and handling the actions in reducers to cache the data."]}),"\n",(0,i.jsxs)(t.p,{children:["However, when you use RTK Query, there ",(0,i.jsx)(t.em,{children:"is"}),' a mindset shift that happens. We\'re no longer thinking about "managing state" per se. Instead, ',(0,i.jsxs)(t.strong,{children:['we now think about "managing ',(0,i.jsx)(t.em,{children:"cached data"}),'"']}),". Rather than trying to write reducers ourselves, we're now going to focus on defining ",(0,i.jsx)(t.strong,{children:'"where is this data coming from?", "how should this update be sent?", "when should this cached data be re-fetched?", and "how should the cached data be updated?"'}),". How that data gets fetched, stored, and retrieved becomes implementation details we no longer have to worry about."]}),"\n",(0,i.jsx)(t.p,{children:"We'll see how this mindset shift applies as we continue."}),"\n",(0,i.jsx)(t.h2,{id:"setting-up-rtk-query",children:"Setting Up RTK Query"}),"\n",(0,i.jsxs)(t.p,{children:["Our example application already works, but now it's time to migrate all of the async logic over to use RTK Query. As we go through, we'll see how to use all the major features of RTK Query, as well as how to migrate existing uses of ",(0,i.jsx)(t.code,{children:"createAsyncThunk"})," and ",(0,i.jsx)(t.code,{children:"createSlice"})," over to use the RTK Query APIs."]}),"\n",(0,i.jsx)(t.h3,{id:"defining-an-api-slice",children:"Defining an API Slice"}),"\n",(0,i.jsx)(t.p,{children:'Previously, we\'ve defined separate "slices" for each of our different data types like Posts, Users, and Notifications. Each slice had its own reducer, defined its own actions and thunks, and cached the entries for that data type separately.'}),"\n",(0,i.jsxs)(t.p,{children:["With RTK Query, ",(0,i.jsx)(t.strong,{children:'the logic for managing cached data is centralized into a single "API slice" per application'}),". In much the same way that you have a single Redux store per app, we now have a single slice for ",(0,i.jsx)(t.em,{children:"all"})," our cached data."]}),"\n",(0,i.jsxs)(t.p,{children:["We'll start by defining a new ",(0,i.jsx)(t.code,{children:"apiSlice.ts"})," file. Since this isn't specific to any of the other \"features\" we've already written, we'll add a new ",(0,i.jsx)(t.code,{children:"features/api/"})," folder and put ",(0,i.jsx)(t.code,{children:"apiSlice.ts"})," in there. Let's fill out the API slice file, and then break down the code inside to see what it's doing:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/api/apiSlice.ts"',children:"// Import the RTK Query methods from the React-specific entry point\nimport { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\n// Use the `Post` type we've already defined in `postsSlice`,\n// and then re-export it for ease of use\nimport type { Post } from '@/features/posts/postsSlice'\nexport type { Post }\n\n// Define our single API slice object\nexport const apiSlice = createApi({\n  // The cache reducer expects to be added at `state.api` (already default - this is optional)\n  reducerPath: 'api',\n  // All of our requests will have URLs starting with '/fakeApi'\n  baseQuery: fetchBaseQuery({ baseUrl: '/fakeApi' }),\n  // The \"endpoints\" represent operations and requests for this server\n  endpoints: builder => ({\n    // The `getPosts` endpoint is a \"query\" operation that returns data.\n    // The return value is a `Post[]` array, and it takes no arguments.\n    getPosts: builder.query<Post[], void>({\n      // The URL for the request is '/fakeApi/posts'\n      query: () => '/posts'\n    })\n  })\n})\n\n// Export the auto-generated hook for the `getPosts` query endpoint\nexport const { useGetPostsQuery } = apiSlice\n"})}),"\n",(0,i.jsxs)(t.p,{children:["RTK Query's functionality is based on a single method, called ",(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/rtk-query/api/createApi",children:(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.code,{children:"createApi"})})}),". All of the Redux Toolkit APIs we've seen so far are UI-agnostic, and could be used with ",(0,i.jsx)(t.em,{children:"any"})," UI layer. The RTK Query core logic is the same way. However, RTK Query also includes a React-specific version of ",(0,i.jsx)(t.code,{children:"createApi"}),", and since we're using RTK and React together, we need to use that to take advantage of RTK's React integration. So, we import from ",(0,i.jsx)(t.code,{children:"'@reduxjs/toolkit/query/react'"})," specifically."]}),"\n",(0,i.jsxs)(t.admonition,{type:"tip",children:[(0,i.jsxs)(t.p,{children:[(0,i.jsxs)(t.strong,{children:["Your application is expected to have only one ",(0,i.jsx)(t.code,{children:"createApi"})," call in it"]}),". This one API slice should contain ",(0,i.jsx)(t.em,{children:"all"})," endpoint definitions that talk to the same base URL. For example, endpoints ",(0,i.jsx)(t.code,{children:"/api/posts"})," and ",(0,i.jsx)(t.code,{children:"/api/users"})," are both fetching data from the same server, so they would go in the same API slice. If your app does fetch data from multiple servers, you can either specify full URLs in each endpoint, or if absolutely necessary create separate API slices for each server."]}),(0,i.jsxs)(t.p,{children:["Endpoints are normally defined directly inside the ",(0,i.jsx)(t.code,{children:"createApi"})," call. If you're looking to split up your endpoints between multiple files, see ",(0,i.jsx)(t.a,{href:"/tutorials/essentials/part-8-rtk-query-advanced#injecting-endpoints",children:'the "Injecting Endpoints" section in Part 8'})," section of the docs!"]})]}),"\n",(0,i.jsx)(t.h4,{id:"api-slice-parameters",children:"API Slice Parameters"}),"\n",(0,i.jsxs)(t.p,{children:["When we call ",(0,i.jsx)(t.code,{children:"createApi"}),", there are two fields that are required:"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"baseQuery"}),": a function that knows how to fetch data from the server. RTK Query includes ",(0,i.jsx)(t.code,{children:"fetchBaseQuery"}),", a small wrapper around the standard ",(0,i.jsx)(t.code,{children:"fetch()"})," function that handles typical processing of HTTP requests and responses. When we create a ",(0,i.jsx)(t.code,{children:"fetchBaseQuery"})," instance, we can pass in the base URL of all future requests, as well as override behavior such as modifying request headers. You can ",(0,i.jsx)(t.a,{href:"https://redux-toolkit.js.org/rtk-query/usage/customizing-queries#customizing-queries-with-basequery",children:"create custom base queries"})," to customize behavior like error handling and auth."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"endpoints"}),": a set of operations that we've defined for interacting with this server. Endpoints can be ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.em,{children:"queries"})}),", which return data for caching, or ",(0,i.jsx)(t.strong,{children:(0,i.jsx)(t.em,{children:"mutations"})}),", which send an update to the server. The endpoints are defined using a callback function that accepts a ",(0,i.jsx)(t.code,{children:"builder"})," parameter and returns an object containing endpoint definitions created with ",(0,i.jsx)(t.code,{children:"builder.query()"})," and ",(0,i.jsx)(t.code,{children:"builder.mutation()"}),"."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.code,{children:"createApi"})," also accepts a ",(0,i.jsx)(t.code,{children:"reducerPath"})," field, which defines the expected top-level state slice field for the generated reducer. For our other slices like ",(0,i.jsx)(t.code,{children:"postsSlice"}),", there's no guarantee that it will be used to update ",(0,i.jsx)(t.code,{children:"state.posts"})," - we ",(0,i.jsx)(t.em,{children:"could"})," have attached the reducer anywhere in the root state, like ",(0,i.jsx)(t.code,{children:"someOtherField: postsReducer"}),". Here, ",(0,i.jsx)(t.code,{children:"createApi"})," expects us to tell it where the cache state will exist when we add the cache reducer to the store. If you don't provide a ",(0,i.jsx)(t.code,{children:"reducerPath"})," option, it defaults to ",(0,i.jsx)(t.code,{children:"'api'"}),", so all your RTKQ cache data will be stored under ",(0,i.jsx)(t.code,{children:"state.api"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["If you forget to add the reducer to the store, or attach it at a different key than what is specified in ",(0,i.jsx)(t.code,{children:"reducerPath"}),", RTKQ will log an error to let you know this needs to be fixed."]}),"\n",(0,i.jsx)(t.h4,{id:"defining-endpoints",children:"Defining Endpoints"}),"\n",(0,i.jsxs)(t.p,{children:["The first part of the URL for all requests is defined as ",(0,i.jsx)(t.code,{children:"'/fakeApi'"})," in the ",(0,i.jsx)(t.code,{children:"fetchBaseQuery"})," definition."]}),"\n",(0,i.jsxs)(t.p,{children:["For our first step, we want to add an endpoint that will return the entire list of posts from the fake API server. We'll include an endpoint called ",(0,i.jsx)(t.code,{children:"getPosts"}),", and define it as a ",(0,i.jsx)(t.strong,{children:"query endpoint"})," using ",(0,i.jsx)(t.code,{children:"builder.query()"}),". This method accepts many options for configuring how to make the request and process the response. For now, all we need to do is supply the remaining piece of the URL path by defining a ",(0,i.jsx)(t.code,{children:"query"})," option, with a callback that returns the URL string: ",(0,i.jsx)(t.code,{children:"() => '/posts'"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["By default, query endpoints will use a ",(0,i.jsx)(t.code,{children:"GET"})," HTTP request, but you can override that by returning an object like ",(0,i.jsx)(t.code,{children:"{url: '/posts', method: 'POST', body: newPost}"})," instead of just the URL string itself. You can also define several other options for the request this way, such as setting headers."]}),"\n",(0,i.jsxs)(t.p,{children:["For TypeScript usage, ",(0,i.jsxs)(t.strong,{children:["the ",(0,i.jsx)(t.code,{children:"builder.query()"})," and ",(0,i.jsx)(t.code,{children:"builder.mutation()"})," endpoint definition functions accept two generic arguments: ",(0,i.jsx)(t.code,{children:"<ReturnType, ArgumentType>"})]}),". For example, an endpoint to fetch a Pokemon by name might look like ",(0,i.jsx)(t.code,{children:"getPokemonByName: builder.query<Pokemon, string>()"}),". ",(0,i.jsxs)(t.strong,{children:["If a given endpoint takes ",(0,i.jsx)(t.em,{children:"no"})," arguments, use the ",(0,i.jsx)(t.code,{children:"void"})," type, like ",(0,i.jsx)(t.code,{children:"getAllPokemon: builder.query<Pokemon[], void>()"})]}),"."]}),"\n",(0,i.jsx)(t.h4,{id:"exporting-api-slices-and-hooks",children:"Exporting API Slices and Hooks"}),"\n",(0,i.jsx)(t.p,{children:'In our earlier slice files, we just exported the action creators and the slice reducers, because those are all that\'s needed in other files. With RTK Query, we typically export the entire "API slice" object itself, because it has several fields that may be useful.'}),"\n",(0,i.jsxs)(t.p,{children:["Finally, look carefully at the last line of this file. Where's this ",(0,i.jsx)(t.code,{children:"useGetPostsQuery"})," value coming from?"]}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsxs)(t.strong,{children:["RTK Query's React integration will automatically generate React hooks for ",(0,i.jsx)(t.em,{children:"every"})," endpoint we define!"]})," Those hooks encapsulate the process of triggering a request when a component mounts, and re-rendering the component as the request is processed and data is available. We can export those hooks out of this API slice file for use in our React components."]}),"\n",(0,i.jsx)(t.p,{children:"The hooks are automatically named based on a standard convention:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"use"}),", the normal prefix for any React hook"]}),"\n",(0,i.jsx)(t.li,{children:"The name of the endpoint, capitalized"}),"\n",(0,i.jsxs)(t.li,{children:["The type of the endpoint, ",(0,i.jsx)(t.code,{children:"Query"})," or ",(0,i.jsx)(t.code,{children:"Mutation"})]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["In this case, our endpoint is ",(0,i.jsx)(t.code,{children:"getPosts"})," and it's a query endpoint, so the generated hook is ",(0,i.jsx)(t.code,{children:"useGetPostsQuery"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"configuring-the-store",children:"Configuring the Store"}),"\n",(0,i.jsxs)(t.p,{children:["We now need to hook up the API slice to our Redux store. We can modify the existing ",(0,i.jsx)(t.code,{children:"store.ts"})," file to add the API slice's cache reducer to the state. Also, the API slice generates a custom middleware that needs to be added to the store. This middleware ",(0,i.jsx)(t.em,{children:"must"})," be added as well - it manages cache lifetimes and expiration."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="app/store.ts"',children:"import { configureStore } from '@reduxjs/toolkit'\n\n// highlight-next-line\nimport { apiSlice } from '@/features/api/apiSlice'\nimport authReducer from '@/features/auth/authSlice'\nimport postsReducer from '@/features/posts/postsSlice'\nimport usersReducer from '@/features/users/usersSlice'\nimport notificationsReducer from '@/features/notifications/notificationsSlice'\n\nimport { listenerMiddleware } from './listenerMiddleware'\n\nexport const store = configureStore({\n  // Pass in the root reducer setup as the `reducer` argument\n  reducer: {\n    auth: authReducer,\n    posts: postsReducer,\n    users: usersReducer,\n    notifications: notificationsReducer,\n    // highlight-next-line\n    [apiSlice.reducerPath]: apiSlice.reducer\n  },\n  middleware: getDefaultMiddleware =>\n    // highlight-start\n    getDefaultMiddleware()\n      .prepend(listenerMiddleware.middleware)\n      .concat(apiSlice.middleware)\n  // highlight-end\n})\n"})}),"\n",(0,i.jsxs)(t.p,{children:["We can reuse the ",(0,i.jsx)(t.code,{children:"apiSlice.reducerPath"})," field as a computed key in the ",(0,i.jsx)(t.code,{children:"reducer"})," parameter, to ensure that the caching reducer is added in the right place."]}),"\n",(0,i.jsxs)(t.p,{children:["As we saw when we ",(0,i.jsx)(t.a,{href:"/tutorials/essentials/part-6-performance-normalization#setting-up-the-listener-middleware",children:"added the listener middleware"}),", we need to keep all of the existing standard middleware like ",(0,i.jsx)(t.code,{children:"redux-thunk"})," in the store setup, and the API slice's middleware typically goes after those. We're already calling ",(0,i.jsx)(t.code,{children:"getDefaultMiddleware()"})," and putting the listener middleware at the front, so we can call ",(0,i.jsx)(t.code,{children:".concat(apiSlice.middleware)"})," to add this at the end."]}),"\n",(0,i.jsx)(t.h2,{id:"displaying-posts-with-queries",children:"Displaying Posts with Queries"}),"\n",(0,i.jsx)(t.h3,{id:"using-query-hooks-in-components",children:"Using Query Hooks in Components"}),"\n",(0,i.jsxs)(t.p,{children:["Now that we have the API slice defined and added to the store, we can import the generated ",(0,i.jsx)(t.code,{children:"useGetPostsQuery"})," hook into our ",(0,i.jsx)(t.code,{children:"<PostsList>"})," component and use it there."]}),"\n",(0,i.jsxs)(t.p,{children:["Currently, ",(0,i.jsx)(t.code,{children:"<PostsList>"})," is specifically importing ",(0,i.jsx)(t.code,{children:"useSelector"}),", ",(0,i.jsx)(t.code,{children:"useDispatch"}),", and ",(0,i.jsx)(t.code,{children:"useEffect"}),", reading posts data and loading state from the store, and dispatching the ",(0,i.jsx)(t.code,{children:"fetchPosts()"})," thunk on mount to trigger the data fetch. ",(0,i.jsxs)(t.strong,{children:["The ",(0,i.jsx)(t.code,{children:"useGetPostsQueryHook"})," replaces all of that!"]})]}),"\n",(0,i.jsxs)(t.p,{children:["Let's see how ",(0,i.jsx)(t.code,{children:"<PostsList>"})," looks when we use this hook:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/posts/PostsList.tsx"',children:"import React from 'react'\nimport { Link } from 'react-router-dom'\n\nimport { Spinner } from '@/components/Spinner'\nimport { TimeAgo } from '@/components/TimeAgo'\n\n// highlight-next-line\nimport { useGetPostsQuery, Post } from '@/features/api/apiSlice'\n\nimport { PostAuthor } from './PostAuthor'\nimport { ReactionButtons } from './ReactionButtons'\n\n// highlight-start\n// Go back to passing a `post` object as a prop\ninterface PostExcerptProps {\n  post: Post\n}\n\nfunction PostExcerpt({ post }: PostExcerptProps) {\n  // highlight-end\n  return (\n    <article className=\"post-excerpt\" key={post.id}>\n      <h3>\n        <Link to={`/posts/${post.id}`}>{post.title}</Link>\n      </h3>\n      <div>\n        <PostAuthor userId={post.user} />\n        <TimeAgo timestamp={post.date} />\n      </div>\n      <p className=\"post-content\">{post.content.substring(0, 100)}</p>\n      <ReactionButtons post={post} />\n    </article>\n  )\n}\n\nexport const PostsList = () => {\n  // highlight-start\n  // Calling the `useGetPostsQuery()` hook automatically fetches data!\n  const {\n    data: posts = [],\n    isLoading,\n    isSuccess,\n    isError,\n    error\n  } = useGetPostsQuery()\n  // highlight-end\n\n  let content: React.ReactNode\n\n  // highlight-start\n  // Show loading states based on the hook status flags\n  if (isLoading) {\n    content = <Spinner text=\"Loading...\" />\n  } else if (isSuccess) {\n    content = posts.map(post => <PostExcerpt key={post.id} post={post} />)\n  } else if (isError) {\n    content = <div>{error.toString()}</div>\n  }\n  // highlight-end\n\n  return (\n    <section className=\"posts-list\">\n      <h2>Posts</h2>\n      {content}\n    </section>\n  )\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Conceptually, ",(0,i.jsx)(t.code,{children:"<PostsList>"})," is still doing all the same work it was before, but ",(0,i.jsxs)(t.strong,{children:["we were able to replace the multiple ",(0,i.jsx)(t.code,{children:"useSelector"})," calls and the ",(0,i.jsx)(t.code,{children:"useEffect"})," dispatch with a single call to ",(0,i.jsx)(t.code,{children:"useGetPostsQuery()"})]}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["(Note that at this point, the application will have some mismatches between code that is still looking at the existing ",(0,i.jsx)(t.code,{children:"state.posts"})," slice for data, vs the new code that is reading from RTK Query. This is expected, and we'll fix these mismatches one at a time as we go forward.)"]}),"\n",(0,i.jsxs)(t.p,{children:["Previously, we were selecting a list of post IDs from the store, passing a post ID to each ",(0,i.jsx)(t.code,{children:"<PostExcerpt>"})," component, and selecting each individual ",(0,i.jsx)(t.code,{children:"Post"})," object from the store separately. Since the ",(0,i.jsx)(t.code,{children:"posts"})," array already has all of the post objects, we've switched back to passing the post objects themselves down as props."]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["You should normally use the query hooks to access cached data in components - you ",(0,i.jsx)(t.em,{children:"shouldn't"})," write your own ",(0,i.jsx)(t.code,{children:"useSelector"})," calls to access fetched data or ",(0,i.jsx)(t.code,{children:"useEffect"})," calls to trigger fetching!"]})}),"\n",(0,i.jsx)(t.h3,{id:"query-hook-result-objects",children:"Query Hook Result Objects"}),"\n",(0,i.jsx)(t.p,{children:'Each generated query hook returns a "result" object containing several fields, including:'}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"data"}),": the actual response contents from the server for the most recent ",(0,i.jsx)(t.em,{children:"successful"})," cache entry data. ",(0,i.jsxs)(t.strong,{children:["This field will be ",(0,i.jsx)(t.code,{children:"undefined"})," until the response is received"]}),"."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"currentData"}),": The response contents for the ",(0,i.jsx)(t.em,{children:"current"})," query arguments. This can switch to ",(0,i.jsx)(t.code,{children:"undefined"})," if the query arguments are changed and a request starts because there isn't an existing cache entry."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"isLoading"}),": a boolean indicating if this hook is currently making the ",(0,i.jsx)(t.em,{children:"first"})," request to the server because there isn't any data yet. (Note that if the parameters change to request different data, ",(0,i.jsx)(t.code,{children:"isLoading"})," will remain false.)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"isFetching"}),": a boolean indicating if the hook is currently making ",(0,i.jsx)(t.em,{children:"any"})," request to the server"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"isSuccess"}),": a boolean indicating if the hook has made a successful request and has cached data available (ie, ",(0,i.jsx)(t.code,{children:"data"})," should be defined now)"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"isError"}),": a boolean indicating if the last request had an error"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.code,{children:"error"}),": a serialized error object"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["It's common to destructure fields from the result object, and possibly rename ",(0,i.jsx)(t.code,{children:"data"})," to a more specific variable like ",(0,i.jsx)(t.code,{children:"posts"})," to describe what it contains. We can then use the status booleans and the ",(0,i.jsx)(t.code,{children:"data/error"})," fields to render the UI that we want. However, if you're using an older version of TypeScript, you may need to keep the original object as-is and refer to flags as ",(0,i.jsx)(t.code,{children:"result.isSuccess"})," in your conditional checks, so that TS can correctly infer that ",(0,i.jsx)(t.code,{children:"data"})," is valid."]}),"\n",(0,i.jsx)(t.h4,{id:"loading-state-fields",children:"Loading State Fields"}),"\n",(0,i.jsxs)(t.p,{children:["Note that ",(0,i.jsxs)(t.a,{href:"https://redux-toolkit.js.org/rtk-query/usage/queries#query-loading-state",children:[(0,i.jsx)(t.code,{children:"isLoading"})," and ",(0,i.jsx)(t.code,{children:"isFetching"})," are different flags with different behavior"]}),". You can decide which one to use based on when and how you need to show loading states in the UI. For example, you might want to check ",(0,i.jsx)(t.code,{children:"isLoading"})," if you want to show a skeleton while loading a page for the first time, or you might choose to check ",(0,i.jsx)(t.code,{children:"isFetching"})," to show a spinner or gray out existing results every time there's any request happening as the user selects different items."]}),"\n",(0,i.jsxs)(t.p,{children:["Similarly, ",(0,i.jsx)(t.code,{children:"data"})," and ",(0,i.jsx)(t.code,{children:"currentData"})," will change at different times. Most of the time, you should use the values in ",(0,i.jsx)(t.code,{children:"data"}),", but ",(0,i.jsx)(t.code,{children:"currentData"})," is available to give you more granularity for loading behavior. For example, if you wanted to show data in the UI as translucent to represent a re-fetching state, you can use ",(0,i.jsx)(t.code,{children:"data"})," in combination with ",(0,i.jsx)(t.code,{children:"isFetching"})," to achieve this, because ",(0,i.jsx)(t.code,{children:"data"})," will stay the same until the new request has completed. However, if you also wish to only show values corresponding to the current arg (such as clearing out the UI until the new request is done), you can instead use ",(0,i.jsx)(t.code,{children:"currentData"})," to achieve this."]}),"\n",(0,i.jsx)(t.h3,{id:"sorting-posts",children:"Sorting Posts"}),"\n",(0,i.jsxs)(t.p,{children:["Unfortunately, the posts are now being displayed out of order. Previously, we were sorting them by date at the reducer level with ",(0,i.jsx)(t.code,{children:"createEntityAdapter"}),"'s sorting option. Since the API slice is just caching the exact array returned from the server, there's no specific sorting happening - whatever order the server sent back is what we've got."]}),"\n",(0,i.jsxs)(t.p,{children:["There's a few different options for how to handle this. For now, we'll do the sorting inside of ",(0,i.jsx)(t.code,{children:"<PostsList>"})," itself, and we'll talk about the other options and their tradeoffs later."]}),"\n",(0,i.jsxs)(t.p,{children:["We can't just call ",(0,i.jsx)(t.code,{children:"posts.sort()"})," directly, because ",(0,i.jsx)(t.code,{children:"Array.sort()"})," mutates the existing array, so we'll need to make a copy of it first. To avoid re-sorting on every rerender, we can do the sorting in a ",(0,i.jsx)(t.code,{children:"useMemo()"})," hook. We'll also want to give ",(0,i.jsx)(t.code,{children:"posts"})," a default empty array in case it's ",(0,i.jsx)(t.code,{children:"undefined"}),", so that we always have an array to sort on."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/posts/PostsList.tsx"',children:'// omit setup\n\nexport const PostsList = () => {\n  const {\n    // highlight-next-line\n    data: posts = [],\n    isLoading,\n    isSuccess,\n    isError,\n    error\n  } = useGetPostsQuery()\n\n  // highlight-start\n  const sortedPosts = useMemo(() => {\n    const sortedPosts = posts.slice()\n    // Sort posts in descending chronological order\n    sortedPosts.sort((a, b) => b.date.localeCompare(a.date))\n    return sortedPosts\n  }, [posts])\n  // highlight-end\n\n  let content\n\n  if (isLoading) {\n    content = <Spinner text="Loading..." />\n  } else if (isSuccess) {\n    // highlight-next-line\n    content = sortedPosts.map(post => <PostExcerpt key={post.id} post={post} />)\n  } else if (isError) {\n    content = <div>{error.toString()}</div>\n  }\n\n  // omit rendering\n}\n'})}),"\n",(0,i.jsx)(t.h2,{id:"displaying-individual-posts",children:"Displaying Individual Posts"}),"\n",(0,i.jsxs)(t.p,{children:["We've updated ",(0,i.jsx)(t.code,{children:"<PostsList>"})," to fetch a list of ",(0,i.jsx)(t.em,{children:"all"})," posts, and we're showing pieces of each ",(0,i.jsx)(t.code,{children:"Post"}),' inside the list. But, if we click on "View Post" for any of them, our ',(0,i.jsx)(t.code,{children:"<SinglePostPage>"})," component will fail to find a post in the old ",(0,i.jsx)(t.code,{children:"state.posts"}),' slice and show us a "Post not found!" error. We need to update ',(0,i.jsx)(t.code,{children:"<SinglePostPage>"})," to use RTK Query as well."]}),"\n",(0,i.jsxs)(t.p,{children:["There's a couple ways we could do this. One would be to have ",(0,i.jsx)(t.code,{children:"<SinglePostPage>"})," call the same ",(0,i.jsx)(t.code,{children:"useGetPostsQuery()"})," hook, get the ",(0,i.jsx)(t.em,{children:"entire"})," array of posts, and find just the one ",(0,i.jsx)(t.code,{children:"Post"})," object it needs to display. Query hooks also have a ",(0,i.jsx)(t.code,{children:"selectFromResult"})," option that would allow us to do that same lookup earlier, inside the hook itself - we'll see this in action later."]}),"\n",(0,i.jsx)(t.p,{children:"Instead, we're going to try adding another endpoint definition that will let us request a single post from the server based on its ID. This is somewhat redundant, but it will allow us to see how RTK Query can be used to customize query requests based on arguments."}),"\n",(0,i.jsx)(t.h3,{id:"adding-the-single-post-query-endpoint",children:"Adding the Single Post Query Endpoint"}),"\n",(0,i.jsxs)(t.p,{children:["In ",(0,i.jsx)(t.code,{children:"apiSlice.ts"}),", we're going to add another query endpoint definition, called ",(0,i.jsx)(t.code,{children:"getPost"})," (no 's' this time):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/api/apiSlice.ts"',children:"export const apiSlice = createApi({\n  reducerPath: 'api',\n  baseQuery: fetchBaseQuery({ baseUrl: '/fakeApi' }),\n  endpoints: builder => ({\n    getPosts: builder.query<Post[], void>({\n      query: () => '/posts'\n    }),\n    // highlight-start\n    getPost: builder.query<Post, string>({\n      query: postId => `/posts/${postId}`\n    })\n    // highlight-end\n  })\n})\n\n// highlight-next-line\nexport const { useGetPostsQuery, useGetPostQuery } = apiSlice\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"getPost"})," endpoint looks much like the existing ",(0,i.jsx)(t.code,{children:"getPosts"})," endpoint, but the ",(0,i.jsx)(t.code,{children:"query"})," parameter is different. Here, ",(0,i.jsx)(t.code,{children:"query"})," takes an argument called ",(0,i.jsx)(t.code,{children:"postId"}),", and we're using that ",(0,i.jsx)(t.code,{children:"postId"})," to construct the server URL. That way we can make a server request for just one specific ",(0,i.jsx)(t.code,{children:"Post"})," object."]}),"\n",(0,i.jsxs)(t.p,{children:["This also generates a new ",(0,i.jsx)(t.code,{children:"useGetPostQuery"})," hook, so we export that as well."]}),"\n",(0,i.jsx)(t.h3,{id:"query-arguments-and-cache-keys",children:"Query Arguments and Cache Keys"}),"\n",(0,i.jsxs)(t.p,{children:["Our ",(0,i.jsx)(t.code,{children:"<SinglePostPage>"})," is currently reading one ",(0,i.jsx)(t.code,{children:"Post"})," entry from ",(0,i.jsx)(t.code,{children:"state.posts"})," based on ID. We need to update it to call the new ",(0,i.jsx)(t.code,{children:"useGetPostQuery"})," hook, and use similar loading state as the main list."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/posts/SinglePostPage.tsx"',children:'// omit some imports\n\n// highlight-next-line\nimport { useGetPostQuery } from \'@/features/api/apiSlice\'\nimport { selectCurrentUsername } from \'@/features/auth/authSlice\'\n\nexport const SinglePostPage = () => {\n  const { postId } = useParams()\n\n  const currentUsername = useAppSelector(selectCurrentUsername)\n  // highlight-next-line\n  const { data: post, isFetching, isSuccess } = useGetPostQuery(postId!)\n\n  let content: React.ReactNode\n\n  const canEdit = currentUsername === post?.user\n\n  // highlight-start\n  if (isFetching) {\n    content = <Spinner text="Loading..." />\n  } else if (isSuccess) {\n    // highlight-end\n    content = (\n      <article className="post">\n        <h2>{post.title}</h2>\n        <div>\n          <PostAuthor userId={post.user} />\n          <TimeAgo timestamp={post.date} />\n        </div>\n        <p className="post-content">{post.content}</p>\n        <ReactionButtons post={post} />\n        {canEdit && (\n          <Link to={`/editPost/${post.id}`} className="button">\n            Edit Post\n          </Link>\n        )}\n      </article>\n    )\n  }\n\n  return <section>{content}</section>\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Notice that we're taking the ",(0,i.jsx)(t.code,{children:"postId"})," we've read from the router match, and passing it as an argument to ",(0,i.jsx)(t.code,{children:"useGetPostQuery"}),". The query hook will then use that to construct the request URL, and fetch this specific ",(0,i.jsx)(t.code,{children:"Post"})," object."]}),"\n",(0,i.jsx)(t.p,{children:"So how is all this data being cached, anyway? Let's click \"View Post\" for one of our post entries, then take a look at what's inside the Redux store at this point."}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"RTK Query data cached in the store state",src:n(4673).A+"",width:"2560",height:"945"})}),"\n",(0,i.jsxs)(t.p,{children:["We can see that we have a top-level ",(0,i.jsx)(t.code,{children:"state.api"})," slice, as expected from the store setup. Inside of there is a section called ",(0,i.jsx)(t.code,{children:"queries"}),", and it currently has two items. The key ",(0,i.jsx)(t.code,{children:"getPosts(undefined)"})," represents the metadata and response contents for the request we made with the ",(0,i.jsx)(t.code,{children:"getPosts"})," endpoint. Similarly, the key ",(0,i.jsx)(t.code,{children:"getPost('abcd1234')"})," is for the specific request we just made for this one post."]}),"\n",(0,i.jsxs)(t.p,{children:['RTK Query creates a "cache key" for each unique endpoint + argument combination, and stores the results for each cache key separately. That means that ',(0,i.jsx)(t.strong,{children:"you can use the same query hook multiple times, pass it different query parameters, and each result will be cached separately in the Redux store"}),"."]}),"\n",(0,i.jsx)(t.admonition,{type:"tip",children:(0,i.jsxs)(t.p,{children:["If you need the same data in multiple components, just call the same query hook with the same arguments in each component! For example, you can call ",(0,i.jsx)(t.code,{children:"useGetPostQuery('123')"})," in three different components, and RTK Query will make sure the data is only fetched once, and each component will re-render as needed."]})}),"\n",(0,i.jsxs)(t.p,{children:["It's also important to note that ",(0,i.jsxs)(t.strong,{children:["the query parameter must be a ",(0,i.jsx)(t.em,{children:"single"})," value!"]})," If you need to pass through multiple parameters, you must pass an object containing multiple fields (exactly the same as with ",(0,i.jsx)(t.code,{children:"createAsyncThunk"}),'). RTK Query will do a "shallow stable" comparison of the fields, and re-fetch the data if any of them have changed.']}),"\n",(0,i.jsxs)(t.p,{children:["Notice that the names of the actions in the left-hand list are much more generic and less descriptive: ",(0,i.jsx)(t.code,{children:"api/executeQuery/fulfilled"}),", instead of ",(0,i.jsx)(t.code,{children:"posts/fetchPosts/fulfilled"}),". This is a tradeoff of using an additional abstraction layer. The individual actions do contain the specific endpoint name under ",(0,i.jsx)(t.code,{children:"action.meta.arg.endpointName"}),", but it's not as easily viewable in the action history list."]}),"\n",(0,i.jsxs)(t.admonition,{type:"tip",children:[(0,i.jsx)(t.p,{children:'The Redux DevTools have an "RTK Query" tab that specifically shows RTK Query data in a more usable format that focuses on cache entries, rather than the raw Redux state structure. This includes info on each endpoint and cache result, stats on query timing, and much more:'}),(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"RTK Query data cached in the store state",src:n(3794).A+"",width:"2560",height:"919"})}),(0,i.jsx)(t.p,{children:"You can also see this live demo of the RTK Query devtools"}),(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://rtk-query-monitor-demo.netlify.app/",children:"RTK Query Monitor preview demo"})}),"\n"]})]}),"\n",(0,i.jsx)(t.h2,{id:"creating-posts-with-mutations",children:"Creating Posts with Mutations"}),"\n",(0,i.jsx)(t.p,{children:'We\'ve seen how we can fetch data from the server by defining "query" endpoints, but what about sending updates to the server?'}),"\n",(0,i.jsxs)(t.p,{children:["RTK Query lets us define ",(0,i.jsx)(t.strong,{children:"mutation endpoints"})," that update data on the server. Let's add a mutation that will let us add a new post."]}),"\n",(0,i.jsx)(t.h3,{id:"adding-the-new-post-mutation-endpoint",children:"Adding the New Post Mutation Endpoint"}),"\n",(0,i.jsxs)(t.p,{children:["Adding a mutation endpoint is very similar to adding a query endpoint. The biggest difference is that we define the endpoint using ",(0,i.jsx)(t.code,{children:"builder.mutation()"})," instead of ",(0,i.jsx)(t.code,{children:"builder.query()"}),". Also, we now need to change the HTTP method to be a ",(0,i.jsx)(t.code,{children:"'POST'"})," request, and we have to provide the body of the request as well."]}),"\n",(0,i.jsxs)(t.p,{children:["We'll export the existing ",(0,i.jsx)(t.code,{children:"NewPost"})," TS type from ",(0,i.jsx)(t.code,{children:"postsSlice.ts"}),", then use it as the argument type in this mutation, since it's what our component needs to pass in."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/api/apiSlice.ts"',children:"import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react'\n\n// highlight-next-line\nimport type { Post, NewPost } from '@/features/posts/postsSlice'\nexport type { Post }\n\nexport const apiSlice = createApi({\n  reducerPath: 'api',\n  baseQuery: fetchBaseQuery({ baseUrl: '/fakeApi' }),\n  endpoints: builder => ({\n    getPosts: builder.query<Post[], void>({\n      query: () => '/posts'\n    }),\n    getPost: builder.query<Post, string>({\n      query: postId => `/posts/${postId}`\n    }),\n    // highlight-start\n    addNewPost: builder.mutation<Post, NewPost>({\n      query: initialPost => ({\n        // The HTTP URL will be '/fakeApi/posts'\n        url: '/posts',\n        // This is an HTTP POST request, sending an update\n        method: 'POST',\n        // Include the entire post object as the body of the request\n        body: initialPost\n      })\n    })\n    // highlight-end\n  })\n})\n\nexport const {\n  useGetPostsQuery,\n  useGetPostQuery,\n  // highlight-next-line\n  useAddNewPostMutation\n} = apiSlice\n"})}),"\n",(0,i.jsxs)(t.p,{children:["As with the query endpoints, we specify the TS types: the mutation returns a full ",(0,i.jsx)(t.code,{children:"Post"}),", and accepts the partial ",(0,i.jsx)(t.code,{children:"NewPost"})," value as the argument."]}),"\n",(0,i.jsxs)(t.p,{children:["Here our ",(0,i.jsx)(t.code,{children:"query"})," option returns an object containing ",(0,i.jsx)(t.code,{children:"{url, method, body}"}),", which lets us specify that this will be an HTTP ",(0,i.jsx)(t.code,{children:"POST"})," method request, and what the ",(0,i.jsx)(t.code,{children:"body"})," contents should be. Since we're using ",(0,i.jsx)(t.code,{children:"fetchBaseQuery"})," to make the requests, the ",(0,i.jsx)(t.code,{children:"body"}),' field will automatically be JSON-serialized for us. (And yes, the word "post" appears entirely too many times in this example :) )']}),"\n",(0,i.jsxs)(t.p,{children:["Like with query endpoints, the API slice automatically generates a React hook for the mutation endpoint - in this case, ",(0,i.jsx)(t.code,{children:"useAddNewPostMutation"}),"."]}),"\n",(0,i.jsx)(t.h3,{id:"using-mutation-hooks-in-components",children:"Using Mutation Hooks in Components"}),"\n",(0,i.jsxs)(t.p,{children:["Our ",(0,i.jsx)(t.code,{children:"<AddPostForm>"}),' is already dispatching an async thunk to add a post whenever we click the "Save Post" button. To do that, it has to import ',(0,i.jsx)(t.code,{children:"useDispatch"})," and the ",(0,i.jsx)(t.code,{children:"addNewPost"})," thunk. The mutation hooks replace both of those, and the usage pattern is basically the same:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/posts/AddPostForm.tsx"',children:'import React from \'react\'\n\nimport { useAppSelector } from \'@/app/hooks\'\n\n// highlight-next-line\nimport { useAddNewPostMutation } from \'@/features/api/apiSlice\'\nimport { selectCurrentUsername } from \'@/features/auth/authSlice\'\n\n// omit field types\n\nexport const AddPostForm = () => {\n  const userId = useAppSelector(selectCurrentUsername)!\n  // highlight-next-line\n  const [addNewPost, { isLoading }] = useAddNewPostMutation()\n\n  const handleSubmit = async (e: React.FormEvent<AddPostFormElements>) => {\n    // Prevent server submission\n    e.preventDefault()\n\n    const { elements } = e.currentTarget\n    const title = elements.postTitle.value\n    const content = elements.postContent.value\n\n    const form = e.currentTarget\n\n    try {\n      // highlight-next-line\n      await addNewPost({ title, content, user: userId }).unwrap()\n\n      form.reset()\n    } catch (err) {\n      console.error(\'Failed to save the post: \', err)\n    }\n  }\n\n  return (\n    <section>\n      <h2>Add a New Post</h2>\n      <form onSubmit={handleSubmit}>\n        <label htmlFor="postTitle">Post Title:</label>\n        <input type="text" id="postTitle" defaultValue="" required />\n        <label htmlFor="postContent">Content:</label>\n        <textarea\n          id="postContent"\n          name="postContent"\n          defaultValue=""\n          required\n        />\n        // highlight-next-line\n        <button disabled={isLoading}>Save Post</button>\n      </form>\n    </section>\n  )\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:"Mutation hooks return an array with two values:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'The first value is a "trigger function". When called, it makes the request to the server, with whatever argument you provide. This is actually a thunk that has already been wrapped to immediately dispatch itself.'}),"\n",(0,i.jsxs)(t.li,{children:["The second value is an object with metadata about the current in-progress request, if any. This includes an ",(0,i.jsx)(t.code,{children:"isLoading"})," flag to indicate if a request is in-progress."]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["We can replace the existing thunk dispatch and component loading state with the trigger function and ",(0,i.jsx)(t.code,{children:"isLoading"})," flag from the ",(0,i.jsx)(t.code,{children:"useAddNewPostMutation"})," hook, and the rest of the component stays the same."]}),"\n",(0,i.jsxs)(t.p,{children:["As with the previous thunk dispatch, we call ",(0,i.jsx)(t.code,{children:"addNewPost"})," with the initial post object. This returns a special Promise with a ",(0,i.jsx)(t.code,{children:".unwrap()"})," method, and we can ",(0,i.jsx)(t.code,{children:"await addNewPost().unwrap()"})," to handle any potential errors with a standard ",(0,i.jsx)(t.code,{children:"try/catch"})," block. (This looks the same as ",(0,i.jsxs)(t.a,{href:"/tutorials/essentials/part-5-async-logic#checking-thunk-results-in-components",children:["what we saw with ",(0,i.jsx)(t.code,{children:"createAsyncThunk"})]}),", because it ",(0,i.jsx)(t.em,{children:"is"})," the same - RTK Query uses ",(0,i.jsx)(t.code,{children:"createAsyncThunk"})," internally)"]}),"\n",(0,i.jsx)(t.h2,{id:"refreshing-cached-data",children:"Refreshing Cached Data"}),"\n",(0,i.jsxs)(t.p,{children:['When we click "Save Post", we can view the Network tab in the browser DevTools and confirm that the HTTP ',(0,i.jsx)(t.code,{children:"POST"})," request succeeded. But, the new post isn't showing up in our ",(0,i.jsx)(t.code,{children:"<PostsList>"})," if we go back there. The Redux store state hasn't changed, and we still have the same cached data in memory."]}),"\n",(0,i.jsx)(t.p,{children:"We need to tell RTK Query to refresh its cached list of posts so that we can see the new post we just added."}),"\n",(0,i.jsx)(t.h3,{id:"refetching-posts-manually",children:"Refetching Posts Manually"}),"\n",(0,i.jsx)(t.p,{children:"The first option is to manually force RTK Query to refetch data for a given endpoint. This isn't the approach you'd use in a real app, but we'll try it now as an intermediate step."}),"\n",(0,i.jsxs)(t.p,{children:["Query hook result objects include a ",(0,i.jsx)(t.code,{children:"refetch"}),' function that we can call to force a refetch. We can temporarily add a "Refetch Posts" button to ',(0,i.jsx)(t.code,{children:"<PostsList>"})," and click that after adding a new post:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/posts/PostsList.tsx"',children:'export const PostsList = () => {\n  const {\n    data: posts = [],\n    isLoading,\n    isSuccess,\n    isError,\n    error,\n    // highlight-next-line\n    refetch\n  } = useGetPostsQuery()\n\n  // omit content\n\n  return (\n    <section className="posts-list">\n      <h2>Posts</h2>\n      // highlight-next-line\n      <button onClick={refetch}>Refetch Posts</button>\n      {content}\n    </section>\n  )\n}\n'})}),"\n",(0,i.jsx)(t.p,{children:'Now, if we add a new post, wait for that to complete, and click "Refetch Posts", we should see the new post showing up.'}),"\n",(0,i.jsxs)(t.p,{children:["Unfortunately, there's no real indicator that the refetch is happening. It would help if we showed ",(0,i.jsx)(t.em,{children:"something"})," to indicate that the refetch request is in progress."]}),"\n",(0,i.jsxs)(t.p,{children:["Earlier we saw that query hooks have both an ",(0,i.jsx)(t.code,{children:"isLoading"})," flag, which is ",(0,i.jsx)(t.code,{children:"true"})," if this is the ",(0,i.jsx)(t.em,{children:"first"})," request for data, and an ",(0,i.jsx)(t.code,{children:"isFetching"})," flag, which is ",(0,i.jsx)(t.code,{children:"true"})," while ",(0,i.jsx)(t.em,{children:"any"})," request for data is in progress. We could look at the ",(0,i.jsx)(t.code,{children:"isFetching"})," flag, and replace the entire list of posts with a loading spinner again while the refetch is in progress. But, that could be a bit annoying, and besides - we already have all these posts, why should we completely hide them?"]}),"\n",(0,i.jsx)(t.p,{children:"Instead, we could make the existing list of posts partially transparent to indicate the data is stale, but keep them visible while the refetch is happening. As soon as the request completes, we can return to showing the posts list as normal."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-tsx",metastring:'title="features/posts/PostsList.tsx"',children:"// highlight-next-line\nimport classnames from 'classnames'\n\nimport { useGetPostsQuery, Post } from '@/features/api/apiSlice'\n\n// omit other imports and PostExcerpt\n\nexport const PostsList = () => {\n  const {\n    data: posts = [],\n    isLoading,\n    // highlight-next-line\n    isFetching,\n    isSuccess,\n    isError,\n    error,\n    refetch\n  } = useGetPostsQuery()\n\n  const sortedPosts = useMemo(() => {\n    const sortedPosts = posts.slice()\n    sortedPosts.sort((a, b) => b.date.localeCompare(a.date))\n    return sortedPosts\n  }, [posts])\n\n  let content: React.ReactNode\n\n  if (isLoading) {\n    content = <Spinner text=\"Loading...\" />\n  } else if (isSuccess) {\n    // highlight-start\n    const renderedPosts = sortedPosts.map(post => (\n      <PostExcerpt key={post.id} post={post} />\n    ))\n    // highlight-end\n\n    // highlight-start\n    const containerClassname = classnames('posts-container', {\n      disabled: isFetching\n    })\n\n    content = <div className={containerClassname}>{renderedPosts}</div>\n    // highlight-end\n  } else if (isError) {\n    content = <div>{error.toString()}</div>\n  }\n\n  // omit return\n}\n"})}),"\n",(0,i.jsx)(t.p,{children:'If we add a new post and then click "Refetch Posts", we should now see the posts list go semi-transparent for a couple seconds, then re-render with the new post added at the top.'}),"\n",(0,i.jsx)(t.h3,{id:"automatic-refreshing-with-cache-invalidation",children:"Automatic Refreshing with Cache Invalidation"}),"\n",(0,i.jsx)(t.p,{children:"Manually forcing a refetch of data is occasionally necessary depending on user behavior, but definitely not a good solution for normal usage."}),"\n",(0,i.jsx)(t.p,{children:'We know that our "server" has a complete list of all posts, including the one we just added. Ideally, we want to have our app automatically refetch the updated list of posts as soon as the mutation request has completed. That way we know our client-side cached data is in sync with what the server has.'}),"\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:'RTK Query lets us define relationships between queries and mutations to enable automatic data refetching, using "tags"'}),'. A "tag" is a string or small object that lets you give identifiers to certain types of data, and "invalidate" portions of the cache. When a cache tag is invalidated, RTK Query will automatically refetch the endpoints that were marked with that tag.']}),"\n",(0,i.jsx)(t.p,{children:"Basic tag usage requires adding three pieces of information to our API slice:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["A root ",(0,i.jsx)(t.code,{children:"tagTypes"})," field in the API slice object, declaring an array of string tag names for data types such as ",(0,i.jsx)(t.code,{children:"'Post'"})]}),"\n",(0,i.jsxs)(t.li,{children:["A ",(0,i.jsx)(t.code,{children:"providesTags"})," array in query endpoints, listing a set of tags describing the data in that query"]}),"\n",(0,i.jsxs)(t.li,{children:["An ",(0,i.jsx)(t.code,{children:"invalidatesTags"})," array in mutation endpoints, listing a set of tags that are invalidated every time that mutation runs"]}),"\n"]}),"\n",(0,i.jsxs)(t.p,{children:["We can add a single tag called ",(0,i.jsx)(t.code,{children:"'Post'"})," to our API slice that will let us automatically refetch our ",(0,i.jsx)(t.code,{children:"getPosts"})," endpoint any time we add a new post:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",metastring:'title="features/api/apiSlice.ts"',children:"export const apiSlice = createApi({\n  reducerPath: 'api',\n  baseQuery: fetchBaseQuery({ baseUrl: '/fakeApi' }),\n  // highlight-next-line\n  tagTypes: ['Post'],\n  endpoints: builder => ({\n    getPosts: builder.query<Post[], void>({\n      query: () => '/posts',\n      // highlight-next-line\n      providesTags: ['Post']\n    }),\n    getPost: builder.query<Post, string>({\n      query: postId => `/posts/${postId}`\n    }),\n    addNewPost: builder.mutation<Post, NewPost>({\n      query: initialPost => ({\n        url: '/posts',\n        method: 'POST',\n        body: initialPost\n      }),\n      // highlight-next-line\n      invalidatesTags: ['Post']\n    })\n  })\n})\n"})}),"\n",(0,i.jsxs)(t.p,{children:['That\'s all we need! Now, if we click "Save Post", you should see the ',(0,i.jsx)(t.code,{children:"<PostsList>"})," component automatically gray out after a couple seconds, and then rerender with the newly added post at the top."]}),"\n",(0,i.jsxs)(t.p,{children:["Note that there's nothing special about the literal string ",(0,i.jsx)(t.code,{children:"'Post'"})," here. We could have called it ",(0,i.jsx)(t.code,{children:"'Fred'"}),", ",(0,i.jsx)(t.code,{children:"'qwerty'"}),', or anything else. It just needs to be the same string in each field, so that RTK Query knows "when this mutation happens, invalidate all endpoints that have that same tag string listed".']}),"\n",(0,i.jsx)(t.h2,{id:"what-youve-learned",children:"What You've Learned"}),"\n",(0,i.jsx)(t.p,{children:"With RTK Query, the actual details of how to manage data fetching, caching, and loading state are abstracted away. This simplifies application code considerably, and lets us focus on higher-level concerns about intended app behavior instead. Since RTK Query is implemented using the same Redux Toolkit APIs we've already seen, we can still use the Redux DevTools to view the changes in our state over time."}),"\n",(0,i.jsx)("iframe",{class:"codesandbox",src:"https://codesandbox.io/embed/github/reduxjs/redux-essentials-example-app/tree/ts-checkpoint-5-createApi?fontsize=14&hidenavigation=1&module=%2fsrc%2Ffeatures%2Fposts%2FpostsSlice.ts&theme=dark&runonclick=1",title:"redux-essentials-example",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),"\n",(0,i.jsx)(t.admonition,{title:"Summary",type:"tip",children:(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"RTK Query is a data fetching and caching solution included in Redux Toolkit"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"RTK Query abstracts the process of managing cached server data for you, and eliminates the need to write logic for loading state, storing results, and making requests"}),"\n",(0,i.jsx)(t.li,{children:"RTK Query builds on top of the same patterns used in Redux, like async thunks"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsxs)(t.strong,{children:['RTK Query uses a single "API slice" per application, defined using ',(0,i.jsx)(t.code,{children:"createApi"})]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["RTK Query provides UI-agnostic and React-specific versions of ",(0,i.jsx)(t.code,{children:"createApi"})]}),"\n",(0,i.jsx)(t.li,{children:'API slices define multiple "endpoints" for different server operations'}),"\n",(0,i.jsx)(t.li,{children:"The API slice includes auto-generated React hooks if using the React integration"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Query endpoints allow fetching and caching data from the server"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Query hooks return a ",(0,i.jsx)(t.code,{children:"data"})," value, plus loading status flags"]}),"\n",(0,i.jsx)(t.li,{children:'The query can be re-fetched manually, or automatically using "tags" for cache invalidation'}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Mutation endpoints allow updating data on the server"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:'Mutation hooks return a "trigger" function that sends an update request, plus loading status'}),"\n",(0,i.jsx)(t.li,{children:'The trigger function returns a Promise that can be "unwrapped" and awaited'}),"\n"]}),"\n"]}),"\n"]})}),"\n",(0,i.jsx)(t.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,i.jsxs)(t.p,{children:["RTK Query provides solid default behavior, but also includes many options for customizing how requests are managed and working with cached data. In ",(0,i.jsx)(t.a,{href:"/tutorials/essentials/part-8-rtk-query-advanced",children:"Part 8: RTK Query Advanced Patterns"}),", we'll see how to use these options to implement useful features like optimistic updates."]})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},4673:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/devtools-rtkq-cache-4d338d6100eeedfccb2a8d22bb283b2e.png"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(6540);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}},9692:(e,t,n)=>{n.d(t,{E:()=>i});n(6540);var s=n(4848);const i=e=>{let{children:t,title:n="Detailed Explanation"}=e;return(0,s.jsxs)("details",{className:"detailed-explanation",children:[(0,s.jsx)("summary",{children:(0,s.jsx)("h4",{children:n})}),t]})}}}]);