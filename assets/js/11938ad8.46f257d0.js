"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[6236],{1470:(e,t,n)=>{n.d(t,{A:()=>v});var s=n(6540),a=n(4164),o=n(3104),i=n(6347),r=n(205),l=n(7485),d=n(1682),c=n(679);function h(e){return s.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,s.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:t,children:n}=e;return(0,s.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:n,attributes:s,default:a}}=e;return{value:t,label:n,attributes:s,default:a}}))}(n);return function(e){const t=(0,d.XI)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function x(e){let{queryString:t=!1,groupId:n}=e;const a=(0,i.W6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l.aZ)(o),(0,s.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);t.set(o,e),a.replace({...a.location,search:t.toString()})}),[o,a])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,o=u(e),[i,l]=(0,s.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const s=n.find((e=>e.default))??n[0];if(!s)throw new Error("Unexpected error: 0 tabValues");return s.value}({defaultValue:t,tabValues:o}))),[d,h]=x({queryString:n,groupId:a}),[m,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,o]=(0,c.Dv)(n);return[a,(0,s.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:a}),j=(()=>{const e=d??m;return p({value:e,tabValues:o})?e:null})();(0,r.A)((()=>{j&&l(j)}),[j]);return{selectedValue:i,selectValue:(0,s.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),h(e),f(e)}),[h,f,o]),tabValues:o}}var f=n(2303);const j={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=n(4848);function w(e){let{className:t,block:n,selectedValue:s,selectValue:i,tabValues:r}=e;const l=[],{blockElementScrollPositionUntilNextRender:d}=(0,o.a_)(),c=e=>{const t=e.currentTarget,n=l.indexOf(t),a=r[n].value;a!==s&&(d(t),i(a))},h=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},t),children:r.map((e=>{let{value:t,label:n,attributes:o}=e;return(0,g.jsx)("li",{role:"tab",tabIndex:s===t?0:-1,"aria-selected":s===t,ref:e=>l.push(e),onKeyDown:h,onClick:c,...o,className:(0,a.A)("tabs__item",j.tabItem,o?.className,{"tabs__item--active":s===t}),children:n??t},t)}))})}function y(e){let{lazy:t,children:n,selectedValue:o}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===o));return e?(0,s.cloneElement)(e,{className:(0,a.A)("margin-top--md",e.props.className)}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:i.map(((e,t)=>(0,s.cloneElement)(e,{key:t,hidden:e.props.value!==o})))})}function b(e){const t=m(e);return(0,g.jsxs)("div",{className:(0,a.A)("tabs-container",j.tabList),children:[(0,g.jsx)(w,{...t,...e}),(0,g.jsx)(y,{...t,...e})]})}function v(e){const t=(0,f.A)();return(0,g.jsx)(b,{...e,children:h(e.children)},String(t))}},2965:(e,t,n)=>{n.d(t,{Ay:()=>r,RM:()=>o});var s=n(4848),a=n(8453);n(9365),n(1470);const o=[];function i(e){const t={a:"a",admonition:"admonition",em:"em",li:"li",p:"p",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(t.admonition,{type:"caution",children:[(0,s.jsxs)(t.p,{children:["Note that ",(0,s.jsx)(t.strong,{children:'this tutorial intentionally shows older-style Redux logic patterns that require more code than the "modern Redux" patterns with Redux Toolkit we teach as the right approach for building apps with Redux today'}),", in order to explain the principles and concepts behind Redux. It's ",(0,s.jsx)(t.em,{children:"not"})," meant to be a production-ready project."]}),(0,s.jsx)(t.p,{children:'See these pages to learn how to use "modern Redux" with Redux Toolkit:'}),(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/tutorials/essentials/part-1-overview-concepts",children:(0,s.jsx)(t.strong,{children:'The full "Redux Essentials" tutorial'})}),', which teaches "how to use Redux, the right way" with Redux Toolkit for real-world apps. ',(0,s.jsx)(t.strong,{children:'We recommend that all Redux learners should read the "Essentials" tutorial!'})]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.a,{href:"/tutorials/fundamentals/part-8-modern-redux",children:(0,s.jsx)(t.strong,{children:"Redux Fundamentals, Part 8: Modern Redux with Redux Toolkit"})}),", which shows how to convert the low-level examples from earlier sections into modern Redux Toolkit equivalents"]}),"\n"]})]})}function r(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(i,{...e})}):i(e)}},3706:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/todos-app-screenshot-b88cee51d457022943b3697ac0b010a7.png"},5410:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>l,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"tutorials/fundamentals/part-3-state-actions-reducers","title":"Redux Fundamentals, Part 3: State, Actions, and Reducers","description":"The official Redux Fundamentals tutorial: learn how reducers update state in response to actions","source":"@site/../docs/tutorials/fundamentals/part-3-state-actions-reducers.md","sourceDirName":"tutorials/fundamentals","slug":"/tutorials/fundamentals/part-3-state-actions-reducers","permalink":"/tutorials/fundamentals/part-3-state-actions-reducers","draft":false,"unlisted":false,"editUrl":"https://github.com/reduxjs/redux/edit/master/website/../docs/tutorials/fundamentals/part-3-state-actions-reducers.md","tags":[],"version":"current","lastUpdatedAt":1747212223000,"frontMatter":{"id":"part-3-state-actions-reducers","title":"Redux Fundamentals, Part 3: State, Actions, and Reducers","sidebar_label":"State, Actions, and Reducers","description":"The official Redux Fundamentals tutorial: learn how reducers update state in response to actions"},"sidebar":"docs","previous":{"title":"Redux Concepts and Data Flow","permalink":"/tutorials/fundamentals/part-2-concepts-data-flow"},"next":{"title":"Store","permalink":"/tutorials/fundamentals/part-4-store"}}');var a=n(4848),o=n(8453),i=n(9692),r=n(2965);const l={id:"part-3-state-actions-reducers",title:"Redux Fundamentals, Part 3: State, Actions, and Reducers",sidebar_label:"State, Actions, and Reducers",description:"The official Redux Fundamentals tutorial: learn how reducers update state in response to actions"},d=void 0,c={},h=[{value:"Introduction",id:"introduction",level:2},...r.RM,{value:"Project Setup",id:"project-setup",level:3},{value:"Creating a New Redux + React Project",id:"creating-a-new-redux--react-project",level:4},{value:"Exploring the Initial Project",id:"exploring-the-initial-project",level:4},{value:"Starting the Todo Example App",id:"starting-the-todo-example-app",level:2},{value:"Defining Requirements",id:"defining-requirements",level:3},{value:"Designing the State Values",id:"designing-the-state-values",level:3},{value:"Designing the State Structure",id:"designing-the-state-structure",level:3},{value:"Designing Actions",id:"designing-actions",level:3},{value:"Writing Reducers",id:"writing-reducers",level:2},{value:"Creating the Root Reducer",id:"creating-the-root-reducer",level:3},{value:"Rules of Reducers",id:"rules-of-reducers",level:3},{value:"Reducers and Immutable Updates",id:"reducers-and-immutable-updates",level:3},{value:"Handling Additional Actions",id:"handling-additional-actions",level:3},{value:"Splitting Reducers",id:"splitting-reducers",level:2},{value:"Combining Reducers",id:"combining-reducers",level:2},{value:"<code>combineReducers</code>",id:"combinereducers",level:3},{value:"What You&#39;ve Learned",id:"what-youve-learned",level:2},{value:"What&#39;s Next?",id:"whats-next",level:2}];function u(e){const t={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.admonition,{title:"What You'll Learn",type:"tip",children:(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"How to define state values that contain your app's data"}),"\n",(0,a.jsx)(t.li,{children:"How to define action objects that describe what happens in your app"}),"\n",(0,a.jsx)(t.li,{children:"How to write reducer functions that calculate updated state based on existing state and actions"}),"\n"]})}),"\n",(0,a.jsx)(t.admonition,{title:"Prerequisites",type:"info",children:(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:['Familiarity with key Redux terms and concepts like "actions", "reducers", "store", and "dispatching". (See ',(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.a,{href:"/tutorials/fundamentals/part-2-concepts-data-flow",children:"Part 2: Redux Concepts and Data Flow"})})," for explanations of these terms.)"]}),"\n"]})}),"\n",(0,a.jsx)(t.h2,{id:"introduction",children:"Introduction"}),"\n",(0,a.jsxs)(t.p,{children:["In ",(0,a.jsx)(t.a,{href:"/tutorials/fundamentals/part-2-concepts-data-flow",children:"Part 2: Redux Concepts and Data Flow"}),", we looked at how Redux can help us build maintainable apps by giving us a single central place to put global app state. We also talked about core Redux concepts like dispatching action objects and using reducer functions that return new state values."]}),"\n",(0,a.jsx)(t.p,{children:"Now that you have some idea of what these pieces are, it's time to put that knowledge into practice. We're going to build a small example app to see how these pieces actually work together."}),"\n",(0,a.jsx)(r.Ay,{}),"\n",(0,a.jsx)(t.h3,{id:"project-setup",children:"Project Setup"}),"\n",(0,a.jsx)(t.p,{children:"For this tutorial, we've created a pre-configured starter project that already has React set up, includes some default styling, and has a fake REST API that will allow us to write actual API requests in our app. You'll use this as the basis for writing the actual application code."}),"\n",(0,a.jsx)(t.p,{children:"To get started, you can open and fork this CodeSandbox:"}),"\n",(0,a.jsx)("iframe",{class:"codesandbox",src:"https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/master/?codemirror=1&fontsize=14&hidenavigation=1&theme=dark&runonclick=1",title:"redux-fundamentals-example-app",allow:"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb",sandbox:"allow-modals allow-forms allow-popups allow-scripts allow-same-origin"}),"\n",(0,a.jsxs)(t.p,{children:["You can also ",(0,a.jsx)(t.a,{href:"https://github.com/reduxjs/redux-fundamentals-example-app",children:"clone the same project from this Github repo"}),". After cloning the repo, you can install the tools for the project with ",(0,a.jsx)(t.code,{children:"npm install"}),", and start it with ",(0,a.jsx)(t.code,{children:"npm start"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["If you'd like to see the final version of what we're going to build, you can check out ",(0,a.jsxs)(t.a,{href:"https://github.com/reduxjs/redux-fundamentals-example-app/tree/tutorial-steps",children:["the ",(0,a.jsxs)(t.strong,{children:[(0,a.jsx)(t.code,{children:"tutorial-steps"})," branch"]})]}),", or ",(0,a.jsx)(t.a,{href:"https://codesandbox.io/s/github/reduxjs/redux-fundamentals-example-app/tree/tutorial-steps",children:"look at the final version in this CodeSandbox"}),"."]}),"\n",(0,a.jsx)(t.h4,{id:"creating-a-new-redux--react-project",children:"Creating a New Redux + React Project"}),"\n",(0,a.jsxs)(t.p,{children:["Once you've finished this tutorial, you'll probably want to try working on your own projects. ",(0,a.jsxs)(t.strong,{children:["We recommend using the ",(0,a.jsx)(t.a,{href:"https://github.com/reduxjs/cra-template-redux",children:"Redux templates for Create-React-App"})," as the fastest way to create a new Redux + React project"]}),". It comes with Redux Toolkit and React-Redux already configured, using ",(0,a.jsx)(t.a,{href:"/tutorials/fundamentals/part-1-overview",children:'a modernized version of the "counter" app example you saw in Part 1'}),". This lets you jump right into writing your actual application code without having to add the Redux packages and set up the store."]}),"\n",(0,a.jsx)(t.p,{children:"If you want to know specific details on how to add Redux to a project, see this explanation:"}),"\n",(0,a.jsxs)(i.E,{title:"Detailed Explanation: Adding Redux to a React Project",children:[(0,a.jsx)(t.p,{children:"The Redux template for CRA comes with Redux Toolkit and React-Redux already configured. If you're setting up a new project from scratch without that template, follow these steps:"}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Add the ",(0,a.jsx)(t.code,{children:"@reduxjs/toolkit"})," and ",(0,a.jsx)(t.code,{children:"react-redux"})," packages"]}),"\n",(0,a.jsxs)(t.li,{children:["Create a Redux store using RTK's ",(0,a.jsx)(t.code,{children:"configureStore"})," API, and pass in at least one reducer function"]}),"\n",(0,a.jsxs)(t.li,{children:["Import the Redux store into your application's entry point file (such as ",(0,a.jsx)(t.code,{children:"src/index.js"}),")"]}),"\n",(0,a.jsxs)(t.li,{children:["Wrap your root React component with the ",(0,a.jsx)(t.code,{children:"<Provider>"})," component from React-Redux, like:"]}),"\n"]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-jsx",children:"root.render(\n  <Provider store={store}>\n    <App />\n  </Provider>,\n  document.getElementById('root')\n)\n"})})]}),"\n",(0,a.jsx)(t.h4,{id:"exploring-the-initial-project",children:"Exploring the Initial Project"}),"\n",(0,a.jsxs)(t.p,{children:["This initial project is based on ",(0,a.jsx)(t.a,{href:"https://create-react-app.dev/docs/getting-started",children:"the standard Vite"})," project template, with some modifications."]}),"\n",(0,a.jsx)(t.p,{children:"Let's take a quick look at what the initial project contains:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"/src"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"index.js"}),": the entry point file for the application. It renders the main ",(0,a.jsx)(t.code,{children:"<App>"})," component."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"App.js"}),": the main application component."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"index.css"}),": styles for the complete application"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"/api"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"client.js"}),": a small ",(0,a.jsx)(t.code,{children:"fetch"})," wrapper client that allows us to make HTTP GET and POST requests"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"server.js"}),": provides a fake REST API for our data. Our app will fetch data from these fake endpoints later."]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"/exampleAddons"}),": contains some additional Redux addons that we'll use later in the tutorial to show how things work"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"If you load the app now, you should see a welcome message, but the rest of the app is otherwise empty."}),"\n",(0,a.jsx)(t.p,{children:"With that, let's get started!"}),"\n",(0,a.jsx)(t.h2,{id:"starting-the-todo-example-app",children:"Starting the Todo Example App"}),"\n",(0,a.jsx)(t.p,{children:'Our example application will be a small "todo" application. You\'ve probably seen todo app examples before - they make\ngood examples because they let us show how to do things like tracking a list of items, handling user input, and updating\nthe UI when that data changes, which are all things that happen in a normal application.'}),"\n",(0,a.jsx)(t.h3,{id:"defining-requirements",children:"Defining Requirements"}),"\n",(0,a.jsx)(t.p,{children:"Let's start by figuring out the initial business requirements for this application:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The UI should consist of three main sections:","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"An input box to let the user type in the text of a new todo item"}),"\n",(0,a.jsx)(t.li,{children:"A list of all the existing todo items"}),"\n",(0,a.jsx)(t.li,{children:"A footer section that shows the number of non-completed todos, and shows filtering options"}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.li,{children:'Todo list items should have a checkbox that toggles their "completed" status. We should also be able to add a color-coded\ncategory tag for a predefined list of colors, and delete todo items.'}),"\n",(0,a.jsx)(t.li,{children:'The counter should pluralize the number of active todos: "0 items", "1 item", "3 items", etc'}),"\n",(0,a.jsx)(t.li,{children:"There should be buttons to mark all todos as completed, and to clear all completed todos by removing them"}),"\n",(0,a.jsxs)(t.li,{children:["There should be two ways to filter the displayed todos in the list:","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'Filtering based on showing "All", "Active", and "Completed" todos'}),"\n",(0,a.jsx)(t.li,{children:"Filtering based on selecting one or more colors, and showing any todos whose tag that match those colors"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"We'll add some more requirements later on, but this is enough to get us started."}),"\n",(0,a.jsx)(t.p,{children:"The end goal is an app that should look like this:"}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.img,{alt:"Example todo app screenshot",src:n(3706).A+"",width:"1200",height:"850"})}),"\n",(0,a.jsx)(t.h3,{id:"designing-the-state-values",children:"Designing the State Values"}),"\n",(0,a.jsxs)(t.p,{children:["One of the core principles of React and Redux is that ",(0,a.jsx)(t.strong,{children:"your UI should be based on your state"}),". So, one approach to designing an application is to first think of all the state needed to describe how the application works. It's also a good idea\nto try to describe your UI with as few values in the state as possible, so there's less data you need to keep track of\nand update."]}),"\n",(0,a.jsx)(t.p,{children:"Conceptually, there are two main aspects of this application:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"The actual list of current todo items"}),"\n",(0,a.jsx)(t.li,{children:"The current filtering options"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"We'll also need to keep track of the data the user is typing into the \"Add Todo\" input box, but that's less important\nand we'll handle that later."}),"\n",(0,a.jsx)(t.p,{children:"For each todo item, we need to store a few pieces of information:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"The text the user entered"}),"\n",(0,a.jsx)(t.li,{children:"The boolean flag saying if it's completed or not"}),"\n",(0,a.jsx)(t.li,{children:"A unique ID value"}),"\n",(0,a.jsx)(t.li,{children:"A color category, if selected"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Our filtering behavior can probably be described with some enumerated values:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'Completed status: "All", "Active", and "Completed"'}),"\n",(0,a.jsx)(t.li,{children:'Colors: "Red", "Yellow", "Green", "Blue", "Orange", "Purple"'}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:'Looking at these values, we can also say that the todos are "app state" (the core data that the application works with),\nwhile the filtering values are "UI state" (state that describes what the app is doing right now). It can be helpful to\nthink about these different kinds of categories to help understand how the different pieces of state are being used.'}),"\n",(0,a.jsx)(t.h3,{id:"designing-the-state-structure",children:"Designing the State Structure"}),"\n",(0,a.jsxs)(t.p,{children:["With Redux, ",(0,a.jsx)(t.strong,{children:"our application state is always kept in plain JavaScript objects and arrays"}),". That means you may not put\nother things into the Redux state - no class instances, built-in JS types like ",(0,a.jsx)(t.code,{children:"Map"})," / ",(0,a.jsx)(t.code,{children:"Set"})," / ",(0,a.jsx)(t.code,{children:"Promise"})," / ",(0,a.jsx)(t.code,{children:"Date"}),", functions, or anything else that is not plain JS data."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"The root Redux state value is almost always a plain JS object"}),", with other data nested inside of it."]}),"\n",(0,a.jsx)(t.p,{children:"Based on this information, we should now be able to describe the kinds of values we need to have inside our Redux state:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["First, we need an array of todo item objects. Each item should have these fields:","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"id"}),": a unique number"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"text"}),": the text the user typed in"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"completed"}),": a boolean flag"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.code,{children:"color"}),": An optional color category"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["Then, we need to describe our filtering options. We need to have:","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'The current "completed" filter value'}),"\n",(0,a.jsx)(t.li,{children:"An array of the currently selected color categories"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"So, here's what an example of our app's state might look like:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const todoAppState = {\n  todos: [\n    { id: 0, text: 'Learn React', completed: true },\n    { id: 1, text: 'Learn Redux', completed: false, color: 'purple' },\n    { id: 2, text: 'Build something fun!', completed: false, color: 'blue' }\n  ],\n  filters: {\n    status: 'Active',\n    colors: ['red', 'blue']\n  }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["It's important to note that ",(0,a.jsx)(t.strong,{children:"it's okay to have other state values outside of Redux!"}),' This example is small enough so far that we actually do have all our state in the Redux store, but as we\'ll see later, some data really doesn\'t need to be kept in Redux (like "is this dropdown open?" or "current value of a form input").']}),"\n",(0,a.jsx)(t.h3,{id:"designing-actions",children:"Designing Actions"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Actions"})," are plain JavaScript objects that have a ",(0,a.jsx)(t.code,{children:"type"})," field. As mentioned earlier, ",(0,a.jsx)(t.strong,{children:"you can think of an action as an event that describes something that happened in the application"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"In the same way that we designed the state structure based on the app's requirements, we should also be able to\ncome up with a list of some of the actions that describe what's happening:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Add a new todo entry based on the text the user entered"}),"\n",(0,a.jsx)(t.li,{children:"Toggle the completed status of a todo"}),"\n",(0,a.jsx)(t.li,{children:"Select a color category for a todo"}),"\n",(0,a.jsx)(t.li,{children:"Delete a todo"}),"\n",(0,a.jsx)(t.li,{children:"Mark all todos as completed"}),"\n",(0,a.jsx)(t.li,{children:"Clear all completed todos"}),"\n",(0,a.jsx)(t.li,{children:'Choose a different "completed" filter value'}),"\n",(0,a.jsx)(t.li,{children:"Add a new color filter"}),"\n",(0,a.jsx)(t.li,{children:"Remove a color filter"}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["We normally put any extra data needed to describe what's happening into the ",(0,a.jsx)(t.code,{children:"action.payload"})," field. This could be a\nnumber, a string, or an object with multiple fields inside."]}),"\n",(0,a.jsxs)(t.p,{children:["The Redux store doesn't care what the actual text of the ",(0,a.jsx)(t.code,{children:"action.type"})," field is. However, your own code will look\nat ",(0,a.jsx)(t.code,{children:"action.type"})," to see if an update is needed. Also, you will frequently look at action type strings in the Redux\nDevTools Extension while debugging to see what's going on in your app. So, try to choose action types that are\nreadable and clearly describe what's happening - it'll be much easier to understand things when you look at them later!"]}),"\n",(0,a.jsx)(t.p,{children:"Based on that list of things that can happen, we can create a list of actions that our application will use:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"{type: 'todos/todoAdded', payload: todoText}"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"{type: 'todos/todoToggled', payload: todoId}"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"{type: 'todos/colorSelected', payload: {todoId, color}}"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"{type: 'todos/todoDeleted', payload: todoId}"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"{type: 'todos/allCompleted'}"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"{type: 'todos/completedCleared'}"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"{type: 'filters/statusFilterChanged', payload: filterValue}"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.code,{children:"{type: 'filters/colorFilterChanged', payload: {color, changeType}}"})}),"\n"]}),"\n",(0,a.jsxs)(t.p,{children:["In this case, the actions primarily have a single extra piece of data, so we can put that directly in the ",(0,a.jsx)(t.code,{children:"action.payload"}),' field. We could have split the color filter behavior into two actions, one for "added" and one for "removed", but in this case\nwe\'ll do it as one action with an extra field inside specifically to show that we can have objects as an action payload.']}),"\n",(0,a.jsxs)(t.p,{children:["Like the state data, ",(0,a.jsx)(t.strong,{children:"actions should contain the smallest amount of information needed to describe what happened"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"writing-reducers",children:"Writing Reducers"}),"\n",(0,a.jsx)(t.p,{children:"Now that we know what our state structure and our actions look like, it's time to write our first reducer."}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Reducers"})," are functions that take the current ",(0,a.jsx)(t.code,{children:"state"})," and an ",(0,a.jsx)(t.code,{children:"action"})," as arguments, and return a new ",(0,a.jsx)(t.code,{children:"state"})," result. In other words, ",(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.code,{children:"(state, action) => newState"})}),"."]}),"\n",(0,a.jsx)(t.h3,{id:"creating-the-root-reducer",children:"Creating the Root Reducer"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:'A Redux app really only has one reducer function: the "root reducer" function'})," that you will pass to ",(0,a.jsx)(t.code,{children:"createStore"})," later on. That one root reducer function is responsible for handling ",(0,a.jsx)(t.em,{children:"all"})," of the actions that are dispatched, and calculating what the ",(0,a.jsx)(t.em,{children:"entire"})," new state result should be every time."]}),"\n",(0,a.jsxs)(t.p,{children:["Let's start by creating a ",(0,a.jsx)(t.code,{children:"reducer.js"})," file in the ",(0,a.jsx)(t.code,{children:"src"})," folder, alongside ",(0,a.jsx)(t.code,{children:"index.js"})," and ",(0,a.jsx)(t.code,{children:"App.js"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Every reducer needs some initial state, so we'll add some fake todo entries to get us started. Then, we can write an outline for the logic inside the reducer function:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="src/reducer.js"',children:"const initialState = {\n  todos: [\n    { id: 0, text: 'Learn React', completed: true },\n    { id: 1, text: 'Learn Redux', completed: false, color: 'purple' },\n    { id: 2, text: 'Build something fun!', completed: false, color: 'blue' }\n  ],\n  filters: {\n    status: 'All',\n    colors: []\n  }\n}\n\n// Use the initialState as a default value\nexport default function appReducer(state = initialState, action) {\n  // The reducer normally looks at the action type field to decide what happens\n  switch (action.type) {\n    // Do something here based on the different types of actions\n    default:\n      // If this reducer doesn't recognize the action type, or doesn't\n      // care about this specific action, return the existing state unchanged\n      return state\n  }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["A reducer may be called with ",(0,a.jsx)(t.code,{children:"undefined"})," as the state value when the application is being initialized. If that happens, we need to provide an initial state value so the rest of the reducer code has something to work with. ",(0,a.jsxs)(t.strong,{children:["Reducers normally use default argument syntax to provide initial state: ",(0,a.jsx)(t.code,{children:"(state = initialState, action)"})]}),"."]}),"\n",(0,a.jsxs)(t.p,{children:["Next, let's add the logic to handle the ",(0,a.jsx)(t.code,{children:"'todos/todoAdded'"})," action."]}),"\n",(0,a.jsxs)(t.p,{children:["We first need to check if the current action's type matches that specific string.\nThen, we need to return a new object containing ",(0,a.jsx)(t.em,{children:"all"})," of the state, even for the fields\nthat didn't change."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="src/reducer.js"',children:"function nextTodoId(todos) {\n  const maxId = todos.reduce((maxId, todo) => Math.max(todo.id, maxId), -1)\n  return maxId + 1\n}\n\n// Use the initialState as a default value\nexport default function appReducer(state = initialState, action) {\n  // The reducer normally looks at the action type field to decide what happens\n  switch (action.type) {\n    // Do something here based on the different types of actions\n    // highlight-start\n    case 'todos/todoAdded': {\n      // We need to return a new state object\n      return {\n        // that has all the existing state data\n        ...state,\n        // but has a new array for the `todos` field\n        todos: [\n          // with all of the old todos\n          ...state.todos,\n          // and the new todo object\n          {\n            // Use an auto-incrementing numeric ID for this example\n            id: nextTodoId(state.todos),\n            text: action.payload,\n            completed: false\n          }\n        ]\n      }\n    }\n    // highlight-end\n    default:\n      // If this reducer doesn't recognize the action type, or doesn't\n      // care about this specific action, return the existing state unchanged\n      return state\n  }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"That's... an awful lot of work to add one todo item to the state. Why is all this extra work necessary?"}),"\n",(0,a.jsx)(t.h3,{id:"rules-of-reducers",children:"Rules of Reducers"}),"\n",(0,a.jsxs)(t.p,{children:["We said earlier that ",(0,a.jsxs)(t.strong,{children:["reducers must ",(0,a.jsx)(t.em,{children:"always"})," follow some special rules"]}),":"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["They should only calculate the new state value based on the ",(0,a.jsx)(t.code,{children:"state"})," and ",(0,a.jsx)(t.code,{children:"action"})," arguments"]}),"\n",(0,a.jsxs)(t.li,{children:["They are not allowed to modify the existing ",(0,a.jsx)(t.code,{children:"state"}),". Instead, they must make ",(0,a.jsx)(t.em,{children:"immutable updates"}),", by copying the existing ",(0,a.jsx)(t.code,{children:"state"})," and making changes to the copied values."]}),"\n",(0,a.jsx)(t.li,{children:'They must not do any asynchronous logic or other "side effects"'}),"\n"]}),"\n",(0,a.jsxs)(t.admonition,{type:"tip",children:[(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:'A "side effect" is any change to state or behavior that can be seen outside of returning a value from a function'}),". Some common kinds of side effects are things like:"]}),(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Logging a value to the console"}),"\n",(0,a.jsx)(t.li,{children:"Saving a file"}),"\n",(0,a.jsx)(t.li,{children:"Setting an async timer"}),"\n",(0,a.jsx)(t.li,{children:"Making an HTTP request"}),"\n",(0,a.jsx)(t.li,{children:"Modifying some state that exists outside of a function, or mutating arguments to a function"}),"\n",(0,a.jsxs)(t.li,{children:["Generating random numbers or unique random IDs (such as ",(0,a.jsx)(t.code,{children:"Math.random()"})," or ",(0,a.jsx)(t.code,{children:"Date.now()"}),")"]}),"\n"]})]}),"\n",(0,a.jsxs)(t.p,{children:["Any function that follows these rules is also known as a ",(0,a.jsx)(t.strong,{children:'"pure" function'}),", even if it's not specifically written as a reducer function."]}),"\n",(0,a.jsx)(t.p,{children:"But why are these rules important? There's a few different reasons:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"One of the goals of Redux is to make your code predictable. When a function's output is only calculated from the input arguments, it's easier to understand how that code works, and to test it."}),"\n",(0,a.jsx)(t.li,{children:"On the other hand, if a function depends on variables outside itself, or behaves randomly, you never know what will happen when you run it."}),"\n",(0,a.jsx)(t.li,{children:'If a function modifies other values, including its arguments, that can change the way the application works unexpectedly. This can be a common source of bugs, such as "I updated my state, but now my UI isn\'t updating when it should!"'}),"\n",(0,a.jsx)(t.li,{children:"Some of the Redux DevTools capabilities depend on having your reducers follow these rules correctly"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:'The rule about "immutable updates" is particularly important, and worth talking about further.'}),"\n",(0,a.jsx)(t.h3,{id:"reducers-and-immutable-updates",children:"Reducers and Immutable Updates"}),"\n",(0,a.jsx)(t.p,{children:'Earlier, we talked about "mutation" (modifying existing object/array values) and "immutability" (treating values as something that cannot be changed).'}),"\n",(0,a.jsxs)(t.admonition,{type:"warning",children:[(0,a.jsxs)(t.p,{children:["In Redux, ",(0,a.jsxs)(t.strong,{children:["our reducers are ",(0,a.jsx)(t.em,{children:"never"})," allowed to mutate the original / current state values!"]})]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// \u274c Illegal - by default, this will mutate the state!\nstate.value = 123\n"})})]}),"\n",(0,a.jsx)(t.p,{children:"There are several reasons why you must not mutate state in Redux:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"It causes bugs, such as the UI not updating properly to show the latest values"}),"\n",(0,a.jsx)(t.li,{children:"It makes it harder to understand why and how the state has been updated"}),"\n",(0,a.jsx)(t.li,{children:"It makes it harder to write tests"}),"\n",(0,a.jsx)(t.li,{children:'It breaks the ability to use "time-travel debugging" correctly'}),"\n",(0,a.jsx)(t.li,{children:"It goes against the intended spirit and usage patterns for Redux"}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"So if we can't change the originals, how do we return an updated state?"}),"\n",(0,a.jsxs)(t.admonition,{type:"tip",children:[(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["Reducers can only make ",(0,a.jsx)(t.em,{children:"copies"})," of the original values, and then they can mutate the copies."]})}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"// \u2705 This is safe, because we made a copy\nreturn {\n  ...state,\n  value: 123\n}\n"})})]}),"\n",(0,a.jsxs)(t.p,{children:["We already saw that we can ",(0,a.jsx)(t.a,{href:"/tutorials/fundamentals/part-2-concepts-data-flow#immutability",children:"write immutable updates by hand"}),", by using JavaScript's array / object spread operators and other functions that return copies of the original values."]}),"\n",(0,a.jsxs)(t.p,{children:["This becomes harder when the data is nested. ",(0,a.jsxs)(t.strong,{children:["A critical rule of immutable updates is that you must make a copy of ",(0,a.jsx)(t.em,{children:"every"})," level of nesting that needs to be updated."]})]}),"\n",(0,a.jsx)(t.p,{children:"However, if you're thinking that \"writing immutable updates by hand this way looks hard to remember and do correctly\"... yeah, you're right! :)"}),"\n",(0,a.jsxs)(t.p,{children:["Writing immutable update logic by hand ",(0,a.jsx)(t.em,{children:"is"})," hard, and ",(0,a.jsx)(t.strong,{children:"accidentally mutating state in reducers is the single most common mistake Redux users make"}),"."]}),"\n",(0,a.jsx)(t.admonition,{type:"tip",children:(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"In real-world applications, you won't have to write these complex nested immutable updates by hand"}),". In ",(0,a.jsx)(t.a,{href:"/tutorials/fundamentals/part-8-modern-redux",children:"Part 8: Modern Redux with Redux Toolkit"}),", you'll\nlearn how to use Redux Toolkit to simplify writing immutable update logic in reducers."]})}),"\n",(0,a.jsx)(t.h3,{id:"handling-additional-actions",children:"Handling Additional Actions"}),"\n",(0,a.jsxs)(t.p,{children:["With that in mind, let's add the reducer logic for a couple more cases. First, toggling a todo's ",(0,a.jsx)(t.code,{children:"completed"})," field based on its ID:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="src/reducer.js"',children:"export default function appReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'todos/todoAdded': {\n      return {\n        ...state,\n        todos: [\n          ...state.todos,\n          {\n            id: nextTodoId(state.todos),\n            text: action.payload,\n            completed: false\n          }\n        ]\n      }\n    }\n    // highlight-start\n    case 'todos/todoToggled': {\n      return {\n        // Again copy the entire state object\n        ...state,\n        // This time, we need to make a copy of the old todos array\n        todos: state.todos.map(todo => {\n          // If this isn't the todo item we're looking for, leave it alone\n          if (todo.id !== action.payload) {\n            return todo\n          }\n\n          // We've found the todo that has to change. Return a copy:\n          return {\n            ...todo,\n            // Flip the completed flag\n            completed: !todo.completed\n          }\n        })\n      }\n    }\n    // highlight-end\n    default:\n      return state\n  }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"And since we've been focusing on the todos state, let's add a case to handle the \"visibility selection changed\" action as well:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="src/reducer.js"',children:"export default function appReducer(state = initialState, action) {\n  switch (action.type) {\n    case 'todos/todoAdded': {\n      return {\n        ...state,\n        todos: [\n          ...state.todos,\n          {\n            id: nextTodoId(state.todos),\n            text: action.payload,\n            completed: false\n          }\n        ]\n      }\n    }\n    case 'todos/todoToggled': {\n      return {\n        ...state,\n        todos: state.todos.map(todo => {\n          if (todo.id !== action.payload) {\n            return todo\n          }\n\n          return {\n            ...todo,\n            completed: !todo.completed\n          }\n        })\n      }\n    }\n    // highlight-start\n    case 'filters/statusFilterChanged': {\n      return {\n        // Copy the whole state\n        ...state,\n        // Overwrite the filters value\n        filters: {\n          // copy the other filter fields\n          ...state.filters,\n          // And replace the status field with the new value\n          status: action.payload\n        }\n      }\n    }\n    // highlight-end\n    default:\n      return state\n  }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"We've only handled 3 actions, but this is already getting a bit long. If we try to handle every action in this one reducer\nfunction, it's going to be hard to read it all."}),"\n",(0,a.jsxs)(t.p,{children:["That's why ",(0,a.jsx)(t.strong,{children:"reducers are typically split into multiple smaller reducer functions"})," - to make it easier to understand and\nmaintain the reducer logic."]}),"\n",(0,a.jsx)(t.h2,{id:"splitting-reducers",children:"Splitting Reducers"}),"\n",(0,a.jsxs)(t.p,{children:["As part of this, ",(0,a.jsx)(t.strong,{children:"Redux reducers are typically split apart based on the section of the Redux state that they update"}),". Our todo app state currently has two top-level sections: ",(0,a.jsx)(t.code,{children:"state.todos"})," and ",(0,a.jsx)(t.code,{children:"state.filters"}),". So, we can split the large root reducer function into two smaller reducers - a ",(0,a.jsx)(t.code,{children:"todosReducer"})," and a ",(0,a.jsx)(t.code,{children:"filtersReducer"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"So, where should these split-up reducer functions live?"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:'We recommend organizing your Redux app folders and files based on "features"'})," - code that relates to a specific concept\nor area of your application. ",(0,a.jsx)(t.strong,{children:'The Redux code for a particular feature is usually written as a single file, known as a\n"slice" file'}),", which contains all the reducer logic and all of the action-related code for that part of your app state."]}),"\n",(0,a.jsxs)(t.p,{children:["Because of that, ",(0,a.jsx)(t.strong,{children:'the reducer for a specific section of the Redux app state is called a "slice reducer"'}),". Typically, some of the action objects will be closely related to a specific slice reducer, and so the action type strings should start with the name of that feature (like ",(0,a.jsx)(t.code,{children:"'todos'"}),") and describe the event that happened (like ",(0,a.jsx)(t.code,{children:"'todoAdded'"}),"), joined together into one string (",(0,a.jsx)(t.code,{children:"'todos/todoAdded'"}),")."]}),"\n",(0,a.jsxs)(t.p,{children:["In our project, create a new ",(0,a.jsx)(t.code,{children:"features"})," folder, and then a ",(0,a.jsx)(t.code,{children:"todos"})," folder inside that. Create a new file named ",(0,a.jsx)(t.code,{children:"todosSlice.js"}),", and let's cut and paste the todo-related initial state over into this file:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',children:"const initialState = [\n  { id: 0, text: 'Learn React', completed: true },\n  { id: 1, text: 'Learn Redux', completed: false, color: 'purple' },\n  { id: 2, text: 'Build something fun!', completed: false, color: 'blue' }\n]\n\nfunction nextTodoId(todos) {\n  const maxId = todos.reduce((maxId, todo) => Math.max(todo.id, maxId), -1)\n  return maxId + 1\n}\n\nexport default function todosReducer(state = initialState, action) {\n  switch (action.type) {\n    default:\n      return state\n  }\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Now we can copy over the logic for updating the todos. However, there's an important difference here. ",(0,a.jsx)(t.strong,{children:"This file only has to update the todos-related state - it's not nested any more!"})," This is another reason why we split up reducers. Since the todos state is an array by itself, we don't have to copy the outer root state object in here. That makes this reducer easier to read."]}),"\n",(0,a.jsxs)(t.p,{children:["This is called ",(0,a.jsx)(t.strong,{children:"reducer composition"}),", and it's the fundamental pattern of building Redux apps."]}),"\n",(0,a.jsx)(t.p,{children:"Here's what the updated reducer looks like after we handle those actions:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="src/features/todos/todosSlice.js"',children:"export default function todosReducer(state = initialState, action) {\n  switch (action.type) {\n    // highlight-start\n    case 'todos/todoAdded': {\n      // Can return just the new todos array - no extra object around it\n      return [\n        ...state,\n        {\n          id: nextTodoId(state),\n          text: action.payload,\n          completed: false\n        }\n      ]\n    }\n    case 'todos/todoToggled': {\n      return state.map(todo => {\n        if (todo.id !== action.payload) {\n          return todo\n        }\n\n        return {\n          ...todo,\n          completed: !todo.completed\n        }\n      })\n    }\n    // highlight-end\n    default:\n      return state\n  }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"That's a bit shorter and easier to read."}),"\n",(0,a.jsxs)(t.p,{children:["Now we can do the same thing for the visibility logic. Create ",(0,a.jsx)(t.code,{children:"src/features/filters/filtersSlice.js"}),", and let's move all the filter-related code over there:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="src/features/filters/filtersSlice.js"',children:"const initialState = {\n  status: 'All',\n  colors: []\n}\n\nexport default function filtersReducer(state = initialState, action) {\n  switch (action.type) {\n    // highlight-start\n    case 'filters/statusFilterChanged': {\n      return {\n        // Again, one less level of nesting to copy\n        ...state,\n        status: action.payload\n      }\n    }\n    // highlight-end\n    default:\n      return state\n  }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"We still have to copy the object containing the filters state, but since there's less nesting, it's easier to read what's happening."}),"\n",(0,a.jsxs)(t.admonition,{type:"info",children:[(0,a.jsx)(t.p,{children:"To keep this page shorter, we'll skip showing how to write the reducer update logic for the other actions."}),(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"Try writing the updates for those yourself"}),", based on ",(0,a.jsx)(t.a,{href:"#defining-requirements",children:"the requirements described above"}),"."]}),(0,a.jsxs)(t.p,{children:["If you get stuck, see ",(0,a.jsx)(t.a,{href:"#what-youve-learned",children:"the CodeSandbox at the end of this page"})," for the complete implementation of these reducers."]})]}),"\n",(0,a.jsx)(t.h2,{id:"combining-reducers",children:"Combining Reducers"}),"\n",(0,a.jsxs)(t.p,{children:["We now have two separate slice files, each with its own slice reducer function. But, we said earlier that the Redux store needs ",(0,a.jsx)(t.em,{children:"one"})," root reducer function when we create it. So, how can we go back to having a root reducer without putting all the code in one big function?"]}),"\n",(0,a.jsxs)(t.p,{children:["Since reducers are normal JS functions, we can import the slice reducers back into ",(0,a.jsx)(t.code,{children:"reducer.js"}),", and write a new root reducer whose only job is to call the other two functions."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="src/reducer.js"',children:"import todosReducer from './features/todos/todosSlice'\nimport filtersReducer from './features/filters/filtersSlice'\n\nexport default function rootReducer(state = {}, action) {\n  // always return a new object for the root state\n  return {\n    // the value of `state.todos` is whatever the todos reducer returns\n    todos: todosReducer(state.todos, action),\n    // For both reducers, we only pass in their slice of the state\n    filters: filtersReducer(state.filters, action)\n  }\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Note that each of these reducers is managing its own part of the global state. The state parameter is different for every reducer, and corresponds to the part of the state it manages."})}),"\n",(0,a.jsx)(t.p,{children:"This allows us to split up our logic based on features and slices of state, to keep things maintainable."}),"\n",(0,a.jsx)(t.h3,{id:"combinereducers",children:(0,a.jsx)(t.code,{children:"combineReducers"})}),"\n",(0,a.jsx)(t.p,{children:"We can see that the new root reducer is doing the same thing for each slice: calling the slice reducer, passing in the slice of the state owned by that reducer, and assigning the result back to the root state object. If we were to add more slices, the pattern\nwould repeat."}),"\n",(0,a.jsxs)(t.p,{children:["The Redux core library includes a utility called ",(0,a.jsx)(t.a,{href:"/api/combinereducers",children:(0,a.jsx)(t.code,{children:"combineReducers"})}),", which does this same boilerplate step for us. We can replace our hand-written ",(0,a.jsx)(t.code,{children:"rootReducer"})," with a shorter one generated by ",(0,a.jsx)(t.code,{children:"combineReducers"}),"."]}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsxs)(t.strong,{children:["Now that we need ",(0,a.jsx)(t.code,{children:"combineReducers"}),", it's time to actually install the Redux core library"]}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"npm install redux\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Once that's done, we can import ",(0,a.jsx)(t.code,{children:"combineReducers"})," and use it:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",metastring:'title="src/reducer.js"',children:"// highlight-next-line\nimport { combineReducers } from 'redux'\n\nimport todosReducer from './features/todos/todosSlice'\nimport filtersReducer from './features/filters/filtersSlice'\n\nconst rootReducer = combineReducers({\n  // Define a top-level state field named `todos`, handled by `todosReducer`\n  todos: todosReducer,\n  filters: filtersReducer\n})\n\nexport default rootReducer\n"})}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"combineReducers"})," accepts an object where the key names will become the keys in your root state object, and the\nvalues are the slice reducer functions that know how to update those slices of the Redux state."]}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["Remember, the key names you give to ",(0,a.jsx)(t.code,{children:"combineReducers"})," decides what the key names of your state object will be!"]})}),"\n",(0,a.jsx)(t.h2,{id:"what-youve-learned",children:"What You've Learned"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.strong,{children:"State, Actions, and Reducers are the building blocks of Redux"}),". Every Redux app has state values, creates actions to describe what happened, and uses reducer functions to calculate new state values based on the previous state and an action."]}),"\n",(0,a.jsx)(t.p,{children:"Here's the contents of our app so far:"}),"\n",(0,a.jsx)("iframe",{class:"codesandbox",src:"https://codesandbox.io/embed/github/reduxjs/redux-fundamentals-example-app/tree/checkpoint-1-combinedReducers/?codemirror=1&fontsize=14&hidenavigation=1&module=%2Fsrc%2Freducer.js&theme=dark&runonclick=1",title:"redux-fundamentals-example-app",allow:"accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking",sandbox:"allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"}),"\n",(0,a.jsx)(t.admonition,{title:"Summary",type:"tip",children:(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Redux apps use plain JS objects, arrays, and primitives as the state values"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"The root state value should be a plain JS object"}),"\n",(0,a.jsx)(t.li,{children:"The state should contain the smallest amount of data needed to make the app work"}),"\n",(0,a.jsxs)(t.li,{children:["Classes, Promises, functions, and other non-plain values should ",(0,a.jsx)(t.em,{children:"not"})," go in the Redux state"]}),"\n",(0,a.jsxs)(t.li,{children:["Reducers must not create random values like ",(0,a.jsx)(t.code,{children:"Math.random()"})," or ",(0,a.jsx)(t.code,{children:"Date.now()"})]}),"\n",(0,a.jsx)(t.li,{children:"It's okay to have other state values that are not in the Redux store (like local component state) side-by side with Redux"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsxs)(t.strong,{children:["Actions are plain objects with a ",(0,a.jsx)(t.code,{children:"type"})," field that describe what happened"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["The ",(0,a.jsx)(t.code,{children:"type"})," field should be a readable string, and is usually written as ",(0,a.jsx)(t.code,{children:"'feature/eventName'"})]}),"\n",(0,a.jsxs)(t.li,{children:["Actions may contain other values, which are typically stored in the ",(0,a.jsx)(t.code,{children:"action.payload"})," field"]}),"\n",(0,a.jsx)(t.li,{children:"Actions should have the smallest amount of data needed to describe what happened"}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsxs)(t.strong,{children:["Reducers are functions that look like ",(0,a.jsx)(t.code,{children:"(state, action) => newState"})]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Reducers must always follow special rules:","\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["Only calculate the new state based on the ",(0,a.jsx)(t.code,{children:"state"})," and ",(0,a.jsx)(t.code,{children:"action"})," arguments"]}),"\n",(0,a.jsxs)(t.li,{children:["Never mutate the existing ",(0,a.jsx)(t.code,{children:"state"})," - always return a copy"]}),"\n",(0,a.jsx)(t.li,{children:'No "side effects" like HTTP requests or async logic'}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Reducers should be split up to make them easier to read"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:'Reducers are usually split based on top-level state keys or "slices" of state'}),"\n",(0,a.jsx)(t.li,{children:'Reducers are usually written in "slice" files, organized into "feature" folders'}),"\n",(0,a.jsxs)(t.li,{children:["Reducers can be combined together with the Redux ",(0,a.jsx)(t.code,{children:"combineReducers"})," function"]}),"\n",(0,a.jsxs)(t.li,{children:["The key names given to ",(0,a.jsx)(t.code,{children:"combineReducers"})," define the top-level state object keys"]}),"\n"]}),"\n"]}),"\n"]})}),"\n",(0,a.jsx)(t.h2,{id:"whats-next",children:"What's Next?"}),"\n",(0,a.jsx)(t.p,{children:"We now have some reducer logic that will update our state, but those reducers won't do anything by themselves. They need\nto be put inside a Redux store, which can call the reducer code with actions when something has happened."}),"\n",(0,a.jsxs)(t.p,{children:["In ",(0,a.jsx)(t.a,{href:"/tutorials/fundamentals/part-4-store",children:"Part 4: Store"}),", we'll see how to create a Redux store and run our reducer logic."]})]})}function p(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var s=n(6540);const a={},o=s.createContext(a);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(o.Provider,{value:t},e.children)}},9365:(e,t,n)=>{n.d(t,{A:()=>i});n(6540);var s=n(4164);const a={tabItem:"tabItem_Ymn6"};var o=n(4848);function i(e){let{children:t,hidden:n,className:i}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,s.A)(a.tabItem,i),hidden:n,children:t})}},9692:(e,t,n)=>{n.d(t,{E:()=>a});n(6540);var s=n(4848);const a=e=>{let{children:t,title:n="Detailed Explanation"}=e;return(0,s.jsxs)("details",{className:"detailed-explanation",children:[(0,s.jsx)("summary",{children:(0,s.jsx)("h4",{children:n})}),t]})}}}]);