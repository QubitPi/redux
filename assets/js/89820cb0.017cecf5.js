"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9837],{6760:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(8168),i=(n(6540),n(5680));const r={id:"usage-with-typescript",title:"Usage With TypeScript"},o="Usage with TypeScript",s={unversionedId:"usage/usage-with-typescript",id:"usage/usage-with-typescript",title:"Usage With TypeScript",description:"- Standard patterns for setting up a Redux app with TypeScript",source:"@site/../docs/usage/UsageWithTypescript.md",sourceDirName:"usage",slug:"/usage/usage-with-typescript",permalink:"/usage/usage-with-typescript",draft:!1,editUrl:"https://github.com/reduxjs/redux/edit/master/website/../docs/usage/UsageWithTypescript.md",tags:[],version:"current",lastUpdatedAt:1737618502,formattedLastUpdatedAt:"Jan 23, 2025",frontMatter:{id:"usage-with-typescript",title:"Usage With TypeScript"},sidebar:"docs",previous:{title:"Migrating to RTK 2.0 and Redux 5.0",permalink:"/usage/migrations/migrating-rtk-2"},next:{title:"Writing Tests",permalink:"/usage/writing-tests"}},p={},l=[{value:"Overview",id:"overview",level:2},{value:"Standard Redux Toolkit Project Setup with TypeScript",id:"standard-redux-toolkit-project-setup-with-typescript",level:2},{value:"Define Root State and Dispatch Types",id:"define-root-state-and-dispatch-types",level:3},{value:"Define Typed Hooks",id:"define-typed-hooks",level:3},{value:"<code>.withTypes()</code>",id:"withtypes",level:4},{value:"Application Usage",id:"application-usage",level:2},{value:"Define Slice State and Action Types",id:"define-slice-state-and-action-types",level:3},{value:"Use Typed Hooks in Components",id:"use-typed-hooks-in-components",level:3},{value:"Typing Additional Redux Logic",id:"typing-additional-redux-logic",level:2},{value:"Type Checking Reducers",id:"type-checking-reducers",level:3},{value:"Type Checking Middleware",id:"type-checking-middleware",level:3},{value:"Type Checking Redux Thunks",id:"type-checking-redux-thunks",level:3},{value:"Usage with React Redux",id:"usage-with-react-redux",level:2},{value:"Typing the <code>useSelector</code> hook",id:"typing-the-useselector-hook",level:3},{value:"Typing the <code>useDispatch</code> hook",id:"typing-the-usedispatch-hook",level:3},{value:"Typing the <code>connect</code> higher order component",id:"typing-the-connect-higher-order-component",level:3},{value:"Usage with Redux Toolkit",id:"usage-with-redux-toolkit",level:2},{value:"Typing <code>configureStore</code>",id:"typing-configurestore",level:3},{value:"Matching Actions",id:"matching-actions",level:3},{value:"Typing <code>createSlice</code>",id:"typing-createslice",level:3},{value:"Defining Separate Case Reducers",id:"defining-separate-case-reducers",level:4},{value:"Typing <code>extraReducers</code>",id:"typing-extrareducers",level:4},{value:"Typing <code>prepare</code> Callbacks",id:"typing-prepare-callbacks",level:4},{value:"Fixing Circular Types in Exported Slices",id:"fixing-circular-types-in-exported-slices",level:4},{value:"Typing <code>createAsyncThunk</code>",id:"typing-createasyncthunk",level:3},{value:"Typing <code>createEntityAdapter</code>",id:"typing-createentityadapter",level:3},{value:"Additional Recommendations",id:"additional-recommendations",level:2},{value:"Use the React Redux Hooks API",id:"use-the-react-redux-hooks-api",level:3},{value:"Avoid Action Type Unions",id:"avoid-action-type-unions",level:3},{value:"Resources",id:"resources",level:2}],c={toc:l},d="wrapper";function u(e){let{components:t,...n}=e;return(0,i.yg)(d,(0,a.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"usage-with-typescript"},"Usage with TypeScript"),(0,i.yg)("admonition",{title:"What You'll Learn",type:"tip"},(0,i.yg)("ul",{parentName:"admonition"},(0,i.yg)("li",{parentName:"ul"},"Standard patterns for setting up a Redux app with TypeScript"),(0,i.yg)("li",{parentName:"ul"},"Techniques for correctly typing portions of Redux logic"))),(0,i.yg)("admonition",{title:"Prerequisites",type:"important"},(0,i.yg)("ul",{parentName:"admonition"},(0,i.yg)("li",{parentName:"ul"},"Understanding of ",(0,i.yg)("a",{parentName:"li",href:"https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html"},"TypeScript syntax and terms")),(0,i.yg)("li",{parentName:"ul"},"Familiarity with TypeScript concepts like ",(0,i.yg)("a",{parentName:"li",href:"https://www.typescriptlang.org/docs/handbook/2/generics.html"},"generics")," and ",(0,i.yg)("a",{parentName:"li",href:"https://www.typescriptlang.org/docs/handbook/utility-types.html"},"utility types")),(0,i.yg)("li",{parentName:"ul"},"Knowledge of ",(0,i.yg)("a",{parentName:"li",href:"https://reactjs.org/docs/hooks-intro.html"},"React Hooks")))),(0,i.yg)("h2",{id:"overview"},"Overview"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"TypeScript")," is a typed superset of JavaScript that provides compile-time checking of source code. When used with Redux, TypeScript can help provide:"),(0,i.yg)("ol",null,(0,i.yg)("li",{parentName:"ol"},"Type safety for reducers, state and action creators, and UI components"),(0,i.yg)("li",{parentName:"ol"},"Easy refactoring of typed code"),(0,i.yg)("li",{parentName:"ol"},"A superior developer experience in a team environment")),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"/style-guide/#use-static-typing"},(0,i.yg)("strong",{parentName:"a"},"We strongly recommend using TypeScript in Redux applications")),". However, like all tools, TypeScript has tradeoffs. It adds complexity in terms of writing additional code, understanding TS syntax, and building the application. At the same time, it provides value by catching errors earlier in development, enabling safer and more efficient refactoring, and acting as documentation for existing source code."),(0,i.yg)("p",null,"We believe that ",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("a",{parentName:"strong",href:"https://blog.isquaredsoftware.com/2019/11/blogged-answers-learning-and-using-typescript/#pragmatism-is-vital"},"pragmatic use of TypeScript")," provides more than enough value and benefit to justify the added overhead"),", especially in larger codebases, but you should take time to ",(0,i.yg)("strong",{parentName:"p"},"evaluate the tradeoffs and decide whether it's worth using TS in your own application"),"."),(0,i.yg)("p",null,"There are multiple possible approaches to type checking Redux code. ",(0,i.yg)("strong",{parentName:"p"},"This page shows our standard recommended patterns for using Redux and TypeScript together"),", and is not an exhaustive guide. Following these patterns should result in a good TS usage experience, with ",(0,i.yg)("strong",{parentName:"p"},"the best tradeoffs between type safety and amount of type declarations you have to add to your codebase"),"."),(0,i.yg)("h2",{id:"standard-redux-toolkit-project-setup-with-typescript"},"Standard Redux Toolkit Project Setup with TypeScript"),(0,i.yg)("p",null,"We assume that a typical Redux project is using Redux Toolkit and React Redux together."),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://redux-toolkit.js.org"},"Redux Toolkit")," (RTK) is the standard approach for writing modern Redux logic. RTK is already written in TypeScript, and its API is designed to provide a good experience for TypeScript usage."),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://react-redux.js.org"},"React Redux")," has its type definitions in a separate ",(0,i.yg)("a",{parentName:"p",href:"https://npm.im/@types/react-redux"},(0,i.yg)("inlineCode",{parentName:"a"},"@types/react-redux")," typedefs package")," on NPM. In addition to typing the library functions, the types also export some helpers to make it easier to write typesafe interfaces between your Redux store and your React components."),(0,i.yg)("p",null,"As of React Redux v7.2.3, the ",(0,i.yg)("inlineCode",{parentName:"p"},"react-redux")," package has a dependency on ",(0,i.yg)("inlineCode",{parentName:"p"},"@types/react-redux"),", so the type definitions will be automatically installed with the library. Otherwise, you'll need to manually install them yourself (typically ",(0,i.yg)("inlineCode",{parentName:"p"},"npm install @types/react-redux")," )."),(0,i.yg)("p",null,"The ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/reduxjs/cra-template-redux-typescript"},"Redux+TS template for Create-React-App")," comes with a working example of these patterns already configured."),(0,i.yg)("h3",{id:"define-root-state-and-dispatch-types"},"Define Root State and Dispatch Types"),(0,i.yg)("p",null,"Using ",(0,i.yg)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/configureStore"},"configureStore")," should not need any additional typings. You will, however, want to extract the ",(0,i.yg)("inlineCode",{parentName:"p"},"RootState")," type and the ",(0,i.yg)("inlineCode",{parentName:"p"},"Dispatch")," type so that they can be referenced as needed. Inferring these types from the store itself means that they correctly update as you add more state slices or modify middleware settings."),(0,i.yg)("p",null,"Since those are types, it's safe to export them directly from your store setup file such as ",(0,i.yg)("inlineCode",{parentName:"p"},"app/store.ts")," and import them directly into other files."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="app/store.ts"',title:'"app/store.ts"'},"import { configureStore } from '@reduxjs/toolkit'\n// ...\n\nexport const store = configureStore({\n  reducer: {\n    posts: postsReducer,\n    comments: commentsReducer,\n    users: usersReducer\n  }\n})\n\n// highlight-start\n// Get the type of our store variable\nexport type AppStore = typeof store\n// Infer the `RootState` and `AppDispatch` types from the store itself\nexport type RootState = ReturnType<AppStore['getState']>\n// Inferred type: {posts: PostsState, comments: CommentsState, users: UsersState}\nexport type AppDispatch = AppStore['dispatch']\n// highlight-end\n")),(0,i.yg)("h3",{id:"define-typed-hooks"},"Define Typed Hooks"),(0,i.yg)("p",null,"While it's possible to import the ",(0,i.yg)("inlineCode",{parentName:"p"},"RootState")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"AppDispatch")," types into each component, it's better to ",(0,i.yg)("strong",{parentName:"p"},"create pre-typed versions of the ",(0,i.yg)("inlineCode",{parentName:"strong"},"useDispatch")," and ",(0,i.yg)("inlineCode",{parentName:"strong"},"useSelector")," hooks for usage in your application"),". This is important for a couple reasons:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"For ",(0,i.yg)("inlineCode",{parentName:"li"},"useSelector"),", it saves you the need to type ",(0,i.yg)("inlineCode",{parentName:"li"},"(state: RootState)")," every time"),(0,i.yg)("li",{parentName:"ul"},"For ",(0,i.yg)("inlineCode",{parentName:"li"},"useDispatch"),", the default ",(0,i.yg)("inlineCode",{parentName:"li"},"Dispatch")," type does not know about thunks or other middleware. In order to correctly dispatch thunks, you need to use the specific customized ",(0,i.yg)("inlineCode",{parentName:"li"},"AppDispatch")," type from the store that includes the thunk middleware types, and use that with ",(0,i.yg)("inlineCode",{parentName:"li"},"useDispatch"),". Adding a pre-typed ",(0,i.yg)("inlineCode",{parentName:"li"},"useDispatch")," hook keeps you from forgetting to import ",(0,i.yg)("inlineCode",{parentName:"li"},"AppDispatch")," where it's needed.")),(0,i.yg)("p",null,"Since these are actual variables, not types, it's important to define them in a separate file such as ",(0,i.yg)("inlineCode",{parentName:"p"},"app/hooks.ts"),", not the store setup file. This allows you to import them into any component file that needs to use the hooks, and avoids potential circular import dependency issues."),(0,i.yg)("h4",{id:"withtypes"},(0,i.yg)("inlineCode",{parentName:"h4"},".withTypes()")),(0,i.yg)("p",null,'Previously, the approach for "pre-typing" hooks with your app setting was a little varied. The result would look something like the snippet below:'),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="app/hooks.ts"',title:'"app/hooks.ts"'},"import type { TypedUseSelectorHook } from 'react-redux'\nimport { useDispatch, useSelector, useStore } from 'react-redux'\nimport type { AppDispatch, AppStore, RootState } from './store'\n\n// highlight-start\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch: () => AppDispatch = useDispatch\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector\nexport const useAppStore: () => AppStore = useStore\n// highlight-end\n")),(0,i.yg)("p",null,"React Redux v9.1.0 adds a new ",(0,i.yg)("inlineCode",{parentName:"p"},".withTypes")," method to each of these hooks, analogous to the ",(0,i.yg)("a",{parentName:"p",href:"https://redux-toolkit.js.org/usage/usage-with-typescript#defining-a-pre-typed-createasyncthunk"},(0,i.yg)("inlineCode",{parentName:"a"},".withTypes"))," method found on Redux Toolkit's ",(0,i.yg)("inlineCode",{parentName:"p"},"createAsyncThunk"),"."),(0,i.yg)("p",null,"The setup now becomes:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="app/hooks.ts"',title:'"app/hooks.ts"'},"import { useDispatch, useSelector, useStore } from 'react-redux'\nimport type { AppDispatch, AppStore, RootState } from './store'\n\n// highlight-start\n// Use throughout your app instead of plain `useDispatch` and `useSelector`\nexport const useAppDispatch = useDispatch.withTypes<AppDispatch>()\nexport const useAppSelector = useSelector.withTypes<RootState>()\nexport const useAppStore = useStore.withTypes<AppStore>()\n// highlight-end\n")),(0,i.yg)("h2",{id:"application-usage"},"Application Usage"),(0,i.yg)("h3",{id:"define-slice-state-and-action-types"},"Define Slice State and Action Types"),(0,i.yg)("p",null,"Each slice file should define a type for its initial state value, so that ",(0,i.yg)("inlineCode",{parentName:"p"},"createSlice")," can correctly infer the type of ",(0,i.yg)("inlineCode",{parentName:"p"},"state")," in each case reducer."),(0,i.yg)("p",null,"All generated actions should be defined using the ",(0,i.yg)("inlineCode",{parentName:"p"},"PayloadAction<T>")," type from Redux Toolkit, which takes the type of the ",(0,i.yg)("inlineCode",{parentName:"p"},"action.payload")," field as its generic argument."),(0,i.yg)("p",null,"You can safely import the ",(0,i.yg)("inlineCode",{parentName:"p"},"RootState")," type from the store file here. It's a circular import, but the TypeScript compiler can correctly handle that for types. This may be needed for use cases like writing selector functions."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts",metastring:'title="features/counter/counterSlice.ts"',title:'"features/counter/counterSlice.ts"'},"import { createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport type { RootState } from '../../app/store'\n\n// highlight-start\n// Define a type for the slice state\ninterface CounterState {\n  value: number\n}\n\n// Define the initial state using that type\nconst initialState: CounterState = {\n  value: 0\n}\n// highlight-end\n\nexport const counterSlice = createSlice({\n  name: 'counter',\n  // `createSlice` will infer the state type from the `initialState` argument\n  initialState,\n  reducers: {\n    increment: state => {\n      state.value += 1\n    },\n    decrement: state => {\n      state.value -= 1\n    },\n    // highlight-start\n    // Use the PayloadAction type to declare the contents of `action.payload`\n    incrementByAmount: (state, action: PayloadAction<number>) => {\n      // highlight-end\n      state.value += action.payload\n    }\n  }\n})\n\nexport const { increment, decrement, incrementByAmount } = counterSlice.actions\n\n// Other code such as selectors can use the imported `RootState` type\nexport const selectCount = (state: RootState) => state.counter.value\n\nexport default counterSlice.reducer\n")),(0,i.yg)("p",null,"The generated action creators will be correctly typed to accept a ",(0,i.yg)("inlineCode",{parentName:"p"},"payload")," argument based on the ",(0,i.yg)("inlineCode",{parentName:"p"},"PayloadAction<T>")," type you provided for the reducer. For example, ",(0,i.yg)("inlineCode",{parentName:"p"},"incrementByAmount")," requires a ",(0,i.yg)("inlineCode",{parentName:"p"},"number")," as its argument."),(0,i.yg)("p",null,"In some cases, ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-toolkit/pull/827"},"TypeScript may unnecessarily tighten the type of the initial state"),". If that happens, you can work around it by casting the initial state using ",(0,i.yg)("inlineCode",{parentName:"p"},"as"),", instead of declaring the type of the variable:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"// Workaround: cast state instead of declaring variable type\nconst initialState = {\n  value: 0\n} as CounterState\n")),(0,i.yg)("h3",{id:"use-typed-hooks-in-components"},"Use Typed Hooks in Components"),(0,i.yg)("p",null,"In component files, import the pre-typed hooks instead of the standard hooks from React Redux."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-tsx",metastring:'title="features/counter/Counter.tsx"',title:'"features/counter/Counter.tsx"'},"import React, { useState } from 'react'\n\n// highlight-next-line\nimport { useAppSelector, useAppDispatch } from 'app/hooks'\n\nimport { decrement, increment } from './counterSlice'\n\nexport function Counter() {\n  // highlight-start\n  // The `state` arg is correctly typed as `RootState` already\n  const count = useAppSelector(state => state.counter.value)\n  const dispatch = useAppDispatch()\n  // highlight-end\n\n  // omit rendering logic\n}\n")),(0,i.yg)("admonition",{title:"Warn about wrong imports",type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"ESLint can help your team import the right hooks easily. The ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/typescript-eslint/typescript-eslint/blob/main/packages/eslint-plugin/docs/rules/no-restricted-imports.md"},"typescript-eslint/no-restricted-imports")," rule can show a warning when the wrong import is used accidentally."),(0,i.yg)("p",{parentName:"admonition"},"You could add this to your ESLint config as an example:"),(0,i.yg)("pre",{parentName:"admonition"},(0,i.yg)("code",{parentName:"pre",className:"language-json"},'"no-restricted-imports": "off",\n"@typescript-eslint/no-restricted-imports": [\n  "warn",\n  {\n    "name": "react-redux",\n    "importNames": ["useSelector", "useDispatch"],\n    "message": "Use typed hooks `useAppDispatch` and `useAppSelector` instead."\n  }\n],\n'))),(0,i.yg)("h2",{id:"typing-additional-redux-logic"},"Typing Additional Redux Logic"),(0,i.yg)("h3",{id:"type-checking-reducers"},"Type Checking Reducers"),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"/tutorials/fundamentals/part-3-state-actions-reducers"},"Reducers")," are pure functions that receive the current ",(0,i.yg)("inlineCode",{parentName:"p"},"state")," and incoming ",(0,i.yg)("inlineCode",{parentName:"p"},"action")," as arguments, and return a new state."),(0,i.yg)("p",null,"If you are using Redux Toolkit's ",(0,i.yg)("inlineCode",{parentName:"p"},"createSlice"),", you should rarely need to specifically type a reducer separately. If you do actually write a standalone reducer, it's typically sufficient to declare the type of the ",(0,i.yg)("inlineCode",{parentName:"p"},"initialState")," value, and type the ",(0,i.yg)("inlineCode",{parentName:"p"},"action")," as ",(0,i.yg)("inlineCode",{parentName:"p"},"UnknownAction"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"import { UnknownAction } from 'redux'\n\ninterface CounterState {\n  value: number\n}\n\nconst initialState: CounterState = {\n  value: 0\n}\n\nexport default function counterReducer(\n  state = initialState,\n  action: UnknownAction\n) {\n  // logic here\n}\n")),(0,i.yg)("p",null,"However, the Redux core does export a ",(0,i.yg)("inlineCode",{parentName:"p"},"Reducer<State, Action>")," type you can use as well."),(0,i.yg)("h3",{id:"type-checking-middleware"},"Type Checking Middleware"),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"/tutorials/fundamentals/part-4-store#middleware"},"Middleware")," are an extension mechanism for the Redux store. Middleware are composed into a pipeline that wrap the store's ",(0,i.yg)("inlineCode",{parentName:"p"},"dispatch")," method, and have access to the store's ",(0,i.yg)("inlineCode",{parentName:"p"},"dispatch")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"getState")," methods."),(0,i.yg)("p",null,"The Redux core exports a ",(0,i.yg)("inlineCode",{parentName:"p"},"Middleware")," type that can be used to correctly type a middleware function:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"export interface Middleware<\n  DispatchExt = {}, // optional override return behavior of `dispatch`\n  S = any, // type of the Redux store state\n  D extends Dispatch = Dispatch // type of the dispatch method\n>\n")),(0,i.yg)("p",null,"A custom middleware should use the ",(0,i.yg)("inlineCode",{parentName:"p"},"Middleware")," type, and pass the generic args for ",(0,i.yg)("inlineCode",{parentName:"p"},"S")," (state) and ",(0,i.yg)("inlineCode",{parentName:"p"},"D")," (dispatch) if needed:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"import { Middleware } from 'redux'\n\nimport { RootState } from '../store'\n\nexport const exampleMiddleware: Middleware<\n  {}, // Most middleware do not modify the dispatch return value\n  RootState\n> = storeApi => next => action => {\n  const state = storeApi.getState() // correctly typed as RootState\n}\n")),(0,i.yg)("admonition",{type:"caution"},(0,i.yg)("p",{parentName:"admonition"},"If you are using ",(0,i.yg)("inlineCode",{parentName:"p"},"typescript-eslint"),", the ",(0,i.yg)("inlineCode",{parentName:"p"},"@typescript-eslint/ban-types")," rule might report an error if you use ",(0,i.yg)("inlineCode",{parentName:"p"},"{}")," for the dispatch value. The recommended changes it makes are incorrect and will break your Redux store types, you should disable the rule for this line and keep using ",(0,i.yg)("inlineCode",{parentName:"p"},"{}"),".")),(0,i.yg)("p",null,"The dispatch generic should likely only be needed if you are dispatching additional thunks within the middleware."),(0,i.yg)("p",null,"In cases where ",(0,i.yg)("inlineCode",{parentName:"p"},"type RootState = ReturnType<typeof store.getState>")," is used, a ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/reduxjs/redux/issues/4267"},"circular type reference between the middleware and store definitions")," can be avoided by switching the type definition of ",(0,i.yg)("inlineCode",{parentName:"p"},"RootState")," to:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const rootReducer = combineReducers({ ... });\ntype RootState = ReturnType<typeof rootReducer>;\n")),(0,i.yg)("p",null,"Switching the type definition of ",(0,i.yg)("inlineCode",{parentName:"p"},"RootState")," with Redux Toolkit example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"//instead of defining the reducers in the reducer field of configureStore, combine them here:\nconst rootReducer = combineReducers({ counter: counterReducer })\n\n//then set rootReducer as the reducer object of configureStore\nconst store = configureStore({\n  reducer: rootReducer,\n  middleware: getDefaultMiddleware =>\n    getDefaultMiddleware().concat(yourMiddleware)\n})\n\ntype RootState = ReturnType<typeof rootReducer>\n")),(0,i.yg)("h3",{id:"type-checking-redux-thunks"},"Type Checking Redux Thunks"),(0,i.yg)("p",null,(0,i.yg)("a",{parentName:"p",href:"https://github.com/reduxjs/redux-thunk"},"Redux Thunk")," is the standard middleware for writing sync and async logic that interacts with the Redux store. A thunk function receives ",(0,i.yg)("inlineCode",{parentName:"p"},"dispatch")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"getState")," as its parameters. Redux Thunk has a built in ",(0,i.yg)("inlineCode",{parentName:"p"},"ThunkAction")," type which we can use to define types for those arguments:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'export type ThunkAction<\n  R, // Return type of the thunk function\n  S, // state type used by getState\n  E, // any "extra argument" injected into the thunk\n  A extends Action // known types of actions that can be dispatched\n> = (dispatch: ThunkDispatch<S, E, A>, getState: () => S, extraArgument: E) => R\n')),(0,i.yg)("p",null,"You will typically want to provide the ",(0,i.yg)("inlineCode",{parentName:"p"},"R")," (return type) and ",(0,i.yg)("inlineCode",{parentName:"p"},"S")," (state) generic arguments. Unfortunately, TS does not allow only providing ",(0,i.yg)("em",{parentName:"p"},"some")," generic arguments, so the usual values for the other arguments are ",(0,i.yg)("inlineCode",{parentName:"p"},"unknown")," for ",(0,i.yg)("inlineCode",{parentName:"p"},"E")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"UnknownAction")," for ",(0,i.yg)("inlineCode",{parentName:"p"},"A"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"import { UnknownAction } from 'redux'\nimport { sendMessage } from './store/chat/actions'\nimport { RootState } from './store'\nimport { ThunkAction } from 'redux-thunk'\n\nexport const thunkSendMessage =\n  (message: string): ThunkAction<void, RootState, unknown, UnknownAction> =>\n  async dispatch => {\n    const asyncResp = await exampleAPI()\n    dispatch(\n      sendMessage({\n        message,\n        user: asyncResp,\n        timestamp: new Date().getTime()\n      })\n    )\n  }\n\nfunction exampleAPI() {\n  return Promise.resolve('Async Chat Bot')\n}\n")),(0,i.yg)("p",null,"To reduce repetition, you might want to define a reusable ",(0,i.yg)("inlineCode",{parentName:"p"},"AppThunk")," type once, in your store file, and then use that type whenever you write a thunk:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"export type AppThunk<ReturnType = void> = ThunkAction<\n  ReturnType,\n  RootState,\n  unknown,\n  UnknownAction\n>\n")),(0,i.yg)("p",null,"Note that this assumes that there is no meaningful return value from the thunk. If your thunk returns a promise and you want to ",(0,i.yg)("a",{parentName:"p",href:"/tutorials/essentials/part-5-async-logic#checking-thunk-results-in-components"},"use the returned promise after dispatching the thunk"),", you'd want to use this as ",(0,i.yg)("inlineCode",{parentName:"p"},"AppThunk<Promise<SomeReturnType>>"),"."),(0,i.yg)("admonition",{type:"caution"},(0,i.yg)("p",{parentName:"admonition"},"Don't forget that ",(0,i.yg)("strong",{parentName:"p"},"the default ",(0,i.yg)("inlineCode",{parentName:"strong"},"useDispatch")," hook does not know about thunks"),", and so dispatching a thunk will cause a type error. Be sure to ",(0,i.yg)("a",{parentName:"p",href:"#define-root-state-and-dispatch-types"},"use an updated form of ",(0,i.yg)("inlineCode",{parentName:"a"},"Dispatch")," in your components that recognizes thunks as an acceptable type to dispatch"),".")),(0,i.yg)("h2",{id:"usage-with-react-redux"},"Usage with React Redux"),(0,i.yg)("p",null,"While ",(0,i.yg)("a",{parentName:"p",href:"https://react-redux.js.org"},"React Redux")," is a separate library from Redux itself, it is commonly used with React."),(0,i.yg)("p",null,"For a complete guide on how to correctly use React Redux with TypeScript, see ",(0,i.yg)("strong",{parentName:"p"},(0,i.yg)("a",{parentName:"strong",href:"https://react-redux.js.org/using-react-redux/static-typing"},'the "Static Typing" page in the React Redux docs')),". This section will highlight the standard patterns."),(0,i.yg)("p",null,"If you are using TypeScript, the React Redux types are maintained separately in DefinitelyTyped, but included as a dependency of the react-redux package, so they should be installed automatically. If you still need to install them manually, run:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-sh"},"npm install @types/react-redux\n")),(0,i.yg)("h3",{id:"typing-the-useselector-hook"},"Typing the ",(0,i.yg)("inlineCode",{parentName:"h3"},"useSelector")," hook"),(0,i.yg)("p",null,"Declare the type of the ",(0,i.yg)("inlineCode",{parentName:"p"},"state")," parameter in the selector function, and the return type of ",(0,i.yg)("inlineCode",{parentName:"p"},"useSelector")," will be inferred to match the return type of the selector:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"interface RootState {\n  isOn: boolean\n}\n\n// TS infers type: (state: RootState) => boolean\nconst selectIsOn = (state: RootState) => state.isOn\n\n// TS infers `isOn` is boolean\nconst isOn = useSelector(selectIsOn)\n")),(0,i.yg)("p",null,"This can also be done inline as well:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const isOn = useSelector((state: RootState) => state.isOn)\n")),(0,i.yg)("p",null,"However, prefer creating a pre-typed ",(0,i.yg)("inlineCode",{parentName:"p"},"useAppSelector")," hook with the correct type of ",(0,i.yg)("inlineCode",{parentName:"p"},"state")," built-in instead."),(0,i.yg)("h3",{id:"typing-the-usedispatch-hook"},"Typing the ",(0,i.yg)("inlineCode",{parentName:"h3"},"useDispatch")," hook"),(0,i.yg)("p",null,"By default, the return value of ",(0,i.yg)("inlineCode",{parentName:"p"},"useDispatch")," is the standard ",(0,i.yg)("inlineCode",{parentName:"p"},"Dispatch")," type defined by the Redux core types, so no declarations are needed:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const dispatch = useDispatch()\n")),(0,i.yg)("p",null,"However, prefer creating a pre-typed ",(0,i.yg)("inlineCode",{parentName:"p"},"useAppDispatch")," hook with the correct type of ",(0,i.yg)("inlineCode",{parentName:"p"},"Dispatch")," built-in instead."),(0,i.yg)("h3",{id:"typing-the-connect-higher-order-component"},"Typing the ",(0,i.yg)("inlineCode",{parentName:"h3"},"connect")," higher order component"),(0,i.yg)("p",null,"If you are still using ",(0,i.yg)("inlineCode",{parentName:"p"},"connect"),", you should use the ",(0,i.yg)("inlineCode",{parentName:"p"},"ConnectedProps<T>")," type exported by ",(0,i.yg)("inlineCode",{parentName:"p"},"@types/react-redux^7.1.2")," to infer the types of the props from ",(0,i.yg)("inlineCode",{parentName:"p"},"connect")," automatically. This requires splitting the ",(0,i.yg)("inlineCode",{parentName:"p"},"connect(mapState, mapDispatch)(MyComponent)")," call into two parts:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-tsx"},"import { connect, ConnectedProps } from 'react-redux'\n\ninterface RootState {\n  isOn: boolean\n}\n\nconst mapState = (state: RootState) => ({\n  isOn: state.isOn\n})\n\nconst mapDispatch = {\n  toggleOn: () => ({ type: 'TOGGLE_IS_ON' })\n}\n\nconst connector = connect(mapState, mapDispatch)\n\n// The inferred type will look like:\n// {isOn: boolean, toggleOn: () => void}\ntype PropsFromRedux = ConnectedProps<typeof connector>\n\ntype Props = PropsFromRedux & {\n  backgroundColor: string\n}\n\nconst MyComponent = (props: Props) => (\n  <div style={{ backgroundColor: props.backgroundColor }}>\n    <button onClick={props.toggleOn}>\n      Toggle is {props.isOn ? 'ON' : 'OFF'}\n    </button>\n  </div>\n)\n\nexport default connector(MyComponent)\n")),(0,i.yg)("h2",{id:"usage-with-redux-toolkit"},"Usage with Redux Toolkit"),(0,i.yg)("p",null,"The ",(0,i.yg)("a",{parentName:"p",href:"#standard-redux-toolkit-project-setup-with-typescript"},"Standard Redux Toolkit Project Setup with TypeScript")," section already covered the normal usage patterns for ",(0,i.yg)("inlineCode",{parentName:"p"},"configureStore")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"createSlice"),", and the ",(0,i.yg)("a",{parentName:"p",href:"https://redux-toolkit.js.org/usage/usage-with-typescript"},'Redux Toolkit "Usage with TypeScript" page')," covers all of the RTK APIs in detail."),(0,i.yg)("p",null,"Here are some additional typing patterns you will commonly see when using RTK."),(0,i.yg)("h3",{id:"typing-configurestore"},"Typing ",(0,i.yg)("inlineCode",{parentName:"h3"},"configureStore")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"configureStore")," infers the type of the state value from the provided root reducer function, so no specific type declarations should be needed."),(0,i.yg)("p",null,"If you want to add additional middleware to the store, be sure to use the specialized ",(0,i.yg)("inlineCode",{parentName:"p"},".concat()")," and ",(0,i.yg)("inlineCode",{parentName:"p"},".prepend()")," methods included in the array returned by ",(0,i.yg)("inlineCode",{parentName:"p"},"getDefaultMiddleware()"),", as those will correctly preserve the types of the middleware you're adding. (Using plain JS array spreads often loses those types.)"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const store = configureStore({\n  reducer: rootReducer,\n  middleware: getDefaultMiddleware =>\n    getDefaultMiddleware()\n      .prepend(\n        // correctly typed middlewares can just be used\n        additionalMiddleware,\n        // you can also type middlewares manually\n        untypedMiddleware as Middleware<\n          (action: Action<'specialAction'>) => number,\n          RootState\n        >\n      )\n      // prepend and concat calls can be chained\n      .concat(logger)\n})\n")),(0,i.yg)("h3",{id:"matching-actions"},"Matching Actions"),(0,i.yg)("p",null,"RTK-generated action creators have a ",(0,i.yg)("inlineCode",{parentName:"p"},"match")," method that acts as a ",(0,i.yg)("a",{parentName:"p",href:"https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates"},"type predicate"),". Calling ",(0,i.yg)("inlineCode",{parentName:"p"},"someActionCreator.match(action)")," will do a string comparison against the ",(0,i.yg)("inlineCode",{parentName:"p"},"action.type")," string, and if used as a condition, narrow the type of ",(0,i.yg)("inlineCode",{parentName:"p"},"action")," down to be the correct TS type:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const increment = createAction<number>('increment')\nfunction test(action: Action) {\n  if (increment.match(action)) {\n    // action.payload inferred correctly here\n    const num = 5 + action.payload\n  }\n}\n")),(0,i.yg)("p",null,"This is particularly useful when checking for action types in Redux middleware, such as custom middleware, ",(0,i.yg)("inlineCode",{parentName:"p"},"redux-observable"),", and RxJS's ",(0,i.yg)("inlineCode",{parentName:"p"},"filter")," method."),(0,i.yg)("h3",{id:"typing-createslice"},"Typing ",(0,i.yg)("inlineCode",{parentName:"h3"},"createSlice")),(0,i.yg)("h4",{id:"defining-separate-case-reducers"},"Defining Separate Case Reducers"),(0,i.yg)("p",null,"If you have too many case reducers and defining them inline would be messy, or you want to reuse case reducers across slices, you can also define them outside the ",(0,i.yg)("inlineCode",{parentName:"p"},"createSlice")," call and type them as ",(0,i.yg)("inlineCode",{parentName:"p"},"CaseReducer"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"type State = number\nconst increment: CaseReducer<State, PayloadAction<number>> = (state, action) =>\n  state + action.payload\n\ncreateSlice({\n  name: 'test',\n  initialState: 0,\n  reducers: {\n    increment\n  }\n})\n")),(0,i.yg)("h4",{id:"typing-extrareducers"},"Typing ",(0,i.yg)("inlineCode",{parentName:"h4"},"extraReducers")),(0,i.yg)("p",null,"If you are adding an ",(0,i.yg)("inlineCode",{parentName:"p"},"extraReducers")," field in ",(0,i.yg)("inlineCode",{parentName:"p"},"createSlice"),', be sure to use the "builder callback" form, as the "plain object" form cannot infer action types correctly. Passing an RTK-generated action creator to ',(0,i.yg)("inlineCode",{parentName:"p"},"builder.addCase()")," will correctly infer the type of the ",(0,i.yg)("inlineCode",{parentName:"p"},"action"),":"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const usersSlice = createSlice({\n  name: 'users',\n  initialState,\n  reducers: {\n    // fill in primary logic here\n  },\n  // highlight-start\n  extraReducers: builder => {\n    builder.addCase(fetchUserById.pending, (state, action) => {\n      // both `state` and `action` are now correctly typed\n      // based on the slice state and the `pending` action creator\n    })\n  }\n  // highlight-end\n})\n")),(0,i.yg)("h4",{id:"typing-prepare-callbacks"},"Typing ",(0,i.yg)("inlineCode",{parentName:"h4"},"prepare")," Callbacks"),(0,i.yg)("p",null,"If you want to add a ",(0,i.yg)("inlineCode",{parentName:"p"},"meta")," or ",(0,i.yg)("inlineCode",{parentName:"p"},"error")," property to your action, or customize the ",(0,i.yg)("inlineCode",{parentName:"p"},"payload")," of your action, you have to use the ",(0,i.yg)("inlineCode",{parentName:"p"},"prepare")," notation for defining the case reducer. Using this notation with TypeScript looks like:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const blogSlice = createSlice({\n  name: 'blogData',\n  initialState,\n  reducers: {\n    // highlight-start\n    receivedAll: {\n      reducer(\n        state,\n        action: PayloadAction<Page[], string, { currentPage: number }>\n      ) {\n        state.all = action.payload\n        state.meta = action.meta\n      },\n      prepare(payload: Page[], currentPage: number) {\n        return { payload, meta: { currentPage } }\n      }\n    }\n    // highlight-end\n  }\n})\n")),(0,i.yg)("h4",{id:"fixing-circular-types-in-exported-slices"},"Fixing Circular Types in Exported Slices"),(0,i.yg)("p",null,"Finally, on rare occasions you might need to export the slice reducer with a specific type in order to break a circular type dependency problem. This might look like:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"export default counterSlice.reducer as Reducer<Counter>\n")),(0,i.yg)("h3",{id:"typing-createasyncthunk"},"Typing ",(0,i.yg)("inlineCode",{parentName:"h3"},"createAsyncThunk")),(0,i.yg)("p",null,"For basic usage, the only type you need to provide for ",(0,i.yg)("inlineCode",{parentName:"p"},"createAsyncThunk")," is the type of the single argument for your payload creation callback. You should also ensure that the return value of the callback is typed correctly:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},'const fetchUserById = createAsyncThunk(\n  \'users/fetchById\',\n  // Declare the type your function argument here:\n  // highlight-next-line\n  async (userId: number) => {\n    const response = await fetch(`https://reqres.in/api/users/${userId}`)\n    // Inferred return type: Promise<MyData>\n    // highlight-next-line\n    return (await response.json()) as MyData\n  }\n)\n\n// the parameter of `fetchUserById` is automatically inferred to `number` here\n// and dispatching the resulting thunkAction will return a Promise of a correctly\n// typed "fulfilled" or "rejected" action.\nconst lastReturnedAction = await store.dispatch(fetchUserById(3))\n')),(0,i.yg)("p",null,"If you need to modify the types of the ",(0,i.yg)("inlineCode",{parentName:"p"},"thunkApi")," parameter, such as supplying the type of the ",(0,i.yg)("inlineCode",{parentName:"p"},"state")," returned by ",(0,i.yg)("inlineCode",{parentName:"p"},"getState()"),', you must supply the first two generic arguments for return type and payload argument, plus whichever "thunkApi argument fields" are relevant in an object:'),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const fetchUserById = createAsyncThunk<\n  //highlight-start\n  // Return type of the payload creator\n  MyData,\n  // First argument to the payload creator\n  number,\n  {\n    // Optional fields for defining thunkApi field types\n    dispatch: AppDispatch\n    state: State\n    extra: {\n      jwt: string\n    }\n  }\n  // highlight-end\n>('users/fetchById', async (userId, thunkApi) => {\n  const response = await fetch(`https://reqres.in/api/users/${userId}`, {\n    headers: {\n      Authorization: `Bearer ${thunkApi.extra.jwt}`\n    }\n  })\n  return (await response.json()) as MyData\n})\n")),(0,i.yg)("h3",{id:"typing-createentityadapter"},"Typing ",(0,i.yg)("inlineCode",{parentName:"h3"},"createEntityAdapter")),(0,i.yg)("p",null,"Usage of ",(0,i.yg)("inlineCode",{parentName:"p"},"createEntityAdapter")," with Typescript varies based on whether your entities are normalized by an ",(0,i.yg)("inlineCode",{parentName:"p"},"id")," property, or whether a custom ",(0,i.yg)("inlineCode",{parentName:"p"},"selectId")," is needed."),(0,i.yg)("p",null,"If your entities are normalized by an ",(0,i.yg)("inlineCode",{parentName:"p"},"id")," property, ",(0,i.yg)("inlineCode",{parentName:"p"},"createEntityAdapter")," only requires you to specify the entity type as the single generic argument. For example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"interface Book {\n  id: number\n  title: string\n}\n\n// no selectId needed here, as the entity has an `id` property we can default to\n// highlight-next-line\nconst booksAdapter = createEntityAdapter<Book>({\n  sortComparer: (a, b) => a.title.localeCompare(b.title)\n})\n\nconst booksSlice = createSlice({\n  name: 'books',\n  // highlight-start\n  // The type of the state is inferred here\n  initialState: booksAdapter.getInitialState(),\n  // highlight-end\n  reducers: {\n    bookAdded: booksAdapter.addOne,\n    booksReceived(state, action: PayloadAction<{ books: Book[] }>) {\n      booksAdapter.setAll(state, action.payload.books)\n    }\n  }\n})\n")),(0,i.yg)("p",null,"On the other hand, if the entity needs to be normalized by a different property, we instead recommend passing a custom ",(0,i.yg)("inlineCode",{parentName:"p"},"selectId")," function and annotating there. This allows proper inference of the ID's type, instead of having to provide it manually."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"interface Book {\n  bookId: number\n  title: string\n  // ...\n}\n\nconst booksAdapter = createEntityAdapter({\n  // highlight-next-line\n  selectId: (book: Book) => book.bookId,\n  sortComparer: (a, b) => a.title.localeCompare(b.title)\n})\n\nconst booksSlice = createSlice({\n  name: 'books',\n  // highlight-start\n  // The type of the state is inferred here\n  initialState: booksAdapter.getInitialState(),\n  // highlight-end\n  reducers: {\n    bookAdded: booksAdapter.addOne,\n    booksReceived(state, action: PayloadAction<{ books: Book[] }>) {\n      booksAdapter.setAll(state, action.payload.books)\n    }\n  }\n})\n")),(0,i.yg)("h2",{id:"additional-recommendations"},"Additional Recommendations"),(0,i.yg)("h3",{id:"use-the-react-redux-hooks-api"},"Use the React Redux Hooks API"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"We recommend using the React Redux hooks API as the default approach"),". The hooks API is much simpler to use with TypeScript, as ",(0,i.yg)("inlineCode",{parentName:"p"},"useSelector")," is a simple hook that takes a selector function, and the return type is easily inferred from the type of the ",(0,i.yg)("inlineCode",{parentName:"p"},"state")," argument."),(0,i.yg)("p",null,"While ",(0,i.yg)("inlineCode",{parentName:"p"},"connect")," still works fine, and ",(0,i.yg)("em",{parentName:"p"},"can")," be typed, it's much more difficult to type correctly."),(0,i.yg)("h3",{id:"avoid-action-type-unions"},"Avoid Action Type Unions"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"We specifically recommend ",(0,i.yg)("em",{parentName:"strong"},"against")," trying to create unions of action types"),", as it provides no real benefit and actually misleads the compiler in some ways. See RTK maintainer Lenz Weber's post ",(0,i.yg)("a",{parentName:"p",href:"https://phryneas.de/redux-typescript-no-discriminating-union"},"Do Not Create Union Types with Redux Action Types")," for an explanation of why this is a problem."),(0,i.yg)("p",null,"In addition, if you're using ",(0,i.yg)("inlineCode",{parentName:"p"},"createSlice"),", you already know that all actions defined by that slice are being handled correctly."),(0,i.yg)("h2",{id:"resources"},"Resources"),(0,i.yg)("p",null,"For further information, see these additional resources:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Redux library documentation:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://react-redux.js.org/using-react-redux/static-typing"},"React Redux docs: Static Typing"),": Examples of how to use the React Redux APIs with TypeScript"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://redux-toolkit.js.org/usage/usage-with-typescript"},"Redux Toolkit docs: Usage with TypeScript"),": Examples of how to use the Redux Toolkit APIs with TypeScript"))),(0,i.yg)("li",{parentName:"ul"},"React + Redux + TypeScript guides:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/typescript-cheatsheets/react-typescript-cheatsheet"},"React+TypeScript Cheatsheet"),": a comprehensive guide to using React with TypeScript"),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/piotrwitek/react-redux-typescript-guide"},"React + Redux in TypeScript Guide"),": extensive information on patterns for using React and Redux with TypeScript",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("em",{parentName:"li"},"Note: while this guide has some useful info, many of the patterns it shows go against our recommended practices shown in this page, such as using action type unions. We link this out of completeness")))))),(0,i.yg)("li",{parentName:"ul"},"Other articles:",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://phryneas.de/redux-typescript-no-discriminating-union"},"Do Not Create Union Types with Redux Action Types")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://www.matthewgerstman.com/tech/redux-code-split-typecheck/"},"Redux with Code-Splitting and Type Checking"))))))}u.isMDXComponent=!0},5680:(e,t,n)=>{n.d(t,{xA:()=>c,yg:()=>g});var a=n(6540);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),l=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(p.Provider,{value:t},e.children)},d="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},y=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=l(n),y=i,g=d["".concat(p,".").concat(y)]||d[y]||u[y]||r;return n?a.createElement(g,o(o({ref:t},c),{},{components:n})):a.createElement(g,o({ref:t},c))}));function g(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=y;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}y.displayName="MDXCreateElement"}}]);