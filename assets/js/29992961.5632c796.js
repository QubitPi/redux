"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7278],{7523:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>c,toc:()=>l});var r=t(8168),i=(t(6540),t(5680));const a={id:"code-splitting",title:"Code Splitting"},o="Code Splitting",c={unversionedId:"usage/code-splitting",id:"usage/code-splitting",title:"Code Splitting",description:"In large web applications, it is often desirable to split up the app code into multiple JS bundles that can be loaded on-demand. This strategy, called 'code splitting', helps to increase performance of your application by reducing the size of the initial JS payload that must be fetched.",source:"@site/../docs/usage/CodeSplitting.md",sourceDirName:"usage",slug:"/usage/code-splitting",permalink:"/usage/code-splitting",draft:!1,editUrl:"https://github.com/reduxjs/redux/edit/master/website/../docs/usage/CodeSplitting.md",tags:[],version:"current",lastUpdatedAt:1737618502,formattedLastUpdatedAt:"Jan 23, 2025",frontMatter:{id:"code-splitting",title:"Code Splitting"},sidebar:"docs",previous:{title:"Setup with Next.js",permalink:"/usage/nextjs"},next:{title:"Server Rendering",permalink:"/usage/server-rendering"}},d={},l=[{value:"Basic Principle",id:"basic-principle",level:2},{value:"Using <code>replaceReducer</code>",id:"using-replacereducer",level:3},{value:"Reducer Injection Approaches",id:"reducer-injection-approaches",level:2},{value:"Defining an <code>injectReducer</code> function",id:"defining-an-injectreducer-function",level:3},{value:"Using a &#39;Reducer Manager&#39;",id:"using-a-reducer-manager",level:3},{value:"Redux Toolkit",id:"redux-toolkit",level:2},{value:"<code>combineSlices</code>",id:"combineslices",level:3},{value:"Slice injection",id:"slice-injection",level:4},{value:"Declaring lazy loaded slices",id:"declaring-lazy-loaded-slices",level:4},{value:"Selector utilities",id:"selector-utilities",level:4},{value:"Typical usage",id:"typical-usage",level:4},{value:"<code>createDynamicMiddleware</code>",id:"createdynamicmiddleware",level:3},{value:"<code>addMiddleware</code>",id:"addmiddleware",level:4},{value:"<code>withMiddleware</code>",id:"withmiddleware",level:4},{value:"React integration",id:"react-integration",level:4},{value:"<code>createDispatchWithMiddlewareHook</code>",id:"createdispatchwithmiddlewarehook",level:5},{value:"<code>createDispatchWithMiddlewareHookFactory</code>",id:"createdispatchwithmiddlewarehookfactory",level:5},{value:"Third-party Libraries and Frameworks",id:"third-party-libraries-and-frameworks",level:2}],s={toc:l},u="wrapper";function p(e){let{components:n,...t}=e;return(0,i.yg)(u,(0,r.A)({},s,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"code-splitting"},"Code Splitting"),(0,i.yg)("p",null,"In large web applications, it is often desirable to split up the app code into multiple JS bundles that can be loaded on-demand. This strategy, called 'code splitting', helps to increase performance of your application by reducing the size of the initial JS payload that must be fetched."),(0,i.yg)("p",null,"To code split with Redux, we want to be able to dynamically add reducers to the store. However, Redux really only has a single root reducer function. This root reducer is normally generated by calling ",(0,i.yg)("inlineCode",{parentName:"p"},"combineReducers()")," or a similar function when the application is initialized. In order to dynamically add more reducers, we need to call that function again to re-generate the root reducer. Below, we discuss some approaches to solving this problem and reference two libraries that provide this functionality."),(0,i.yg)("h2",{id:"basic-principle"},"Basic Principle"),(0,i.yg)("h3",{id:"using-replacereducer"},"Using ",(0,i.yg)("inlineCode",{parentName:"h3"},"replaceReducer")),(0,i.yg)("p",null,"The Redux store exposes a ",(0,i.yg)("inlineCode",{parentName:"p"},"replaceReducer")," function, which replaces the current active root reducer function with a new root reducer function. Calling it will swap the internal reducer function reference, and dispatch an action to help any newly-added slice reducers initialize themselves:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"const newRootReducer = combineReducers({\n  existingSlice: existingSliceReducer,\n  newSlice: newSliceReducer\n})\n\nstore.replaceReducer(newRootReducer)\n")),(0,i.yg)("h2",{id:"reducer-injection-approaches"},"Reducer Injection Approaches"),(0,i.yg)("p",null,"This section will cover some handwritten recipes used to inject reducers."),(0,i.yg)("h3",{id:"defining-an-injectreducer-function"},"Defining an ",(0,i.yg)("inlineCode",{parentName:"h3"},"injectReducer")," function"),(0,i.yg)("p",null,"We will likely want to call ",(0,i.yg)("inlineCode",{parentName:"p"},"store.replaceReducer()")," from anywhere in the application. Because of that, it's helpful\nto define a reusable ",(0,i.yg)("inlineCode",{parentName:"p"},"injectReducer()")," function that keeps references to all of the existing slice reducers, and attach\nthat to the store instance."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"import { createStore } from 'redux'\n\n// Define the Reducers that will always be present in the application\nconst staticReducers = {\n  users: usersReducer,\n  posts: postsReducer\n}\n\n// Configure the store\nexport default function configureStore(initialState) {\n  const store = createStore(createReducer(), initialState)\n\n  // Add a dictionary to keep track of the registered async reducers\n  store.asyncReducers = {}\n\n  // Create an inject reducer function\n  // This function adds the async reducer, and creates a new combined reducer\n  store.injectReducer = (key, asyncReducer) => {\n    store.asyncReducers[key] = asyncReducer\n    store.replaceReducer(createReducer(store.asyncReducers))\n  }\n\n  // Return the modified store\n  return store\n}\n\nfunction createReducer(asyncReducers) {\n  return combineReducers({\n    ...staticReducers,\n    ...asyncReducers\n  })\n}\n")),(0,i.yg)("p",null,"Now, one just needs to call ",(0,i.yg)("inlineCode",{parentName:"p"},"store.injectReducer")," to add a new reducer to the store."),(0,i.yg)("h3",{id:"using-a-reducer-manager"},"Using a 'Reducer Manager'"),(0,i.yg)("p",null,"Another approach is to create a 'Reducer Manager' object, which keeps track of all the registered reducers and exposes a ",(0,i.yg)("inlineCode",{parentName:"p"},"reduce()")," function. Consider the following example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-js"},"export function createReducerManager(initialReducers) {\n  // Create an object which maps keys to reducers\n  const reducers = { ...initialReducers }\n\n  // Create the initial combinedReducer\n  let combinedReducer = combineReducers(reducers)\n\n  // An array which is used to delete state keys when reducers are removed\n  let keysToRemove = []\n\n  return {\n    getReducerMap: () => reducers,\n\n    // The root reducer function exposed by this object\n    // This will be passed to the store\n    reduce: (state, action) => {\n      // If any reducers have been removed, clean up their state first\n      if (keysToRemove.length > 0) {\n        state = { ...state }\n        for (let key of keysToRemove) {\n          delete state[key]\n        }\n        keysToRemove = []\n      }\n\n      // Delegate to the combined reducer\n      return combinedReducer(state, action)\n    },\n\n    // Adds a new reducer with the specified key\n    add: (key, reducer) => {\n      if (!key || reducers[key]) {\n        return\n      }\n\n      // Add the reducer to the reducer mapping\n      reducers[key] = reducer\n\n      // Generate a new combined reducer\n      combinedReducer = combineReducers(reducers)\n    },\n\n    // Removes a reducer with the specified key\n    remove: key => {\n      if (!key || !reducers[key]) {\n        return\n      }\n\n      // Remove it from the reducer mapping\n      delete reducers[key]\n\n      // Add the key to the list of keys to clean up\n      keysToRemove.push(key)\n\n      // Generate a new combined reducer\n      combinedReducer = combineReducers(reducers)\n    }\n  }\n}\n\nconst staticReducers = {\n  users: usersReducer,\n  posts: postsReducer\n}\n\nexport function configureStore(initialState) {\n  const reducerManager = createReducerManager(staticReducers)\n\n  // Create a store with the root reducer function being the one exposed by the manager.\n  const store = createStore(reducerManager.reduce, initialState)\n\n  // Optional: Put the reducer manager on the store so it is easily accessible\n  store.reducerManager = reducerManager\n}\n")),(0,i.yg)("p",null,"To add a new reducer, one can now call ",(0,i.yg)("inlineCode",{parentName:"p"},'store.reducerManager.add("asyncState", asyncReducer)'),"."),(0,i.yg)("p",null,"To remove a reducer, one can now call ",(0,i.yg)("inlineCode",{parentName:"p"},'store.reducerManager.remove("asyncState")')),(0,i.yg)("h2",{id:"redux-toolkit"},"Redux Toolkit"),(0,i.yg)("p",null,"Redux Toolkit 2.0 includes some utilities designed to simplify code splitting with reducers and middleware, including solid Typescript support (a common challenge with lazy loaded reducers and middleware)."),(0,i.yg)("h3",{id:"combineslices"},(0,i.yg)("inlineCode",{parentName:"h3"},"combineSlices")),(0,i.yg)("p",null,"The ",(0,i.yg)("a",{parentName:"p",href:"https://redux-toolkit.js.org/api/combineSlices"},(0,i.yg)("inlineCode",{parentName:"a"},"combineSlices"))," utility is designed to allow for easy reducer injection. It also supercedes ",(0,i.yg)("inlineCode",{parentName:"p"},"combineReducers"),", in that it can be used to combine multiple slices and reducers into one root reducer."),(0,i.yg)("p",null,"At setup it accepts a set of slices and reducer maps, and returns a reducer instance with attached methods for injection."),(0,i.yg)("admonition",{type:"note"},(0,i.yg)("p",{parentName:"admonition"},'A "slice" for ',(0,i.yg)("inlineCode",{parentName:"p"},"combineSlices")," is typically created with ",(0,i.yg)("inlineCode",{parentName:"p"},"createSlice"),', but can be any "slice-like" object with ',(0,i.yg)("inlineCode",{parentName:"p"},"reducerPath")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"reducer")," properties (meaning RTK Query API instances are also compatible)."),(0,i.yg)("pre",{parentName:"admonition"},(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const withUserReducer = rootReducer.inject({\n  reducerPath: 'user',\n  reducer: userReducer\n})\n\nconst withApiReducer = rootReducer.inject(fooApi)\n")),(0,i.yg)("p",{parentName:"admonition"},"For simplicity, this ",(0,i.yg)("inlineCode",{parentName:"p"},"{ reducerPath, reducer }"),' shape will be described in these docs as a "slice".')),(0,i.yg)("p",null,"Slices will be mounted at their ",(0,i.yg)("inlineCode",{parentName:"p"},"reducerPath"),", and items from reducer map objects will be mounted under their respective key."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const rootReducer = combineSlices(counterSlice, baseApi, {\n  user: userSlice.reducer,\n  auth: authSlice.reducer\n})\n// is like\nconst rootReducer = combineReducers({\n  [counterSlice.reducerPath]: counterSlice.reducer,\n  [baseApi.reducerPath]: baseApi.reducer,\n  user: userSlice.reducer,\n  auth: authSlice.reducer\n})\n")),(0,i.yg)("admonition",{type:"caution"},(0,i.yg)("p",{parentName:"admonition"},"Be careful to avoid naming collision - later keys will overwrite earlier ones, but Typescript won't be able to account for this.")),(0,i.yg)("h4",{id:"slice-injection"},"Slice injection"),(0,i.yg)("p",null,"To inject a slice, you should call ",(0,i.yg)("inlineCode",{parentName:"p"},"rootReducer.inject(slice)")," on the reducer instance returned from ",(0,i.yg)("inlineCode",{parentName:"p"},"combineSlices"),". This will inject the slice under its ",(0,i.yg)("inlineCode",{parentName:"p"},"reducerPath")," into the set of reducers, and return an instance of the combined reducer typed to know that the slice has been injected."),(0,i.yg)("p",null,"Alternatively, you can call ",(0,i.yg)("inlineCode",{parentName:"p"},"slice.injectInto(rootReducer)"),", which returns an instance of the slice which is aware it's been injected. You may even want to do both, as each call returns something useful, and ",(0,i.yg)("inlineCode",{parentName:"p"},"combineSlices")," allows injection of the same reducer instance at the same ",(0,i.yg)("inlineCode",{parentName:"p"},"reducerPath")," without issue."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const withCounterSlice = rootReducer.inject(counterSlice)\nconst injectedCounterSlice = counterSlice.injectInto(rootReducer)\n")),(0,i.yg)("p",null,"One key difference between typical reducer injection and ",(0,i.yg)("inlineCode",{parentName:"p"},"combineSlice"),'\'s "meta-reducer" approach is that ',(0,i.yg)("inlineCode",{parentName:"p"},"replaceReducer")," is never called for ",(0,i.yg)("inlineCode",{parentName:"p"},"combineSlice"),". The reducer instance passed to the store doesn't change."),(0,i.yg)("p",null,"A consequence of this is that no action is dispatched when a slice is injected, and therefore the injected slice's state doesn't show in state immediately. The state will only show in the store's state when an action is dispatched."),(0,i.yg)("p",null,"However, to avoid selectors having to account for possibly ",(0,i.yg)("inlineCode",{parentName:"p"},"undefined")," state, ",(0,i.yg)("inlineCode",{parentName:"p"},"combineSlices")," includes some useful ",(0,i.yg)("a",{parentName:"p",href:"#selector-utilities"},"selector utilities"),"."),(0,i.yg)("h4",{id:"declaring-lazy-loaded-slices"},"Declaring lazy loaded slices"),(0,i.yg)("p",null,"In order for lazy loaded slices to show up in the inferred state type, a ",(0,i.yg)("inlineCode",{parentName:"p"},"withLazyLoadedSlices")," helper is provided. This allows you to declare slices you intend to later inject, so they can show up as optional in the state type."),(0,i.yg)("p",null,"To completely avoid importing the lazy slice into the combined reducer's file, module augmentation can be used."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"// file: reducer.ts\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { staticSlice } from './staticSlice'\n\nexport interface LazyLoadedSlices {}\n\nexport const rootReducer =\n  combineSlices(staticSlice).withLazyLoadedSlices<LazyLoadedSlices>()\n\n// file: counterSlice.ts\nimport type { WithSlice } from '@reduxjs/toolkit'\nimport { createSlice } from '@reduxjs/toolkit'\nimport { rootReducer } from './reducer'\n\ninterface CounterState {\n  value: number\n}\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 } as CounterState,\n  reducers: {\n    increment: state => void state.value++\n  },\n  selectors: {\n    selectValue: state => state.value\n  }\n})\n\ndeclare module './reducer' {\n  // WithSlice utility assumes reducer is under slice.reducerPath\n  export interface LazyLoadedSlices extends WithSlice<typeof counterSlice> {}\n\n  // if it's not, just use a normal key\n  export interface LazyLoadedSlices {\n    aCounter: CounterState\n  }\n}\n\nconst injectedCounterSlice = counterSlice.injectInto(rootReducer)\nconst injectedACounterSlice = counterSlice.injectInto(rootReducer, {\n  reducerPath: 'aCounter'\n})\n")),(0,i.yg)("h4",{id:"selector-utilities"},"Selector utilities"),(0,i.yg)("p",null,"As well as ",(0,i.yg)("inlineCode",{parentName:"p"},"inject"),", the combined reducer instance has a ",(0,i.yg)("inlineCode",{parentName:"p"},".selector")," method which can be used to wrap selectors. It wraps the state object in a ",(0,i.yg)("inlineCode",{parentName:"p"},"Proxy"),", and provides an initial state for any reducers which have been injected but haven't appeared in state yet."),(0,i.yg)("p",null,"The result of calling ",(0,i.yg)("inlineCode",{parentName:"p"},"inject")," is typed to know that the injected slice will always be defined when the selector is called."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const selectCounterValue = (state: RootState) => state.counter?.value // number | undefined\n\nconst withCounterSlice = rootReducer.inject(counterSlice)\nconst selectCounterValue = withCounterSlice.selector(\n  state => state.counter.value // number - initial state used if not in store\n)\n")),(0,i.yg)("p",null,'An "injected" instance of a slice will do the same thing for slice selectors - initial state will be provided if not present in the state passed.'),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const injectedCounterSlice = counterSlice.injectInto(rootReducer)\n\nconsole.log(counterSlice.selectors.selectValue({})) // runtime error\nconsole.log(injectedCounterSlice.selectors.selectValue({})) // 0\n")),(0,i.yg)("h4",{id:"typical-usage"},"Typical usage"),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"combineSlices")," is designed so that the slice is injected as soon as it's needed (i.e. a selector or action is imported from a component that's been loaded in)."),(0,i.yg)("p",null,"This means that the typical usage will look something along the lines of the below."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"// file: reducer.ts\nimport { combineSlices } from '@reduxjs/toolkit'\nimport { staticSlice } from './staticSlice'\n\nexport interface LazyLoadedSlices {}\n\nexport const rootReducer =\n  combineSlices(staticSlice).withLazyLoadedSlices<LazyLoadedSlices>()\n\n// file: store.ts\nimport { configureStore } from '@reduxjs/toolkit'\nimport { rootReducer } from './reducer'\n\nexport const store = configureStore({ reducer: rootReducer })\n\n// file: counterSlice.ts\nimport type { WithSlice } from '@reduxjs/toolkit'\nimport { createSlice } from '@reduxjs/toolkit'\nimport { rootReducer } from './reducer'\n\nconst counterSlice = createSlice({\n  name: 'counter',\n  initialState: { value: 0 },\n  reducers: {\n    increment: state => void state.value++\n  },\n  selectors: {\n    selectValue: state => state.value\n  }\n})\n\nexport const { increment } = counterSlice.actions\n\ndeclare module './reducer' {\n  export interface LazyLoadedSlices extends WithSlice<typeof counterSlice> {}\n}\n\nconst injectedCounterSlice = counterSlice.injectInto(rootReducer)\n\nexport const { selectValue } = injectedCounterSlice.selectors\n\n// file: Counter.tsx\n// by importing from counterSlice we guarantee\n// the injection happens before this component is defined\nimport { increment, selectValue } from './counterSlice'\nimport { useAppDispatch, useAppSelector } from './hooks'\n\nexport default function Counter() {\n  const dispatch = usAppDispatch()\n  const value = useAppSelector(selectValue)\n  return (\n    <>\n      <p>{value}</p>\n      <button onClick={() => dispatch(increment())}>Increment</button>\n    </>\n  )\n}\n\n// file: App.tsx\nimport { Provider } from 'react-redux'\nimport { store } from './store'\n\n// lazily importing the component means that the code\n// doesn't actually get pulled in and executed until the component is rendered.\n// this means that the inject call only happens once Counter renders\nconst Counter = React.lazy(() => import('./Counter'))\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <Counter />\n    </Provider>\n  )\n}\n")),(0,i.yg)("h3",{id:"createdynamicmiddleware"},(0,i.yg)("inlineCode",{parentName:"h3"},"createDynamicMiddleware")),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"createDynamicMiddleware"),' utility creates a "meta-middleware" which allows for injection of middleware after store initialisation.'),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"import { createDynamicMiddleware, configureStore } from '@reduxjs/toolkit'\nimport logger from 'redux-logger'\nimport reducer from './reducer'\n\nconst dynamicMiddleware = createDynamicMiddleware()\n\nconst store = configureStore({\n  reducer,\n  middleware: getDefaultMiddleware =>\n    getDefaultMiddleware().concat(dynamicMiddleware.middleware)\n})\n\ndynamicMiddleware.addMiddleware(logger)\n")),(0,i.yg)("h4",{id:"addmiddleware"},(0,i.yg)("inlineCode",{parentName:"h4"},"addMiddleware")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"addMiddleware")," appends the middleware instance to the chain of middlewares handled by the dynamic middleware instance. Middleware is applied in injection order, and stored by function reference (so the same middleware is only applied once regardless of how many times it's injected)."),(0,i.yg)("admonition",{type:"note"},(0,i.yg)("p",{parentName:"admonition"},"It's important to remember that all middlewares injected will be contained ",(0,i.yg)("em",{parentName:"p"},"within")," the original dynamic middleware instance."),(0,i.yg)("pre",{parentName:"admonition"},(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"import { createDynamicMiddleware, configureStore } from '@reduxjs/toolkit'\nimport logger from 'redux-logger'\nimport reducer from './reducer'\n\nconst dynamicMiddleware = createDynamicMiddleware()\n\nconst store = configureStore({\n  reducer,\n  middleware: getDefaultMiddleware =>\n    getDefaultMiddleware().concat(dynamicMiddleware.middleware)\n})\n\ndynamicMiddleware.addMiddleware(logger)\n\n// middleware chain is now [thunk, logger]\n")),(0,i.yg)("p",{parentName:"admonition"},"If it's desired to have more control over the order, multiple instances can be used."),(0,i.yg)("pre",{parentName:"admonition"},(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"import { createDynamicMiddleware, configureStore } from '@reduxjs/toolkit'\nimport logger from 'redux-logger'\nimport reducer from './reducer'\n\nconst beforeMiddleware = createDynamicMiddleware()\nconst afterMiddleware = createDynamicMiddleware()\n\nconst store = configureStore({\n  reducer,\n  middleware: getDefaultMiddleware =>\n    getDefaultMiddleware()\n      .prepend(beforeMiddleware.middleware)\n      .concat(afterMiddleware.middleware)\n})\n\nbeforeMiddleware.addMiddleware(logger)\nafterMiddleware.addMiddleware(logger)\n\n// middleware chain is now [logger, thunk, logger]\n"))),(0,i.yg)("h4",{id:"withmiddleware"},(0,i.yg)("inlineCode",{parentName:"h4"},"withMiddleware")),(0,i.yg)("p",null,(0,i.yg)("inlineCode",{parentName:"p"},"withMiddleware")," is an action creator which, when dispatched, causes the middleware to add any middlewares included and returns a pre-typed version of ",(0,i.yg)("inlineCode",{parentName:"p"},"dispatch")," with any added extensions."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"const listenerDispatch = store.dispatch(\n  withMiddleware(listenerMiddleware.middleware)\n)\n\nconst unsubscribe = listenerDispatch(addListener({ actionCreator, effect }))\n//    ^? () => void\n")),(0,i.yg)("p",null,"This is mainly useful in a non-React context. With React it's more useful to use the ",(0,i.yg)("a",{parentName:"p",href:"#react-integration"},"react integration"),"."),(0,i.yg)("h4",{id:"react-integration"},"React integration"),(0,i.yg)("p",null,"When imported from the ",(0,i.yg)("inlineCode",{parentName:"p"},"@reduxjs/toolkit/react")," entry point, the instance of dynamic middleware will have a couple of additional methods attached."),(0,i.yg)("h5",{id:"createdispatchwithmiddlewarehook"},(0,i.yg)("inlineCode",{parentName:"h5"},"createDispatchWithMiddlewareHook")),(0,i.yg)("p",null,"This method calls ",(0,i.yg)("inlineCode",{parentName:"p"},"addMiddleware")," and returns a version of ",(0,i.yg)("inlineCode",{parentName:"p"},"useDispatch")," typed to know about the injected middleware."),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"import { createDynamicMiddleware } from '@reduxjs/toolkit/react'\n\nconst dynamicMiddleware = createDynamicMiddleware()\n\nconst useListenerDispatch = dynamicMiddleware.createDispatchWithMiddlewareHook(\n  listenerMiddleware.middleware\n)\n\nfunction Component() {\n  const dispatch = useListenerDispatch()\n\n  useEffect(() => {\n    const unsubscribe = dispatch(addListener({ actionCreator, effect }))\n    return unsubscribe\n  }, [dispatch])\n}\n")),(0,i.yg)("admonition",{type:"caution"},(0,i.yg)("p",{parentName:"admonition"},"Middleware is injected when ",(0,i.yg)("inlineCode",{parentName:"p"},"createDispatchWithMiddlewareHook")," is called, ",(0,i.yg)("em",{parentName:"p"},"not")," when the ",(0,i.yg)("inlineCode",{parentName:"p"},"useDispatch")," hook is called.")),(0,i.yg)("h5",{id:"createdispatchwithmiddlewarehookfactory"},(0,i.yg)("inlineCode",{parentName:"h5"},"createDispatchWithMiddlewareHookFactory")),(0,i.yg)("p",null,"This method take a React context instance and creates an instance of ",(0,i.yg)("inlineCode",{parentName:"p"},"createDispatchWithMiddlewareHook")," which uses that context. (see ",(0,i.yg)("a",{parentName:"p",href:"https://react-redux.js.org/using-react-redux/accessing-store#providing-custom-context"},"Providing custom context"),")"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre",className:"language-ts"},"import { createContext } from 'react'\nimport { createDynamicMiddleware } from '@reduxjs/toolkit/react'\nimport type { ReactReduxContextValue } from 'react-redux'\n\nconst context = createContext<ReactReduxContextValue | null>(null)\n\nconst dynamicMiddleware = createDynamicMiddleware()\n\nconst createDispatchWithMiddlewareHook =\n  dynamicMiddleware.createDispatchWithMiddlewareHookFactory(context)\n\nconst useListenerDispatch = createDispatchWithMiddlewareHook(\n  listenerMiddleware.middleware\n)\n\nfunction Component() {\n  const dispatch = useListenerDispatch()\n\n  useEffect(() => {\n    const unsubscribe = dispatch(addListener({ actionCreator, effect }))\n    return unsubscribe\n  }, [dispatch])\n}\n")),(0,i.yg)("h2",{id:"third-party-libraries-and-frameworks"},"Third-party Libraries and Frameworks"),(0,i.yg)("p",null,"There are a few good external libraries out there that can help you add the above functionality automatically:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://github.com/markerikson/redux-ecosystem-links/blob/master/reducers.md#dynamic-reducer-injection"},"Redux Ecosystem Links: Reducers - Dynamic Reducer Injection"))))}p.isMDXComponent=!0},5680:(e,n,t)=>{t.d(n,{xA:()=>s,yg:()=>h});var r=t(6540);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var d=r.createContext({}),l=function(e){var n=r.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},s=function(e){var n=l(e.components);return r.createElement(d.Provider,{value:n},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,d=e.parentName,s=c(e,["components","mdxType","originalType","parentName"]),u=l(t),m=i,h=u["".concat(d,".").concat(m)]||u[m]||p[m]||a;return t?r.createElement(h,o(o({ref:n},s),{},{components:t})):r.createElement(h,o({ref:n},s))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,o=new Array(a);o[0]=m;var c={};for(var d in n)hasOwnProperty.call(n,d)&&(c[d]=n[d]);c.originalType=e,c[u]="string"==typeof e?e:i,o[1]=c;for(var l=2;l<a;l++)o[l]=t[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);