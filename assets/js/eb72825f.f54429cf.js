"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4370],{720:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>u});const r=JSON.parse('{"id":"usage/structuring-reducers/reusing-reducer-logic","title":"Reusing Reducer Logic","description":"Structuring Reducers > Reusing Reducer Logic: Patterns for creating reusable reducers","source":"@site/../docs/usage/structuring-reducers/ReusingReducerLogic.md","sourceDirName":"usage/structuring-reducers","slug":"/usage/structuring-reducers/reusing-reducer-logic","permalink":"/usage/structuring-reducers/reusing-reducer-logic","draft":false,"unlisted":false,"editUrl":"https://github.com/reduxjs/redux/edit/master/website/../docs/usage/structuring-reducers/ReusingReducerLogic.md","tags":[],"version":"current","lastUpdatedAt":1747212223000,"frontMatter":{"id":"reusing-reducer-logic","title":"Reusing Reducer Logic","description":"Structuring Reducers > Reusing Reducer Logic: Patterns for creating reusable reducers"},"sidebar":"docs","previous":{"title":"Updating Normalized Data","permalink":"/usage/structuring-reducers/updating-normalized-data"},"next":{"title":"Immutable Update Patterns","permalink":"/usage/structuring-reducers/immutable-update-patterns"}}');var c=n(4848),a=n(8453);const i={id:"reusing-reducer-logic",title:"Reusing Reducer Logic",description:"Structuring Reducers > Reusing Reducer Logic: Patterns for creating reusable reducers"},o="Reusing Reducer Logic",s={},u=[{value:"Customizing Behavior with Higher-Order Reducers",id:"customizing-behavior-with-higher-order-reducers",level:2},{value:"Collection / Item Reducer Pattern",id:"collection--item-reducer-pattern",level:2}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsx)(t.header,{children:(0,c.jsx)(t.h1,{id:"reusing-reducer-logic",children:"Reusing Reducer Logic"})}),"\n",(0,c.jsxs)(t.p,{children:['As an application grows, common patterns in reducer logic will start to emerge. You may find several parts of your reducer logic doing the same kinds of work for different types of data, and want to reduce duplication by reusing the same common logic for each data type. Or, you may want to have multiple "instances" of a certain type of data being handled in the store. However, the global structure of a Redux store comes with some trade-offs: it makes it easy to track the overall state of an application, but can also make it harder to "target" actions that need to update a specific piece of state, particularly if you are using ',(0,c.jsx)(t.code,{children:"combineReducers"}),"."]}),"\n",(0,c.jsxs)(t.p,{children:["As an example, let's say that we want to track multiple counters in our application, named A, B, and C. We define our initial ",(0,c.jsx)(t.code,{children:"counter"})," reducer, and we use ",(0,c.jsx)(t.code,{children:"combineReducers"})," to set up our state:"]}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-js",children:"function counter(state = 0, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1\n    case 'DECREMENT':\n      return state - 1\n    default:\n      return state\n  }\n}\n\nconst rootReducer = combineReducers({\n  counterA: counter,\n  counterB: counter,\n  counterC: counter\n})\n"})}),"\n",(0,c.jsxs)(t.p,{children:["Unfortunately, this setup has a problem. Because ",(0,c.jsx)(t.code,{children:"combineReducers"})," will call each slice reducer with the same action, dispatching ",(0,c.jsx)(t.code,{children:"{type : 'INCREMENT'}"})," will actually cause ",(0,c.jsx)(t.em,{children:"all three"})," counter values to be incremented, not just one of them. We need some way to wrap the ",(0,c.jsx)(t.code,{children:"counter"})," logic so that we can ensure that only the counter we care about is updated."]}),"\n",(0,c.jsx)(t.h2,{id:"customizing-behavior-with-higher-order-reducers",children:"Customizing Behavior with Higher-Order Reducers"}),"\n",(0,c.jsxs)(t.p,{children:["As defined in ",(0,c.jsx)(t.a,{href:"/usage/structuring-reducers/splitting-reducer-logic",children:"Splitting Reducer Logic"}),", a ",(0,c.jsx)(t.em,{children:"higher-order reducer"}),' is a function that takes a reducer function as an argument, and/or returns a new reducer function as a result. It can also be viewed as a "reducer factory". ',(0,c.jsx)(t.code,{children:"combineReducers"})," is one example of a higher-order reducer. We can use this pattern to create specialized versions of our own reducer functions, with each version only responding to specific actions."]}),"\n",(0,c.jsx)(t.p,{children:"The two most common ways to specialize a reducer are to generate new action constants with a given prefix or suffix, or to attach additional info inside the action object. Here's what those might look like:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-js",children:"function createCounterWithNamedType(counterName = '') {\n  return function counter(state = 0, action) {\n    switch (action.type) {\n      case `INCREMENT_${counterName}`:\n        return state + 1\n      case `DECREMENT_${counterName}`:\n        return state - 1\n      default:\n        return state\n    }\n  }\n}\n\nfunction createCounterWithNameData(counterName = '') {\n  return function counter(state = 0, action) {\n    const { name } = action\n    if (name !== counterName) return state\n\n    switch (action.type) {\n      case `INCREMENT`:\n        return state + 1\n      case `DECREMENT`:\n        return state - 1\n      default:\n        return state\n    }\n  }\n}\n"})}),"\n",(0,c.jsx)(t.p,{children:"We should now be able to use either of these to generate our specialized counter reducers, and then dispatch actions that will affect the portion of the state that we care about:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-js",children:"const rootReducer = combineReducers({\n  counterA: createCounterWithNamedType('A'),\n  counterB: createCounterWithNamedType('B'),\n  counterC: createCounterWithNamedType('C')\n})\n\nstore.dispatch({ type: 'INCREMENT_B' })\nconsole.log(store.getState())\n// {counterA : 0, counterB : 1, counterC : 0}\n\nfunction incrementCounter(type = 'A') {\n  return {\n    type: `INCREMENT_${type}`\n  }\n}\nstore.dispatch(incrementCounter('C'))\nconsole.log(store.getState())\n// {counterA : 0, counterB : 1, counterC : 1}\n"})}),"\n",(0,c.jsx)(t.p,{children:"We could also vary the approach somewhat, and create a more generic higher-order reducer that accepts both a given reducer function and a name or identifier:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-js",children:"function counter(state = 0, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1\n    case 'DECREMENT':\n      return state - 1\n    default:\n      return state\n  }\n}\n\nfunction createNamedWrapperReducer(reducerFunction, reducerName) {\n  return (state, action) => {\n    const { name } = action\n    const isInitializationCall = state === undefined\n    if (name !== reducerName && !isInitializationCall) return state\n\n    return reducerFunction(state, action)\n  }\n}\n\nconst rootReducer = combineReducers({\n  counterA: createNamedWrapperReducer(counter, 'A'),\n  counterB: createNamedWrapperReducer(counter, 'B'),\n  counterC: createNamedWrapperReducer(counter, 'C')\n})\n"})}),"\n",(0,c.jsx)(t.p,{children:"You could even go as far as to make a generic filtering higher-order reducer:"}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-js",children:"function createFilteredReducer(reducerFunction, reducerPredicate) {\n    return (state, action) => {\n        const isInitializationCall = state === undefined;\n        const shouldRunWrappedReducer = reducerPredicate(action) || isInitializationCall;\n        return shouldRunWrappedReducer ? reducerFunction(state, action) : state;\n    }\n}\n\nconst rootReducer = combineReducers({\n    // check for suffixed strings\n    counterA : createFilteredReducer(counter, action => action.type.endsWith('_A')),\n    // check for extra data in the action\n    counterB : createFilteredReducer(counter, action => action.name === 'B'),\n    // respond to all 'INCREMENT' actions, but never 'DECREMENT'\n    counterC : createFilteredReducer(counter, action => action.type === 'INCREMENT')\n};\n"})}),"\n",(0,c.jsx)(t.p,{children:"These basic patterns allow you to do things like having multiple instances of a smart connected component within the UI, or reuse common logic for generic capabilities such as pagination or sorting."}),"\n",(0,c.jsxs)(t.p,{children:["In addition to generating reducers this way, you might also want to generate action creators using the same approach, and could generate them both at the same time with helper functions. See ",(0,c.jsx)(t.a,{href:"https://github.com/markerikson/redux-ecosystem-links/blob/master/action-reducer-generators.md",children:"Action/Reducer Generators"})," and ",(0,c.jsx)(t.a,{href:"https://github.com/markerikson/redux-ecosystem-links/blob/master/reducers.md",children:"Reducers"})," libraries for action/reducer utilities."]}),"\n",(0,c.jsx)(t.h2,{id:"collection--item-reducer-pattern",children:"Collection / Item Reducer Pattern"}),"\n",(0,c.jsx)(t.p,{children:"This pattern allows you to have multiple states and use a common reducer to update each state based on an additional parameter inside the action object."}),"\n",(0,c.jsx)(t.pre,{children:(0,c.jsx)(t.code,{className:"language-js",children:'function counterReducer(state, action) {\n    switch(action.type) {\n        case "INCREMENT" : return state + 1;\n        case "DECREMENT" : return state - 1;\n    }\n}\n\nfunction countersArrayReducer(state, action) {\n    switch(action.type) {\n        case "INCREMENT":\n        case "DECREMENT":\n            return state.map( (counter, index) => {\n                if(index !== action.index) return counter;\n                return counterReducer(counter, action);\n            });\n        default:\n            return state;\n    }\n}\n\nfunction countersMapReducer(state, action) {\n    switch(action.type) {\n        case "INCREMENT":\n        case "DECREMENT":\n            return {\n                ...state,\n                state[action.name] : counterReducer(state[action.name], action)\n            };\n        default:\n            return state;\n    }\n}\n'})})]})}function l(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,c.jsx)(t,{...e,children:(0,c.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var r=n(6540);const c={},a=r.createContext(c);function i(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(c):e.components||c:i(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);